[{"title":"第五章 串","url":"/2024/11/02/第五章 串/","content":"# 串的定义\n\n**串是由零个或者多个字符组成的有限序列，又叫字符串。**\n\n一般记为s=\"a1a2…an\"(n≥0)，**s是串的名字，引号中的字符序列是串的值而不是内容**。ai(1≤i≤n)可以是字母、数字等，i是改字符在串中的位置。\n\n串中的字符数目n称为串的长度，**定义中谈到“有限”指的是长度n是有一个有限的数值**。\n\n零个字符的串称为空串，长度为0，直接用两个“\"\"”表示。\n\n所谓的序列，说明串的相邻字符之间有前驱和后继的关系。\n\n空格串：只是包含空格的串。\n\n字串和主串：串中任意个数的连续字符组成的子序列称为该串的子串，包含字串的串称为主串。\n\n字串在珠串的位置就是字串的第一个字符在主串的序号。\n\n# 串的比较\n\n对于两个不相等的串进行判断大小：\n\n给定义两个串：s=“a1a2…an”，t=“b1b2…bm”，当满足以下条件之一时，s<t。\n\n（1）n<m，且ai = bi（i=1,2,…,n）\n\n例如：s=“hap”，t=“happy”，s<t\n\n（2）存在某个≤min(m,n)，使得ai=bi(i=1,2,…,k-1),ak<bk\n\n例如：当s-“happen”，t-“happy”，因为两串的前4个字母均相同，而两串第5个字母(k值)，字母e的ASCII码是101，而字母y的ASCI码是121，显然e<y，所以s<t。\n\n# 串的抽象数据类型\n\n```\nADT 串 (string）\nData\n串中元素仅由一个字符组成，相邻元素具有前驱和后继关系\nOperation\n        StrAssign(T,*chars):生成一个其值等于字符串常量 chars 的串T。\n        StrCopy(T,S):串s存在，由串S复制得串T。\n        Clearstring(s):串s存在，将串清空。\n        stringEmpty(S):若串S为空，返回true，否则返回 false。\n        strLength(s):返回串s的元素个数，即串的长度。\n        StrCompare(s,T):若S>T,返回值>0,若S=T,返回0,若S<T,返回值<0。\n        Concat(T,s1,S2):用T返回由S1和S2联接而成的新串。\n        Substring(Sub,s,pos,len):串s存在,1≤pos≤StrLength(s),且            0≤len≤StrLength(s)-pos+1，用Sub返回串s的第pos个字符起长度为 len的子串。 \n        Index(S,T,pos):串S和T存在,T是非空串,1≤pos≤StrLength(s)。若主串s中存在和串T值相同的子串，则返回它在主串s中第pos个字符之后第一次出现的位置，否则返回0。\n        Replace(s,T,V):串S、T和V存在,T是非空串。用v替换主串s中出现的所有与T相等的不重叠的子串。\n        StrInsert(s,pos,T):串S和T存在,1≤pos≤StrLength(s)+1。在串s的第pos个字符之前插入串 T。\n        StrDelete(s,pos,len):串s存在,1≤pos<strLength(s)-len+1。从串s中删除第pos个字符起长度为 len 的子串。\nendADT\n```\n\n## Index算法\n\n```\nint Index(String S,Strinf T,int pos)\n{\n    int n,m,i;\n    String sub;\n    if(pos>0){\n     n = StrLength(S); //得到主串S的长度\n     m = StrLength(T); //得到字串T的长度\n     i = pos;\n     while(i <= n-m+1){\n          SubString(sub,S,i,m);//主串中第i个位置开始长度与T相等的字串给sub\n          if(SubString(sub,T)!=0)//如果两串不相等\n                  ++i;\n          else\n                  return i; \n       }\n    }\nreteun 0;\n}\n```\n\n# 串的存储结构\n\n## 串的顺序存储结构\n\n串的顺序存储结构是用一组地址连续的存储单元来存储串中的字符序列的。\n\n比如：计算机中寸在一个自由存储区，叫做“堆”。这个堆可由C语言的动态分配函数malloc()和free()来管理\n\n## 串的链式存储结构\n\n如果是简单地应用链表存储串值，一个结点对应一个字符，就会存在很大的空间浪费。因此一个结点，可以存放一个字符，也可以考虑放多个字符，最后一个结点若是未被沾满，可以用“#”等非串字符补传，比如：\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/11/image_719f922a2a3a5e5ff62159498d7564a9.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/11/image_719f922a2a3a5e5ff62159498d7564a9.png)\n\n# 模式匹配算法\n\n去找一个单词在一篇文章中的定位为，这种字串的定位操作通常称做串的模式匹配。\n\n```\nint Index(Strinf S,String T,int pos){\n      int i = pos;       //i用于字串S中当前的位置下标值，从pos位置开始匹配\n      int j = 1;         //j用于字串T当前位置下标值\n      while(i≤S[0]&&j≤T[0]){    //当i小于S的长度并且j小于T的长度是，循环继续\n           if(S[i] == T[j])    //两字母相等则继续\n           {\n               ++i;\n               ++j;\n           }else{              //指针后退重新开始匹配\n                i = i-j+2;     //i退回上次匹配首尾的下一位\n                j = i;        //j退回到字串T的首位\n            }\n     }\n      if(j >T[0]){\n         return i-T[0];\n     }else{\n         retrun 0;\n     }\n}\n```\n","tags":["算法"],"categories":["数据结构"]},{"title":"第四章 栈与队列","url":"/2024/10/12/第四章 栈与队列/","content":"# 栈的定义\n\n**栈（stack）是限定仅在表尾进行插入和删除操作的线性表。（指的是栈顶）栈顶：插入和删除的一端栈底：另外一段空栈：不含任何数据元素的栈栈又称：后进先出的线性表，简称LIFO结构**\n\n注意：栈元素具有线性表关系，即前驱后继关系。特殊之处就是这个线性表的插入和删除位置，只能在栈顶进行。栈底是固定的，最先进栈的只能在栈底。\n\n栈的**插入操作**叫做**进栈，也叫压栈、入栈。**\n\n栈的**删除操作**，叫做**出栈**，也叫弹栈。\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/10/image_88b7c7d20dbe75a35fa94bf1f5209ca7.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/10/image_88b7c7d20dbe75a35fa94bf1f5209ca7.png)\n\n# 栈的抽象数据类型\n\npush：插入（进栈）      pop：删除（出栈）\n\n```\nADT 栈（stack）\nData\n    同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。\noperation\n    InitStack(*S):初始化操作，建立一个空栈s。\n    DestroyStack(*S):若栈存在，则销毁它。\n    CleanrStack(*S):将栈清空。\n    StackEmpyt(S):若栈为空，返回true，否则返回false。\n    GetTop(S,*e):若栈存在且非空，用e返回s的栈元素\n    Push(*S,e):若栈s存在，插入新元素e到栈s中并称为栈顶元素。\n    StatckLengtg(S):返回栈s的元素个数。\nendADT\n```\n\n# 栈的顺序存储结构及实现\n\n## 栈的顺序存储结构\n\n栈的顺序结构其实就是线性表顺序存储的简化，称为顺序栈。\n\n```\ntypedef int SElemType; //SElemType类型根据实际情况\ntypedef struct{\n      SElemType data[MAXSIZE];\n      int top; //栈顶指针\n}SqStack;\n```\n\n## 栈的顺序存储结构-进栈\n\n```\n//插入元素e为新的栈顶元素\nStatus Push(SqStack *S,SElemType){\n      if(S->top == MAXSIZE -1){   //如果栈满\n          return ERROR;\n      }\n      S->top++;     //栈顶指针加1\n      S->data[S->top]=e;  //将新插入元素赋值给栈顶空间\n      return OK;\n}\n```\n\n## 栈的顺序存储结构--出栈操作\n\n```\n//若栈不为空，则删除S的栈顶元素怒，用e返回其值，并返回OK，否则ERROR\nStatus Pop(SqStack *S,SElemType *e){\n     if(S->top==-1){\n          return ERROR;\n     }\n     *e=S->data[S->top];  //将要删除栈顶元素赋值给e\n     S->top--;//栈顶指针减一\n     return OK;\n}\n```\n\n# 两站共享空间\n\n```\ntypedef struct\n{\n      SElemType data[MAXSIZE];\n      int top1; //栈1栈顶指针\n      int top2; //栈2栈顶指针\n}SqDoubleSatck;\n```\n\n### 两站共享空间的push方法\n\n```\n Status Push(SqDoubleStack *S,SElemType e,int stackNumber){\n       if(S->top1+1=S->top2)   //栈满了\n            return ERROR;\n       if(statckNumber==1)        //栈1有元素进栈\n            S->data[++S->top1]=e   //如果是栈1则线top1+1后 给数组元素赋值\n       else if(statckNumber==2)       //栈2有元素进栈\n            S-data[--S->top2]=e   //如果是栈2，则线top2-1后 给数组元素赋值\n       return OK;\n}\n```\n\n### 两站共享空间的pop方法，判断只是栈1栈2的参数stackNumber\n\n```\nStatus Pop(SqDoubleStack *S,SElemType *e,int stackNumber){\n        if(statckNumber == 1)\n        {\n                 if(S->top = -1)\n                   return ERROR;\n                 *e = S->data[S->top1--1];    //将栈1的栈顶元素出栈\n        }\n        else if(stackNumber == 2){\n                 if(S->top2==MAXSIZE)\n                    return ERROR;\n                 *e = S->data[S->top2++];  //栈2的栈顶元素出栈\n        }\n      return OK;\n}\n```\n\n# 栈的链式存储结构以及实现\n\n## 栈的链式存储结构\n\n栈的链式存储结构，简称为链栈。\n\n链栈代码定义：\n\n```\ntypedef struct StackNode{\n     SElemType data;\n     struct StatckNode *next;\n}\n\ntypedef struct\n{\n    LinkStackPrt top;\n    int count;\n}LinkStack;\n```\n\n### 栈的链式存储结构--进栈操作\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/10/image_d97fb64974b580b71d63537e9a8e3737.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/10/image_d97fb64974b580b71d63537e9a8e3737.png)\n\n```\nStatus Push(LinkStack *S,SElemType e){\n      LinkStackPtr s=(LinkStackPrt)malloc(sizeof(StackNode));\n      s->data=e;\n      s->next=S->top;   //把当前栈顶元素赋值给新节点的直接后继。见图1\n      S->top=s;     //把新的结点s赋值给栈顶指针，见图2\n      S->count++;\n      return OK;\n}\n```\n\n### 栈的链式存储结构--出栈操作\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/10/image_b40efa6bd4b0f252e18cda94c2447f9e.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/10/image_b40efa6bd4b0f252e18cda94c2447f9e.png)\n\n```\nStatus Pop(LinkStack *S,SElemType *e){\n       LinkStackPrt p;\n       if(StackEmpty(*S))\n           return ERROR;\n       *e=S->top->data;\n       p=S->top;     //将栈顶结点赋值给p，见图3\n       S->top=S->top->next;   //使得栈顶指针下移一位，指向后一个结点，见图4\n       free(p);               //释放结点p\n       S->count--;\n       return OK;\n}\n```\n\n使用建议：\n\n如果栈的使用过程中元素变化不可预料，有时候小，有时候大，使用链栈。\n\n如果变化在可控范围内，使用顺序栈。\n\n# 栈的作用\n\n栈的引用同简化了程序设计的问题，划分了不同关注层次，使得思考范围缩小，更加聚焦我们要解决的问题核心。\n\n# 栈的应用--递归\n\n递归：把一个直接调用自己或通过一系列的调用语句间接的调用自己的函数，称为递归函数。\n\n例如：\n\n```\nint Fbi(int i){\n      if(i<2){\n           return i == 0 ? 0 : 1;\n      }\n      return Fbi(i-1)+Fbi(i-2);\n}\n\nint main(){\n       int i;\n       printf(\"递归显示斐波那契数列：\\n\");\n       for(i = 0;i<40;i++)\n           printf(\"%d\",Fbi(i));\n       return 0;\n}\n```\n\n注意的是：每个递归定义必须至少有一个条件，满足递归不再进行，即不再引用自身而是返回值退出。\n\n# 栈的应用--四则运算表达式求值\n\n## 后缀（逆波兰）表示法的定义\n\n一种不需要括号的后缀表达法，称为逆波兰\n\n正常数学表达式：9+（3-1）x3+10÷2\n\n后缀表达式：9 3 1-3 * + 10 2 / +\n\n后缀原因在于所有的符号都是在要运算数字的后面。\n\n## 后缀表达式的计算结果\n\n后缀表达式：9 3 1-3 * + 10 2 / +\n\n规则：从左到右遍历表达式的每个数字和符号，遇到数字就进栈，遇到符号就将处于栈顶的两个数字出栈，进行运算，运算结果在进栈。\n\n## 中缀表达式转后缀表达式\n\n正常数学表达式：9+（3-1）x3+10÷2也就是中缀表达式。\n\n转换规则：从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，即后缀表达式的一部分。若是符号，判断其与栈顶符号的优先级，是右括号或优先级不高于栈顶符号（乘除优先加减）则栈顶元素一次出栈并输出，将当前符号进栈，一直到输出后缀表达式为止。\n\n# 队列的定义\n\n队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。\n\n队列是一种先进先出的线性表，简称FIFO。允许插入的一段称为队尾，允许删除的一端称为队头。\n\n例如：q=(a1,a2,…,an)，那么a1就是队头元素，an就是队尾。\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/10/image_93a72f8e79c5d40fdb6c01b67fb7304b.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/10/image_93a72f8e79c5d40fdb6c01b67fb7304b.png)\n\n# 队列的抽象数据类型\n\n```\nADT 队列(Queue)\nData\n    同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。\nOperation\n    InitQueue(*Q):初始化操作，建立一个空队列Q\n    DestroyQueue(*Q):若队列Q存在，则销毁\n    ClearQueue(*Q):将队列Q清空\n    QueueEmpty(Q):若队列Q为空，返回ture，否则false\n    GetHead(Q,*Q):若队列Q存在且非空，用e返回队头元素\n    EnQueue(*Q,e):队列Q存在，插入新元素e到队列Q称为队尾元素\n    DeQueue(*Q,e):删除队列Q中队头元素，并用e返回其值\n    QueueLength(Q):返回队列Q的元素个数\nendADT\n```\n\n# 循环队列\n\n## 队列顺序存储的不足\n\n容易出现假溢出\n\n## 循环队列的定义\n\n解决假溢出的办法就是后面满了，再从头开始，头尾相接的循环。这种队列头尾相接的顺序存储结构称为循环队列。\n\n办法1：设置一个标志了flag，当front=rear，且flag=0时为队列空，当front=rear，且flag=1时为队列满。\n\n办法2：当队列空时，条件时front=rear。当队列满时，修改其条件，保留一个元素空间。也就是数，队列满时，数组还有一个空闲单元。\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/10/image_d63dbe79128fc6ec3c247812a0481301.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/10/image_d63dbe79128fc6ec3c247812a0481301.png)\n\n在第二种方法中，由于rear可能比front大，也可以比front小，若队列的最大尺寸为QueueSize，那么队列满的条件时(rear+1)%QueueSize==front（取模的目的时为了整合rear与front大小为一个问题）。比如当QueueSize=5，左边的图front=0,而rear4，（4+1）%5=0，所以此时队列满，再比如右图，front=2而rear=1，所以（1+1）%5=2，所以队列也是满的，对于下图，ftont=2,而rear=0，(0+1)%5=1，1≠2，所以此时队列没有满。\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/10/image_b84b22038fb5eda0d58c83ca4f9cd977.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/10/image_b84b22038fb5eda0d58c83ca4f9cd977.png)\n\n当rear>front，即图1和图2，此时队列的长度为rear-front，但当rear<front，如上图和下图3，队列长度分为两段，一段QueueSize-front，另一段时0+rear，加在一起的长度为rear-front+QueueSzie。\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/10/image_bf18f7afca60ffc1063ab5041a9db5e2.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/10/image_bf18f7afca60ffc1063ab5041a9db5e2.png)\n\n所以通用计算队列长度公式为\n\n(rear - front + QueueSize)%QueueSize\n\n### 循序队列的顺序存储结构代码如下：\n\n```\ntypedef int QElemType;\ntypedef struct\n{\n    QElemType data[MAXSIZE];\n    int front;  //头指针\n    int rear;   //尾指针，队列不为空，指向队列尾元素的下一个位置\n}SqQueue;\n```\n\n### **循环队列的初始化代码**\n\n```\nStatus InitQueue(SqQueue *Q)\n{\n    Q->front=0;\n    Q->rear=0;\n    return OK;\n}\n```\n\n### 循环队列求队列长度的代码\n\n```\n//返回Q的元素个数，也就是队列的当前长度\nint QueueLength(SqQueue Q)\n{\n  return (Q.rear - Q.front+MAXSIZE)%MAXSIZE;\n}\n```\n\n### **循环队列的**入列操作：\n\n```\nStatus EnQueue(SqQueue *Q,QElemType e)\n{\n   if((Q->rear+1)%MAXSIZE==Q->front){   //队列满判断\n                  return ERROR;\n   }\n    Q->data[Q-rear]=e;         //将元素e赋值给队尾\n    Q->rear=(Q->rear+1)%MAXSIZE; //rear指针向后移动一位，若为最后则转到数组头部\n    return OK;\n}\n```\n\n### 循环队列如队列操作代码：\n\n```\nStatus EnQueue(SqQueue *Q,QElemType e)\n{\n   if((Q->rear+1)%MAXSIZE==Q->front)//队列满的判断\n       return ERROR;\n   Q->data[Q->rear]=e;  //将元素e赋值给队尾\n   Q->rear=(Q->rear+1)%MAXSIZE; //rear指针向后移一位，若到最后则转到数组头部\n   return OK;\n}\n```\n\n### 循环队列的出队列操作代码：\n\n```\nStatus DeQueue(SqQueue *Q,QElemType *e)\n{\n     if(Q->front == Q->rear)\n         return ERROR;\n     *e=Q->data[Q->front];\n     Q->front=(Q->front+1)%MAXSIZE;\n}\n```\n\n# 队列的链式存储结构及实现\n\n队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出，我们把它简称链队列。\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/10/image_e66f05dc08c49df39eccdee7590bd65c.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/10/image_e66f05dc08c49df39eccdee7590bd65c.png)\n\n将队头指针指向链队列的头结点，而队尾指针指向终端节点。空队列时，front和rear都指向头结点。\n\n### 链队列的结构为：\n\n```\ntypedef int QElemType;\ntypedef struct QNone     //结点结构\n{\n     QElemType data;\n     struct QNone *next;\n}QNone,*QueuePtr;\n\n\ntypedef struct\n{\n   QueuePtr front,rear;//队头、队尾指针\n}\n```\n\n## 队列链式存储结构--入队操作\n\n### 入队操作，其实就是链表尾部插入结点\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/10/image_1755ae752128e08adedf1ea588953631.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/10/image_1755ae752128e08adedf1ea588953631.png)\n\n```\nStatus EnQueue(LinkQueue *Q,QElemType e)\n{\n     QueuePtr s=(QueuePtr)malloc(sizeof(QNone));\n     if(!s)           //存储分配失败\n       exit(OVERFLOW);\n     s->data=e;\n     s->next=NULL;\n     Q->rear->next=s;  //把拥有元素e的新节点s赋值给原队尾结点的后继\n     Q->rear=s;  ///把当前的s设置为队尾结点，rear指向s\n     return OK;\n}\n```\n\n## 队列的链式存储结构--出队操作\n\n出队操作，就是头结点的后继节点出队，将头结点的后继改为它后面的结点，若链表除头结点外只剩下一个元素，则需要将rear指向头结点。\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/10/image_c0572c9f7622349cdda81e110c46a2d6.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/10/image_c0572c9f7622349cdda81e110c46a2d6.png)\n\n```\nStatus DeQueue(LinkQueue *Q,QElemType *e)\n{\n      QueuePtr p;\n      if(Q->front==Q->rear)   \n          return ERROR;\n      p=Q->front->next;//将要删除的队头结点暂存到p\n      *e=p->data;     //将要删除的队头几点赋值给e\n      Q->front->next=p-next; //将队头结点的后继p->next赋值给头结点后继\n      if(Q->rear==p)   //若队头就是队尾，删除后将rear指向头结点\n         Q-<rear=Q->front;\n      free(p);\n      retrun OK;\n}\n```\n\n# 总结\n\n栈（stack）限定仅在表尾进行插入和删除操作的线性表。\n\n队列（queue）是值允许在一端进行插入操作，而另外一端进行删除操作的线性表。\n\n对于栈：如果两个相同数据类型的栈，则可以用数组的两段作栈底的地方来让两个栈共享数据，可以最大化利用数组的空间。\n\n对于队列：为了避免数组插入和删除时需要移动数据，于是引用了循环队列，使得队头和队尾进行数组中循环变化，结局了移动数据的时间损耗。\n","tags":["算法"],"categories":["数据结构"]},{"title":"2024年金砖竞赛--云边端赛项","url":"/2024/10/08/2024年金砖竞赛--云边端赛项/","content":"# 大致\n\n```\n打开视频文件：使用 cv2.VideoCapture 打开指定路径的视频文件。\n检查是否成功打开：通过 cap.isOpened() 方法检查是否成功打开了视频文件。\n读取视频帧：在循环中使用 cap.read() 方法逐帧读取视频。\n显示视频帧：使用 cv2.imshow() 方法显示每一帧。\n保存视频帧：定义 save_image 函数来保存当前帧，并以 frame_计数.jpg 的形式命名。\n释放资源并关闭窗口：定义 release_resources函数或者cap.release()cv2.destroyAllWindows()释放摄像头并关闭所有窗口\n键盘输入监听：使用 cv2.waitKey() 方法等待一小段时间（这里设置为 1 毫秒），并在用户按下 'q' 键时退出循环。\n```\n\n# 读取视频\n\n```\nvideo_path = 'path_to_your_video.mp4'  # 将此处替换为你的MP4文件路径\ncap = cv2.VideoCapture(video_path)\n```\n\n# 判断是否打开\n\n```\n# 检查视频是否成功打开\nif not cap.isOpened():\n    print(\"Error: Could not open video.\")\n```\n\n# 获取视频的宽度/长度像素\n\n```\n# 获取视频的宽度\nframe_width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))\n# 获取视频的长度\nframe_height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))\n```\n\n# 读取视频图像，赋值给ret，frame\n\n```\nwhile True:\n        # 读取帧\n        ret, frame = cap.read()\n        if not ret:\n            print(\"Cannot receive frame (stream end?). Exiting ...\")\n            break\n    \n        # 显示帧\n        cv2.imshow('Video', frame)\n    \n        # 按下 'q' 键退出\n        if cv2.waitKey(1) == ord('q'):\n            break\n    \n        # 保存当前帧\n        save_image(frame, frame_count)\n        frame_count += 1\n```\n\n# 释放资源\n\n```\n# 释放摄像头并关闭所有窗口\n    cap.release()\n    cv2.destroyAllWindows()\n```\n\n# 判断文件夹是否存在\n\n```\n# 检查输出目录是否存在，如果不存在则创建\noutput_dir = 'rename'\nif not os.path.exists(output_dir):\n    os.makedirs(output_dir)\n```\n\n# 查看文件夹的文件，并且返回给一个数组\n\n```\nfilenamer_list = [entry.name for entry in os.scandir(folder_path) if entry.is_file()]\nos.scandir(picture) 会扫描指定文件夹picture下的所有内容\n```\n\n# 将picture文件夹内的所有.png 拓展名文件修改为.jpg拓展名，保存在rename 文件夹内\n\n```\n# 将文件名的拓展名从.png修改为.jpg\nnew_filename = filename.replace(\".png\", \".jpg\")\n\n# 重命名文件到目标文件夹\nos.rename(source_file, target_file)\n```\n\n# 读取当前路径的图片\n\n```\nimg = cv2.imread('test.png')\n```\n\n# 将图像转换成灰度\n\n```\nimg_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n```\n\n# 传入灰色图像，阈值变量为threshold，超过阈值的像素修改为255，采用cv2.THRESH_BINARY_INV\n\n```\ncv2.threshold(img_gray, threshold, 255, cv2.THRESH_BINARY_INV)\n              图像       阈值变量\n```\n\n# 读取当前目录下的wuyanzu.png的灰度图片；进行图像边缘检测传入最小阈值为128，最大阈值为 200\n\n```\n# 读取当前路径下的“wuyanzu.png”图片，并转为灰度图\nimg_wuyanzu = cv2.imread('wuyanzu.png', cv2.IMREAD_GRAYSCALE)\n\n# 使用 Canny 边缘检测，设置最小阈值为128，最大阈值为200\nedges = cv2.Canny(img_wuyanzu, 128, 200)\n```\n\n# 对图像进行图像的均衡化对比度限制值为2直方图均衡化的网格大小为 8*8。\n\n```\n# 创建CLAHE对象，设置对比度限制为2，网格大小为8x8\nclahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))\n```\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/10/image_2cf8f5053464f20113c15cb66c588fc5.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/10/image_2cf8f5053464f20113c15cb66c588fc5.png)\n"},{"title":"Dx-C511模块连接华为云OTA","url":"/2024/09/26/Dx-C511模块连接华为云下载固件/","content":"1、配置APN\n\nAT+QICSGP=1,1,\"cmnbiot\",\"\",\"\"\n\n2、开启移动网络\n\nAT+NETOPEN\n\n3、设置客户端ID\n\nAT+MCONFIG=\"id\",\"用户名\",\"密码\"`AT+MCONFIG=\"667145986bc31504f06f60ee_wulianwang_0_0_20\",\"667145986bc31504f06f60ee_wulianwang\",\"63e106dff798f9ed7d313f33c5e1cffe4ad206abe2121b993d464a8f111a97ba\"`\n\n4、连接mqtt服务器\n\nAT+MIPSTART=\"服务器IP地址\",1883,4\n\n`AT+MIPSTART=\"0ae1ed433d.st1.iotda-device.cn-north-4.myhuaweicloud.com\",1883,4`\n\n5、连接服务器，设置心跳60秒\n\nAT+MCONNECT=1,60\n\n6、订阅数据\n\n`AT+MSUB=\"$oc/devices/667145986bc31504f06f6/sys/events/down\",0`\n\n7、发布长数据\n\n`AT+MPUBEX=\"$oc/devices/667145986bc31504f06f/sys/events/up\",0,0,149`\n\n{\"services\":[{\"service_id\":\"$ota\",\"event_type\":\"version_report\",\"event_time\":\"20151212T121212Z\",\"paras\":{\"sw_version\":\"v1.0\",\"fw_version\": \"v1.0\"}}]}\n\n8、开启HTTP模式\n\nAT$HTTPOPEN\n\n9、发送请求头\n\nAT$HTTPRQH=Authorization,Bearer 627fd1b1a3f07e7e977b388c112a3af8acf60349c885e3d7c4490661e208b64a\n\n10、发送URL\n\nAT$HTTPPARA=https://117.78.5.125:8943/iodm/dev/v2.0/upgradefile/applications/d47eeb52098345898ba95b1be5cbd7c4/devices/667145986bc31504f06f60ee_wulianwang/packages/66e2cfd51bd30f6d19a24533,8943,1,0\n\n11、发送get请求\n\nAT$HTTPACTION=0\n","tags":["华为IOT"],"categories":["华为云IOT连接"]},{"title":"第三章 线性表","url":"/2024/09/09/第三章 线性表/","content":"# 1.线性表的定义\n\n线性表：零个或多个数据元素的有限序列。\n\n它是一个序列。**如果有多个元素，则第一个元素无前驱，最后一个元素无后继，其他的每一个元素只有一个前驱和后继。**\n\n将线性表记为 a1，a2，a3，则a1是a2的直接前驱元素，a3是a2的直接后继元素。有且仅仅只有一个直接前驱和一个直接后继。\n\n所以线性表元素的个数n(n≥0)定义为**线性表的长度**，当n＝0，为**空表**。\n\n在非空表中的每个元素都有一个确定的位置，比如a1是第一个，a3是最后一个。a2是第二个，称2为数据元素a2在线性表中的**位序**。\n\n# 2.线性表的抽象数据类型\n\n当传递一个参数给函数的时候，这个参数会不会在函数内被改动决定了**使用什么参数形式**。\n\n如果需要被改动，则需要**传递指向这个参数的指针**。\n\n如果不用被改动可以**直接传递这个参数**。\n\n总结：需要改动则传递参数的**指针**，不需要则传递这个**参数**。\n\n# 3.线性表的顺序存储结构\n\n## 顺序存储结构\n\n线性表的顺序存储结构，指的是****用一段地址连续的存储单元依次存储线性表的数据元素。****\n\n说白了就是：在内存中，占个地方，通过占位的形式，将一定的内存空间给占，然后把相同数据类型的数据元素一次存放在这里。\n\n使用一维数组来实现顺序存储结构\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/9/image_07d1e446d8b116cfd15553faabca4bdd.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/9/image_07d1e446d8b116cfd15553faabca4bdd.png)\n\n## 数据长度与线性表长度的区别\n\n数组的长度是存放线性表的存储空间长度。\n\n线性表的长度是线性表中数据元素的个数，会变化。\n\n## 地址计算方法\n\nC语言中的数组是从0开始为第一个下标。所以线性表的第i个元素是要存储在数组下标为i-1的位置。\n\n**存储器中的每个存储单元都有自己的编号，这个编号为地址。**\n\n假设占用的是c个存储单元，那么线性表中第i+1个数据元素的存储位置和第i个数据元素的存储位置满足以下关系（LOC表示获得存储位置的函数）\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/9/image_55de4f7918d6dc449ca1f46790bc4d9c.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/9/image_55de4f7918d6dc449ca1f46790bc4d9c.png)\n\n例如：如果LOC(1)为第一个元素的地址，每个元素占用4个存储单元，即C=4，那么第二个元素LOC(2)，就是LOC(1)+4\n\n所以对于第i个数据元素ai的存储位置可以得出ai：\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/9/image_a4d51b982d1eb08b5a90df01964d3a29.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/9/image_a4d51b982d1eb08b5a90df01964d3a29.png)\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/9/image_174ffdb4600e63fb2766a24e75af8551.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/9/image_174ffdb4600e63fb2766a24e75af8551.png)\n\n# 4.顺序存储结构的插入与删除\n\n## 获得元素操作\n\n```hhuhuohu\n// 定义两个宏，分别表示函数执行成功和失败的状态\n#define OK 1\n#define ERROR 0\n\n// 定义一个新的类型名Status，它实际上就是int类型\ntypedef int Status;\n\n// 函数声明：从顺序表L中获取第i个位置的元素，并将其赋值给变量e\n// SqList L:顺序表结构体\n// int i:表示获取元素的位置，也就是索引\n// ElemType *e:这是一个指针，用于存放获取到的元素。\nStatus GetElem(SqList L, int i, ElemType *e) {\n    // 检查i是否在合法范围内，即i大于0且小于等于顺序表的长度\n    if (i < 1 || i > L.length) {\n        // 如果i不合法，返回错误状态ERROR\n        return ERROR;\n    }\n    // 如果i合法，将第i个位置的元素赋值给e指向的变量\n    // 注意：由于数组索引是从0开始的，所以第i个元素实际上是L.data[i-1]\n    *e = L.data[i - 1];\n    // 返回成功状态OK\n    return OK;\n}\n```\n\n## 插入操作\n\n```\n// 函数声明，用于在顺序表L中第i个位置插入元素e，并返回操作状态\nStatus ListInsert(SqList *L, int i, ElemType e) {\n    int k;\n\n    // 检查顺序表是否已满，如果已满，返回错误状态\n    if (L->length == MAXSIZE) return ERROR;\n\n    // 检查插入位置i是否合法，如果不合法（小于1或大于顺序表长度+1），返回错误状态\n    if (i < 1 || i > L->length + 1) return ERROR;\n\n    // 如果插入位置不在表尾\n    if (i <= L->length) {\n        // 从最后一个元素开始，直到要插入的位置，将每个元素向后移动一位\n        for (k = L->length - 1; k >= i - 1; k--) {\n            // 将元素向后移动\n            L->data[k + 1] = L->data[k];\n        }\n    }\n\n    // 将新元素e插入到位置i-1（因为数组索引从0开始）\n    L->data[i - 1] = e;\n\n    // 顺序表长度增加1\n    L->length++;\n\n    // 插入成功，返回成功状态\n    return OK;\n}\n\n```\n\n## 删除操作\n\n```\n// 函数声明，从顺序表L中删除第i个位置的元素，并通过e返回该元素的值，函数返回操作状态\nStatus ListDelete(SqList *L, int i, ElemType *e){\n    int k;\n\n    // 检查顺序表是否为空，如果为空，返回错误状态\n    if(L->length == 0) return ERROR; \n\n    // 检查删除位置i是否正确，即i是否在1到L->length的范围内，如果不正确，返回错误状态\n    if(i < 1 || i > L->length) return ERROR; \n\n    // 将要删除的元素赋值给*e，即通过指针e返回被删除元素的值\n    *e = L->data[i-1];\n\n    // 如果删除的位置不是最后一个元素，则需要将后续元素前移\n    if(i < L->length){\n        for(k = i; k < L->length; k++){\n            // 将位置k的元素前移到位置k-1\n            L->data[k-1] = L->data[k];\n        }\n    }\n\n    // 顺序表的长度减1，因为已经删除了一个元素\n    L->length--;\n\n    // 如果删除操作成功，返回OK\n    return OK;\n}\n\n\n```\n\n## 线性表顺序存储结构的优缺点\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/9/image_13333133983167bb4cd71cd15bea7d30.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/9/image_13333133983167bb4cd71cd15bea7d30.png)\n\n# 5.线性表的链式存储结构\n\n## 顺序存储结构不足的解决办法\n\n缺点：插入和删除需要移动大量元素\n\n## 线性表链式存储结构定义\n\n特点：用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续，也可以不是连续。\n\n存储数据元素信息的**域**称为**数据域**，存储直接后继位置的域称为指针域。\n\n指针域存储的**信息称为指针或链**。这两部分信息组成数据元素ai的**存储映像**，为**结点**。\n\nn个结点（ai的存储映像）链结成一个链表，即为线性表的链式存储结构，因此链表的每个节点只包含每个指针域，称为单链表。\n\n单链表：通过每个节点的指针将线性表的数据元素按照逻辑次序链接在一起。\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/9/image_8ca06caf17426ccd753056ee8b9bfee0.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/9/image_8ca06caf17426ccd753056ee8b9bfee0.png)\n\n链表中第一个节点的存储位置叫做头指针，所以整个链表的存储从头指针开始。之后的每一个节点，就是上一个后继指针指向的位置。最后一个，直接后继不存储，所以线性链表的最后一个节点指针为“NULL”。\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/9/image_c05973f5263e0dceadf26947138c10f6.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/9/image_c05973f5263e0dceadf26947138c10f6.png)\n\n为了方便会在单链表的第一个节点前设一个头节点。\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/9/image_8542d2fedc1ee0879e88a3da161e296c.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/9/image_8542d2fedc1ee0879e88a3da161e296c.png)\n\n## 头指针与头节点的区别\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/9/image_1228d149ebd3d54fe7118927040fdcd3.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/9/image_1228d149ebd3d54fe7118927040fdcd3.png)\n\n## 线性表链式存储结构代码描述\n\n若线性表为空，则头节点的指针域为空\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/9/image_348a891425f2846276f25d45223f98fb.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/9/image_348a891425f2846276f25d45223f98fb.png)\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/9/image_5e4a480fa5b3f39ebeb1a6c0dc6c6bef.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/9/image_5e4a480fa5b3f39ebeb1a6c0dc6c6bef.png)\n\n带有头节点的单链表，如下\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/9/image_544182ab322fecd18a3a63c7c0bdab3d.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/9/image_544182ab322fecd18a3a63c7c0bdab3d.png)\n\n空链表如下\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/9/image_2a20349a12feb1221aba8588734c7b25.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/9/image_2a20349a12feb1221aba8588734c7b25.png)\n\n```\n// 定义链表节点结构体\ntypedef struct None {\n    int data;             // 数据域\n    struct None *next;    // 指向下一个节点的指针\n} Node;                   // 使用 Node 作为别名\n\ntypedef struct None *Link;  // 定义指向 Node 的指针类型 Link\n```\n\n从代码中来看：\n\n结点由存放数据元素的数据域，存放后继节点地址的指针域组成。\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/9/image_9554015f67b9e4719bb4916ffbe4ac12.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/9/image_9554015f67b9e4719bb4916ffbe4ac12.png)\n\n## 单链表的读取\n\n算法思路：\n\n（1）声明一个指针p指向链表的第一个结点，初始化j从1开始。\n\n（2）当j<i时，遍历链表，让p的指针向后移动，不断指向下一结点，j累加i。\n\n（3）若到链表末尾p为空，则说明第i个结点不存。\n\n（4）否则查找成功，返回结点p的数据。\n\n```\nstatic GetElem(LinkList L, int i, ElemType *e)\n{\n    int j;  //声明结点p\n    p = L->next; //让p指向链表L的第一个结点\n    j = 1; //j为计数器\n    while (p && j < i)  //p不为空或计算器j还没有等于i时，循环继续\n    {\n        p = p->next;  //让p指向下一个结点\n        j++;\n    }\n    if (!p || j > i)\n    {\n        return ERROR;  //第i个不存在\n    }\n    *e = p->data;  //读取第i个元素的数据\n    return OK;\n}\n// ||：一个为真，则都为真 &&：要两个都为真\n\n```\n\n# 单链表的插入与删除\n\n### 插入算法思路\n\n（1）声明一个指针p指向链表头结点，初始化j从1开始。\n\n（2）当j<i时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1；\n\n（3）若到链表末尾p为空，则说明第i个结点不存在。\n\n（4）否则查找成功，在系统中生成一个空结点s。\n\n（5）将数据元素e赋值给s->data。\n\n（6）单链表的插入标准语句s->next = p->next; p->next = s;\n\n（7）返回成功。\n\n```\nstatic GetElem(LinkList L, int i, ElemType *e)\n{\n    int j;\n    LinkList p = L->next;  // 假设 L 是头结点，p 指向第一个数据结点\n    j = 1;                 // 初始化计数器，从第 1 个结点开始\n    while (p && j < i)      // 遍历链表，直到找到第 i 个结点\n    {\n        p = p->next;\n        j++;\n    }\n    if (!p || j > i)       // 如果链表为空或者 j 超过了 i，返回错误\n    {\n        return ERROR;\n    }\n  \n    // 插入新结点\n    LinkList s = (LinkList)malloc(sizeof(Node));  // 为新结点分配内存\n    s->data = e;      \n    s->next = p->next;       // 将p的后继结点赋值给s的后继\n    p->next = s;             // 将s赋值给p的后继\n\n    return OK;\n}\n```\n\n### 删除算法思路\n\n（1）声明一个指针p指向链表头结点，初始化j从1开始。\n\n（2）当j<i时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1；\n\n（3）若到链表末尾p为空，则说明第i个结点不存在。\n\n（4）否则查找成功，将要删除的结点p->next赋值给q。\n\n（5）单链表的删除标准语句p->next =  q->next。\n\n（6）将q结点中的数据赋值给e，作为返回\n\n（7）释放q结点。\n\n（8）返回成功。\n\n```\nstatic GetElem(LinkList L, int i, ElemType *e)\n{\n    int j;\n    p = L->next;  // 初始化 p 指针，指向链表的第一个节点\n    j = 1;        // 从第 1 个节点开始计数\n    while (p && j < i)  // 遍历链表，找到第 i 个节点的前一个节点\n    {\n        p = p->next;\n        j++;\n    }\n    if (!p || j > i)  // 如果链表长度不足 i，或者 j 超过 i，返回错误\n    {\n        return ERROR;\n    }\n    q = p->next;  // 找到要删除的节点 q（即第 i 个节点）\n    p->next = q->next;  // 让 p 的后继指针跳过 q，指向 q 的后继节点\n    *e = q->data;  // 将要删除的节点 q 的数据保存到 e 中\n    free(q);  // 释放被删除节点 q 所占的内存\n    return OK;  // 返回成功\n}\n\n\n```\n\n# 单链表的整表创建\n\n（1）声明一个指针p和计算器变量i。\n\n（2）初始化一空链表L。\n\n（3）让L的头结点的指针指向NULL，建立一个带头结点的单链表。\n\n（4）循环。\n\n1、生成一个新节点赋值给p。\n\n2、随机生成一个数字赋值给p的数据域p->data。\n\n3、将p插入到头结点与前一新结点之间。\n\n```\nstatic GetElem(LinkList L, int i, ElemType *e)\n{\n    LinkList p;               // 定义一个指针 p 用于遍历链表\n    int i;                    // 定义计数器 i（注意：与外部函数参数 i 冲突）\n    srand(time(0));           // 初始化随机数种子，确保每次运行时生成不同的随机数\n  \n    *L = (LinkList)malloc(sizeof(LNode));  // 为头节点分配内存\n    (*L)->next = NULL;        // 将头节点的后继指针设为 NULL，表示链表初始化为空\n  \n    for (i = 0; i < n; i++)   // 循环生成 n 个节点\n    {\n        p = (LinkList)malloc(sizeof(LNode));  // 为新节点 p 分配内存\n        p->data = rand() % 100 + 1;           // 生成 1 到 100 之间的随机数，并赋给 p->data\n        p->next = (*L)->next;   // 将当前链表的第一个节点赋值为 p 的后继\n        (*L)->next = p;         // 将 p 插入到头节点之后\n    }\n}\n\n```\n\n## 循环链表\n\n循环链表和单链表的差异是p->netx是判断是否为空，循环链表的判断是p->next不等于头结点。\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/9/image_71a70083f1532923691f0a5bc12253a1.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/9/image_71a70083f1532923691f0a5bc12253a1.png)\n\n```\nP = rearA -> next;          //保存A表的头结点，1点\nrearA -> next = rearB -> next -> next;  //将本是指向B表的第一个结点（不是头结点）\n\nq = rearB -> next;   \nrearB -> next = p;          //赋值给rearA->next,2点\nfree(q);                    //释放q   \n```\n\n## 双向链表\n\n双向链表：是在单链表的每个节点中，在设置一个指向前驱结点的指针域。\n\n```\ntypedef struct DulNode\n{\n        ElemType data;\n        struct DuLNode *prior;     //直接前驱指针\n        struct DuLNone *next;      //直接后继指针\n}DulNode,*DuLinkList;\n```\n\n# 总结\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/9/image_a1421df87866f8fe3001afdcd3585367.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/9/image_a1421df87866f8fe3001afdcd3585367.png)\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/9/image_75d63b25107a5df72426d4e9bc78a72f.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/9/image_75d63b25107a5df72426d4e9bc78a72f.png)\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/9/image_f9bc45f80a5d7cda3a0012e9c2f44f9f.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/9/image_f9bc45f80a5d7cda3a0012e9c2f44f9f.png)\n","tags":["算法"],"categories":["数据结构"]},{"title":"许久没有发文章了","url":"/2024/09/04/关于在物联网竞赛中的一些感想/","content":"从四月份到八月份的比赛结束，取得了华东赛区一等奖和全国总决赛二等奖。说起来，也是跟在梦中似的~没有想过真的可以进去国赛，也算是吃到了赛道的福利了。在华东赛区和总决赛的作品演示室看到他们的作品，看的我都自卑了，很高级，我们的作品很简陋，太简陋了，搞得我都想跑了 ~\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/9/bc593d6f5bda4e44204e5044a99a5b7_37609e80403560c5c5f3bd8b9a7ee3d1.jpg](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/9/bc593d6f5bda4e44204e5044a99a5b7_37609e80403560c5c5f3bd8b9a7ee3d1.jpg)\n\n我负责的是写APP和数据大屏，但是连整合单片机的部分都是我来写的，一个字“累”！写鸿蒙APP，也是只学习了三天ArkTs就直接开始写了，ArkTs也是基于TS来的，与JS相对，TS确实简单很多，我主要是有基础啦。总结就是，UI很烦很烦！！！没有艺术细胞的我，画UI简直是酷刑！！！\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/9/image_8070321a721cd749fb34e912d4627942.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/9/image_8070321a721cd749fb34e912d4627942.png)\n\n整合单片机的也是一个折磨，两个队友的代码习惯不一样，不能直接调用函数，而且出现的bug最多的就是单片机……语音，WIFI，LoRa这部分都是我来的，有时候LoRa很奇怪，节点能发数据，但是网关收不到，在华东赛区的时候出现这个问题，吓得我手都在抖哈哈哈。\n\n数据大屏这部分没啥好说的，用的是低代码，会搞Http请求就没有任何问题了，挺简单的。\n\n在总决赛的之前，临时买了一个ESP32Cam，缺点就是卡(供电需要5V2A的，他的烧录板没有！！！)，清晰度倒还好，加入了一个火焰检测，本来是加入烟雾的，摄像头模糊，老是识别到模糊的地方是烟雾，可恶。ESP32Cam视频流转成一个服务器地址，Python再用OpenCV获取，再加入YOLOV8训练的模型就可以了，不过这些部分不是熟悉，实现效果有就行啦。不过在比赛的时候，没有演示出来。\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/9/6e93328e4b1f132fcd13d6c4069aab0_93404f4b35ef661ccdc28e12069e98c8.jpg](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/9/6e93328e4b1f132fcd13d6c4069aab0_93404f4b35ef661ccdc28e12069e98c8.jpg)\n"},{"title":"第十章 EXTI-外部中断/事件控制器","url":"/2024/05/09/第十章 EXTI-外部中断/事件控制器/","content":"# 一、EXTI介绍\n\n外部中断/事件控制器（EXTI）管理控制器的23个中断/时间线，都有一个对应的一个边沿检测器，实现输入信号的上升沿和下降沿检测，都可以实现对每个中断/事件进行单独配置，可以单独配置中断或事件和触发事件的属性。\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/5/image_3aeaa4380ab343e39c3a79a69a049055.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/5/image_3aeaa4380ab343e39c3a79a69a049055.png)\n\n**（EXTI是在APB2总线上的）**\n\n1、红色虚线和绿色虚线分别是 产生中断的线路，信号流入到NVIC控制器。\n\n2、绿色虚线是产生事件的线路，输出一个脉冲信号。\n\n3、输入线，EXTI有23个中断/事件输入先，可以为任意一个GPIO，也可以是外设的事件。\n\n4、边沿检测电路，根据上升沿触发寄存器（EXTI_RTSR）和下降沿触发选择寄存器（EXTI_FTSR）对应位控制信号触发。\n\n5、软件中事件寄存器（EXTI_SWIER），允许程序控制可以启动中断/时间线。\n\n6、中断屏蔽寄存器（EXTI_IMR），可以简单控制EXTI_IMR来实现产生中断的目的。\n\n7、挂起寄存器（EXTI_PR），内容输出到NVIC，实现系统中断事件中断控制。\n\n8、事件屏蔽寄存器（EXTI_EMR），控制它来实现是否产生事件的目的。\n\n# 二、编程要点\n\n1、初始化RGB\n\n2、开启按键GPIO和SYSCFG时钟\n\n3、配置NVIC\n\n4、配置按键GPIO为输入\n\n5、按键连接到EXTI源输入\n\n6、配置按键EXTI中断/事件线\n\n7、编写EXTI中断服务函数\n","tags":["STM32"],"categories":["野火 STM32"]},{"title":"第九章 STM32中断应用","url":"/2024/05/09/第九章 STM32中断应用/","content":"# 一、中断概述\n\n中断时出现某些意外需要主机干预，机器能自动停止运行的程序，转入新的处理的程序，处理完之后返回程序被暂停的程序，继续运行。\n\n**异常就是中断，中断就是异常。**\n\n异常分为：系统异常和外部中断。\n\n# 二、NVIC介绍\n\nNVIC是嵌套向量中断控制器，控制芯片中断的功能。\n\n一般来说，使用ISER（使能中断）、ICER（失能中断）和IP（设置中断优先级）寄存器。\n\n（不常用）\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/5/image_a55375ca0cca80086903ef6aa7ee9e07.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/5/image_a55375ca0cca80086903ef6aa7ee9e07.png)\n\n# 三、优先级\n\n中断优先级寄存器NVIC_IPRx，用来配置外部中断的优先级。如果抢占优先级相同，九比较子优先级，如果都相同，比较硬件中断编号，编号越小，优先级越高\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/5/image_de37c45ad3b6423601d0f44213e25f99.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/5/image_de37c45ad3b6423601d0f44213e25f99.png)\n\n# 四、优先级分组\n\n优先级分组由外设SCB的应用程序中断和复位控制寄存器AIRCR的PRIGROUP[10:8]决定，主优先级=抢占优先级\n\n```c\n/**\n* 配置中断优先级分组：抢占优先级和子优先级\n* 形参如下：\n* @arg NVIC_PriorityGroup_0: 0bit for 抢占优先级\n* 4 bits for 子优先级\n* @arg NVIC_PriorityGroup_1: 1 bit for 抢占优先级\n* 3 bits for 子优先级\n* @arg NVIC_PriorityGroup_2: 2 bit for 抢占优先级\n* 2 bits for 子优先级\n* @arg NVIC_PriorityGroup_3: 3 bit for 抢占优先级\n* 1 bits for 子优先级\n* @arg NVIC_PriorityGroup_4: 4 bit for 抢占优先级\n* 0 bits for 子优先级\n* @ 注意 如果优先级分组为 0，则抢占优先级就不存在，优先级就全部由子优先级控制\n*/\nvoid NVIC_PriorityGroupConfig(uint32_t PriorityGroup)\n{\n     // 检查参数\n     assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));\n     // 设置优先级分组\n     NVIC_SetPriorityGrouping(PriorityGroup);\n}\n```\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/5/image_0779d2ab9fa55ff33a7b9526a2fe24db.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/5/image_0779d2ab9fa55ff33a7b9526a2fe24db.png)\n\n# 五、中断编程\n\n配置中断一般使用三个：\n\n1、使用 HAL\\_NVIC\\_SetPriorityGrouping(uint32\\_t PriorityGroup) 函数配置中断优先级分组。一般默认是 NVIC\\_PRIORITYGROUP\\_4 分组 4。\n\n2、使用 HAL\\_NVIC\\_SetPriority (IRQn\\_Type IRQn, uint32\\_t PreemptPriority, uint32\\_t SubPriority) 函数配置具体外设中断通道的抢占优先级和子优先级。\n\n3、使用 HAL\\_NVIC\\_EnableIRQ 函数使能中断请求。\n","tags":["STM32"],"categories":["野火 STM32"]},{"title":"关于使用wsl使用idf提供编译速度遇到的问题","url":"/2024/04/20/关于使用wsl使用idf提供编译速度遇到的问题/","content":"![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/4/image_5cd7c19bd7b2e43bbe49644b5f332987.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/4/image_5cd7c19bd7b2e43bbe49644b5f332987.png)\n\n在wsl的ubuntu安装idf遇到没有串口的报错，是因为wsl不自带usb的驱动，需要手动安装\n\n教程使用他人的：https://blog.csdn.net/qq_40695642/article/details/127270039\n"},{"title":"eps32连接华为云iot，并且实现arkts控制点灯","url":"/2024/04/02/eps32连接华为云iot，并且实现arkts控制点灯/","content":"# ESP32连接华为云\n\n我使用的是arduinoied所写的代码，要注意，在mqtt请求华为云中，需要写心跳间隔，不然上云不了（client.setKeepAlive(60);  //心跳间隔，很重要！！！）。代码如下：\n\n```c\n#include <ArduinoJson.h>\n#include <WiFi.h>\n#include <PubSubClient.h>\n\n// 定义 LED 和按键引脚\nconst int led_pin = 48; // 根据你的实际硬件更改\nconst int button_pin = 0; // 通常用于ESP32的引脚\n\n// 定义 LED 状态变量，默认为假即低电平，通过它判断 LED 的状态是否改变过\nbool led_status = false;\n\n// WiFi 连接参数\nconst char* ssid = \"LMJZ\";     // 修改为你的WiFi名称\nconst char* password = \"12345678\"; // 修改为你的WiFi密码\n\n// MQTT 连接参数\nconst char* mqttServer = \"f31531a1fe.iot-mqtts.cn-north-4.myhuaweicloud.com\";\nconst int mqttPort = 1883;\nconst char* clientId =\"65f5bd99fb8177243a4f32c3_wenshidu_0_0_2024033011\";\nconst char* mqttUser =\"65f5bd99fb8177243a4f32c3_wenshidu\";\nconst char* mqttPassword = \"def7f41de80e802a96a29f04eec1561c6a63057d2d0a0ed0aba966041ee6a5f1\";\n\n// MQTT 客户端\nWiFiClient espClient;\nPubSubClient client(espClient);\n\n// MQTT 主题\n#define device_id \"65f5bd99fb8177243a4f32c3_wenshidu\"\n#define secret \"630aa442fa0fa9956ea95016189a5186\"\n#define Iot_link_Body_Format \"{\\\"services\\\":[{\\\"service_id\\\":\\\"BasicData\\\",\\\"properties\\\":{%s\"\n// 设备属性上报\n#define Iot_link_MQTT_Topic_Report \"$oc/devices/\" device_id \"/sys/properties/report\"\n// 接收平台下发的命令\n#define Iot_link_MQTT_Topic_Commands \"$oc/devices/\" device_id \"/sys/commands/#\" \n// 设备响应平台的命令\n#define Iot_link_MQTT_Topic_CommandsRes \"$oc/devices/\" device_id \"/sys/commands/response/request_id=\"\n\n// 其他变量和函数声明\nint data_temp = 20; // 模拟上报的温度值\nlong lastMsg = 0;\n\nvoid setup() {\n  // 设置 LED 和按键引脚模式\n  pinMode(led_pin, OUTPUT);\n  pinMode(button_pin, INPUT_PULLUP);\n\n  // WiFi 初始化\n  Serial.begin(115200);\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.println(\"Connecting to WiFi..\");\n  }\n  Serial.println(\"Connected to the WiFi network\");\n\n  // MQTT 初始化\n  MQTT_Init();\n}\n\nvoid loop() {\n  // 检测按键状态并控制 LED\n  if (digitalRead(button_pin) == LOW) {\n    delay(100); // 去抖动\n    if (digitalRead(button_pin) == LOW) {\n      while(digitalRead(button_pin) == LOW); // 等待按钮释放\n      led_status = !led_status;\n      digitalWrite(led_pin, led_status ? HIGH : LOW);\n    }\n  }\n\n  // MQTT 连接和数据上报\n  if (!client.connected()) {\n    MQTT_Init();\n  } else {\n    client.loop();\n  }\n  long now = millis();\n  if (now - lastMsg > 5000) {\n    lastMsg = now;\n    MQTT_POST();\n    data_temp++; // 递增温度值以模拟温度变化\n  }\n}\n\nvoid MQTT_Init() {\n  client.setKeepAlive(60);  //心跳间隔，很重要！！！\n  client.setServer(mqttServer, mqttPort);\n  client.setCallback(callback);\n  while (!client.connected()) {\n    Serial.println(\"Attempting to connect to MQTT server...\");\n    if (client.connect(clientId, mqttUser, mqttPassword)) {\n      Serial.println(\"Connected to MQTT server\");\n      // 订阅命令主题\n      client.subscribe(Iot_link_MQTT_Topic_Commands);\n\n    } else {\n      Serial.print(\"Failed to connect to MQTT server, state: \");\n      Serial.println(client.state());\n      delay(5000);\n    }\n  }\n}\n\nvoid MQTT_POST() {\n  char properties[50];\n  char jsonBuf[200];\n  sprintf(properties, \"\\\"temperature\\\":%d}}]}\", data_temp);\n  sprintf(jsonBuf, Iot_link_Body_Format, properties);\n  client.publish(Iot_link_MQTT_Topic_Report, jsonBuf);\n  Serial.println(\"MQTT Publish OK!\");\n}\n\nvoid callback(char* topic, byte* payload, unsigned int length) {\n  String recdata = \"\";\n  Serial.printf(\"接收到订阅的消息:主题为：%s\\n\", topic); \n  Serial.print(\"数据内容：\");\n  for (int i = 0; i < length; i++) {\n    recdata += (char)payload[i];\n  }\n  Serial.println(recdata);\n\n  // 解析JSON数据\n  DynamicJsonDocument jsonBuffer(1024);\n  deserializeJson(jsonBuffer, recdata);\n  JsonObject obj = jsonBuffer.as<JsonObject>();\n  JsonObject paras = obj[\"paras\"].as<JsonObject>();\n  String ledcom = paras[\"value\"];\n  Serial.printf(\"解析命令：%s\\n\", ledcom.c_str());\n\n  // 解析request id，设备响应时的topic需要包含命令的request id，且会动态变化\n  String request_id = topic;\n  request_id.remove(0, request_id.lastIndexOf('=') + 1);\n  Serial.printf(\"request_id：%s\\n\", request_id.c_str());\n\n  // 命令设备响应\n  String response = \"{}\";\n  client.publish((Iot_link_MQTT_Topic_CommandsRes + request_id).c_str(), response.c_str());\n\n  if (ledcom == \"ON\") {\n    digitalWrite(led_pin, LOW); // 关闭LED\n    Serial.println(\"关灯\");\n  } else if (ledcom == \"OFF\") {\n    digitalWrite(led_pin, HIGH); // 打开LED\n    Serial.println(\"开灯\");\n  }\n}\n\n```\n\n在鸿蒙开发中，要进行http请求，arkts代码\n\n下面是ui代码：\n\n```typescript\n                Button('点击').onClick(async () => {\n                  if (this.led) {\n                    try {\n                      await greenHousesHttpRequest.sendDeviceCommand('BasicData', 'Switch', 'OFF');\n                      console.log('LED已关闭');\n                      this.led = false; // 更新LED状态为关闭\n                      this.leddevice = '离线'; // 更新设备状态显示为不在线\n                    } catch (error) {\n                      console.error('关闭LED失败', error);\n                    }\n                  } else {\n                    try {\n                      await greenHousesHttpRequest.sendDeviceCommand('BasicData', 'Switch', 'ON');\n                      console.log('LED已点亮');\n                      this.led = true;\n                      this.leddevice = '在线';\n                    } catch (error) {\n                      console.error('点亮LED失败', error);\n                    }\n                  }\n                }).margin({top:10});\n```\n\nhttp请求代码：\n\n```typescript\n// 设备下发命令\n  async sendDeviceCommand(serviceId, commandName, commandValue) {\n    if (!this.token) {\n      await this.getAuthToken();\n    }\n\n    return new Promise((resolve, reject) => {\n      let httpRequest = http.createHttp();\n      const url = \"https://f31531a1fe.iotda.cn-north-4.myhuaweicloud.com:443/v5/iot/34dd0bcb3a0b46fab400809bca1b6e3e/devices/65f5bd99fb8177243a4f32c3_wenshidu/commands\"\n      httpRequest.request(url,{\n        method: http.RequestMethod.POST,\n        header: {\n          'Content-Type': 'application/json',\n          'X-Auth-Token': this.token // 确保已经获取了token\n        },\n        extraData: {\n          \"service_id\": serviceId,\n          \"command_name\": commandName,\n          \"paras\": {\n            \"value\": commandValue\n          }\n        }\n      }).then(resp => {\n        if (resp.responseCode == 200) {\n          resolve(JSON.parse(resp.result.toString()));\n        } else {\n          reject('Failed to send command, response code: ' + resp.responseCode);\n        }\n      }).catch(error => {\n        console.error('Error sending command:', JSON.stringify(error));\n        reject(error);\n      });\n    });\n  }\n\n```\n","tags":["华为云IOT"],"categories":["华为云IOT连接"]},{"title":" 一篇牢骚","url":"/2024/03/30/一篇牢骚/","content":"# 愿我此生脚步不停，览尽世间美景。即使路途遥远且艰难，至少，至少，我经历过。以巽为名，行遍千山万水，看尽人间青山。青山不言，我自知晓其壮美。\n\n# 来自抖音博主**hx888888000**\n\n## **长穿毕**\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/3/1d0eb9af83664b212338faae7d440df_779743451a157de28e8c8829ae4fe605.jpg](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/3/1d0eb9af83664b212338faae7d440df_779743451a157de28e8c8829ae4fe605.jpg)\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/3/d111f90f43e69bd4d1ea5806caa44f7_1d6a4e76841ff9d93f24f865ab4fa3d9.jpg](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/3/d111f90f43e69bd4d1ea5806caa44f7_1d6a4e76841ff9d93f24f865ab4fa3d9.jpg)\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/3/5f8bdcb82439a8f5b73a67fff41cb4e_5434663cb0eee6c014428b2bedbf70e7.jpg](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/3/5f8bdcb82439a8f5b73a67fff41cb4e_5434663cb0eee6c014428b2bedbf70e7.jpg)\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/3/8a8e81c8ca5fbeb9ac2ffe066e46a07_6a781df38e8873e0ad1488fc3151b71e.jpg](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/3/8a8e81c8ca5fbeb9ac2ffe066e46a07_6a781df38e8873e0ad1488fc3151b71e.jpg)\n\n# 来自抖音博主zkai6999\n\n## 那拉提\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/3/6b06a76b99a4f86869845bd01d057d8_e1d5262643ad7aa79e7a2cd1b8f69525.jpg](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/3/6b06a76b99a4f86869845bd01d057d8_e1d5262643ad7aa79e7a2cd1b8f69525.jpg)\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/3/d2492dba415b90088096ad8e3c5e4a1_4967f91082ce5adfcd8c159b28b723b3.jpg](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/3/d2492dba415b90088096ad8e3c5e4a1_4967f91082ce5adfcd8c159b28b723b3.jpg)\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/3/c84cd6552b0bc71f923f11c06e15733_32f923434cc1bb7d7d5cac4b5fed3d51.jpg](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/3/c84cd6552b0bc71f923f11c06e15733_32f923434cc1bb7d7d5cac4b5fed3d51.jpg)\n\n# 来自抖音博主zkai6999\n\n## 阿勒泰\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/3/3b921a2a751f23b2e4618a53af9ff15_8380ac733a7acc2caa084b12cec2eaa6.jpg](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/3/3b921a2a751f23b2e4618a53af9ff15_8380ac733a7acc2caa084b12cec2eaa6.jpg)\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/3/86a718a9601a2ccea307145ef4e2d65_588dafa448a4d062c41649fc2e4f47c4.jpg](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/3/86a718a9601a2ccea307145ef4e2d65_588dafa448a4d062c41649fc2e4f47c4.jpg)\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/3/acbdb3a8d851258b290e1754c5c8890_f20bd19c22c344db52714613ba982157.jpg](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/3/acbdb3a8d851258b290e1754c5c8890_f20bd19c22c344db52714613ba982157.jpg)\n"},{"title":"第八章 RCC使用HES/HSI","url":"/2024/03/21/第八章 RCC使用HES/HSI/","content":"# 1、RCC主要作用 时钟部分\n\n设置系统时钟SYSCLK、设置AHB分频因子（决定HCLK等于多少）、设置APB2分频因子（决定PLCLK2等于多少）、设置APB1分频因子（决定PLK1等于多少）、设置各个外设的分配因子。控制 AHB、APB2 和 APB1 这三条总线时钟的开启、控制每个外设的时钟的开启。对于 SYSCLK、HCLK、PCLK2、PCLK1 这四个时钟的配置一般是：HCLK = SYSCLK=PLLCLK ，PCLK1=HCLK/2，PCLK1=HCLK/4 。\n\n# 2、RCC时钟树\n\n库函数时钟系统始终函数：SetSysClock()。\n\nHSE时钟树设置为：\n\nHCLK=SYSCLK=PLLCLK=180M（F429）\n\nPCLK1=HCLK/2=90M(F429)\n\nPLCK1=HCLK/4=45M(F429)\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/3/image_f4eb27007cd32cb5a5c1b1e612c5066f.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/3/image_f4eb27007cd32cb5a5c1b1e612c5066f.png)\n\n## 2.1系统时钟\n\n### 2.1.1\n\nHSE是高速的外部时钟信号，有无源/有源晶振提供，频率4-26MHZ。\n\n有源晶振，时钟从OSC_IN引脚进入，OSC_OUT引脚悬空。\n\n无源晶振，时钟从OSC_IN,OSC_OUT进入，配合谐振电容。\n\n### 2.1.2 锁相环PLL\n\nPLL的主要作用是对时钟进行倍频，然后将时钟输出到各个功能部分。\n\nPLL和PLLI2S，他们由HSE或者HSI提供时钟输入信号。\n\n主PLL有两路时钟输出，第一个输出时钟是PLLCLK用于系统时钟，F429最高时180M，第一个时用于USB OTG FS的时钟（48M）、RNG和SDIO时钟（<=48M）专门用于PLLI2S生成精准时钟，给I2S提供时钟。\n\nHSE或者HSI经过PLL时钟输出分频因子M（2~63）分频后，称为VCO的时钟输入，VCO的时钟必须在1 ~2M，选择HSE=25M作为PLL的时钟输入，M设置25，VCO输入时钟必须等于1M。\n\n### 2.1.3 系统时钟SYSCLK\n\n系统时钟来源可以时HSI、PLLCLK、HSE，具体由时钟配置寄存器RCC_CFGR的SW位配置。SYSCLK=PLLCLK=180M。\n\n如果系统时钟是由HSE经过PLL倍频之后的PLLCLK得到，当HSE出现故障的时候，系统时钟会切换HSI=16M，知道HSE恢复正常。\n\n### 2.1.4 AHB总线时钟HCLK\n\n系统时钟经过AHB预分频器分频之后得到的时钟是叫AHB总线时钟，就是HCLK，分频因子可以是[1,2,4,16,64,128,256,512]，具体由时钟配置寄存器RCC_CFGR的HPRE\n\n位设置。片上大部分外设时钟都是HCLK分频德奥，AHB总线的外设设置时使用外设的时候设置。\n\n### 2.1.5 APB2总线时钟PCLK2\n\nAHB2总线是由PCLK2由HCLK经过高速APB2预分频器得到，分频因子可以是[1,2,4,16]，由时钟配置寄存器RCC_CFGR的PRPE2位设置。PCLK2属于高速的总线时钟，片上高速的外设就挂载到这条总线，比如全部的GPIO、USART1、SPI1等。\n\n### 2.1.6 APB1 总线时钟PCLK1\n\nAPB1总线时钟PCLK1由HCLK经过低速APB预分频器得到，分频因子可以是[1,2,4,16]，由RCC_CFGR的PPRE2位设置。PCLK2属于低速的总线时钟，最高为45M（F429），片上低速的外设挂载到这条总线上，比如USART2/4/5，SPI2/3，I2C1/2。\n","tags":["STM32"],"categories":["野火STM32"]},{"title":"一、harmonyOS开发","url":"/2024/03/09/一、HarmonyOS4开发/","content":"# 一、TS基础语法\n\n## 二、声明变量\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/3/image_4497af838a16322eb31c1c79fe851949.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/3/image_4497af838a16322eb31c1c79fe851949.png)\n\n## 二、条件控制\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/3/image_609945756c4e82937d021ea54447486a.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/3/image_609945756c4e82937d021ea54447486a.png)\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/3/image_46fffd1b2a4a75affe9ed2ccc9e59659.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/3/image_46fffd1b2a4a75affe9ed2ccc9e59659.png)\n\n## 三、循环迭代\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/3/image_9a5d00ad4674553a79dabd0fe52bbfc1.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/3/image_9a5d00ad4674553a79dabd0fe52bbfc1.png)\n\n## 四、函数\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/3/image_5f9ef0934899a071ab9b7e909848d1b7.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/3/image_5f9ef0934899a071ab9b7e909848d1b7.png)\n\n## 五、类和接口\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/3/image_d1fb365339ecda693696e196ceeaffdc.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/3/image_d1fb365339ecda693696e196ceeaffdc.png)\n\n## 六、模块\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/3/image_3eed512d644baa5ffb71ba3c55d4fc44.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/3/image_3eed512d644baa5ffb71ba3c55d4fc44.png)\n\n## 七、UI布局分析\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/3/image_35f78e7774daaad2fe2b693f119a05be.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/3/image_35f78e7774daaad2fe2b693f119a05be.png)\n\n# 八、image组件\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/3/image_89c4675342542ff569532ec4078fed68.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/3/image_89c4675342542ff569532ec4078fed68.png)\n\n\n\n\n\n\n\n\n# 一些代码示例\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/3/image_5a89b9978754b4e47e8174d9932ba65b.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/3/image_5a89b9978754b4e47e8174d9932ba65b.png)\n","tags":["APP开发"],"categories":["鸿蒙开发"]},{"title":"利用MQTT连接华为IOT平台，进行数据上报与下发","url":"/2024/03/09/利用MQTT连接华为IOT平台，进行数据上报与下发/","content":"# 一、查看接入信息\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/3/image_6721540a5fccd555db65a98741e70716.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/3/image_6721540a5fccd555db65a98741e70716.png)\n\n# 二、创建产品\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/3/image_ba9eab465891adb5fd677dcccd8394f2.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/3/image_ba9eab465891adb5fd677dcccd8394f2.png)\n\n# 三、注册设备\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/3/image_c6b568b4ff35a2d66719c5489aeb8418.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/3/image_c6b568b4ff35a2d66719c5489aeb8418.png)\n","tags":["HarmonyOS"],"categories":["华为IOT平台连接"]},{"title":"第七章 启动文件详解","url":"/2024/03/03/第七章 启动文件详解/","content":"# 7.1启动文件介绍\n\n1、初始化堆栈指针 SP=_initial_sp\n\n2、初始化PC指针  =Rest_Handler\n\n3、初始化中断向量表\n\n4、配置系统时钟\n\n5、调用C库函数_main初始化用户堆栈，调用main函数\n\n# 7.2 ARM汇编指令\n\nEQU：给数字常量去一个富豪们，相当于C语言的define\n\nAREA：汇编一个新的代码段或者数据段\n\nSPACE：分配内存空间\n\nPRE-SERVE8：当前文件堆栈按照8位字节对齐\n\nEX-PORT：声明一个符号具有全局属性，可被外部的文件使用\n\nDCD：字节单位分配，要求4字节对齐，要去初始化这些内存\n\nPROC：定义子程序，与ENDP成对使用，表示子程序结束\n\nWEAK：弱定义，如果外部文件声明了一个标号，则优先使用外部文件定义的标号，如果外部文件没有定义也不出错。要注意的是：这个不是 ARM 的指令，是编译器的，这里放在一起只是为了方便。\n\nIM-PORT：跳转到一个符号\n\nALIGN：编译器对指令或者数据的存放地址进行对齐，一般需要跟一个立即数，缺省表示 4 字节对齐要注意的是：这个不是 ARM 的指令，是编译器的，这里放在一起只是为了方便。\n\nEND：到达文件的末尾，文件结束\n\nIF,ELSE,ENDIF：汇编条件分子语句，跟c语言的if else如此\n\n# 7.3 启动文件代码讲解\n\n## 7.3.1 Stack栈\n\n```c\nStack_Size     EQU 0x00000400 //开辟栈的大小为0X00000400（1KB）\n               AREA STACK, NOINIT, READWRITE, ALIGN=3\n              //名字为STACK      可读写       8（2^3）\nStack_Mem      SPACE Stack_Size   //分配内存空间，单位 字节，这里指定大小为Strack_Size\n__initial_sp  //栈的结束地址，由高向低生长\n```\n\n栈的作用是用于局部变量，函数调用，函数形参等开销，栈的大小不能超过内部SRAM的大小，超过要修改栈的大小。\n\n## 7.3.2 Heap堆\n\n```c\nHeap\\_Size EQU 0x00000200    //开辟堆大小0X00000200（512字节）\n   AREA HEAP, NOINIT, READWRITE, ALIGN=3\n   //名字     不初始化，可读写，8（2^3）\n\\_\\_heap\\_base  //堆的起始地址\n          Heap_Mem SPACE Heap_Size\n__heap_limit    //堆的结束地址       堆由低到高生长和栈相反\n```\n\n堆用来动态内存的分配，像malloc()函数申请的内存就在堆上面\n\n## 7.3.3 向量表\n\n```c\nAREA RESET, DATA, READONLY\n//定义数据段为RESET 可读，生命三个标号具有全局属性，可供外部文件调用\nEXPORT __Vectors\nEXPORT __Vectors_End\nEXPORT __Vectors_Size\n```\n\n\\_\\_Vectors 为向量表起始地址，\\_\\_Vectors\\_End 为向量表结束地址，两个相减即可算出向量表大小\n\n## 7.3.4 复位程序\n\n```c\nAREA |.text|, CODE, READONLY\n//定义一个名称为.text 的代码段，可读。\n.text\nReset_Handler PROC\nEXPORT Reset_Handler [WEAK]\nIMPORT SystemInit\nIMPORT __main\nLDR R0, =SystemInit\nBLX R0\nLDR R0, =__main\nBX R0\nENDP\n```\n\n复位子程序是系统上电后第一个执行的程序，调用 SystemInit 函数初始化系统时钟，然后调用 C库函数 \\_mian，最终调用 main 函数去到 C 的世界。\n\nSystemInit() 是一个标准的库函数，在 system\\_stm32f103xe.c 这个库文件中定义。主要作用是配置系统时钟，这里调用这个函数之后，单片机的系统时钟配被配置为 72M。\n\n\\_\\_main 是一个标准的 C 库函数，主要作用是初始化用户堆栈。\n\n## 7.3.5 中断服务程序\n\n```c\nNMI_Handler PROC ; 系统异常\n      EXPORT NMI_Handler [WEAK]\n      B .\n      ENDP\n; 限于篇幅，中间代码省略\nSysTick_Handler PROC\n      EXPORT SysTick_Handler [WEAK]\n      B .\n      ENDP\nDefault_Handler PROC ; 外部中断\n      EXPORT WWDG_IRQHandler [WEAK]\n      EXPORT PVD_IRQHandler [WEAK]\n      EXPORT TAMP_STAMP_IRQHandler [WEAK]\n; 限于篇幅，中间代码省略\nLTDC_IRQHandler\nLTDC_ER_IRQHandler\nDMA2D_IRQHandler\n      B .\n      ENDP\n```\n\nB：跳转到一个标号。这里跳转到一个‘.’，即表示无线循环。\n\n## 7.3.6 用户堆栈初始化\n\nALIGN：对指令或者数据存放的地址进行对齐，后面会跟一个立即数。缺省表示 4 字节对齐。\n\n```c\n; 用户栈和堆初始化, 由 C 库函数_main 来完成\nIF : DEF :__MICROLIB ; 这个宏在 KEIL 里面开启\nEXPORT __initial_sp\nEXPORT __heap_base\nEXPORT __heap_limit\nELSE\n  IMPORT __use_two_region_memory ; 这个函数由用户自己实现\n  EXPORT __user_initial_stackheap\n  __user_initial_stackheap\n  LDR R0, = Heap_Mem\n  LDR R1, =(Stack_Mem + Stack_Size)\n  LDR R2, = (Heap_Mem + Heap_Size)\n  LDR R3, = Stack_Mem\n  BX LR\n  ALIGN\n  ENDIF\n  END\n```\n\n\n首先判断是否定义了 \\_\\_MICROLIB，如果定义了这个宏则赋予标号 \\_\\_initial\\_sp（栈顶地址）、\\_\\_heap\\_base（堆起始地址）、\\_\\_heap\\_limit（堆结束地址）全局属性，可供外部文件调用。\n","tags":["STM32"],"categories":["野火 STM32"]},{"title":"第二章 算法","url":"/2024/02/29/第二章 算法/","content":"# 2.1 算法定义\n\n算法是解决特定问题求解步骤的描述，计算机中表现位指令的有限序列，并且每条指令表示一个或多个操作。\n\n# 2.2 算法的特性\n\n算法具有：输入、输出、有穷性、确定性和可行性。\n\n## 2.2.1 输入输出\n\n算法具有**零个或多个输入和至少一个或多个输出**。\n\n## 2.2.2 有穷性\n\n指的是算法在执行有限步骤之后，自动结束而**不会出现无限循环**，并且每一个步骤**可接受在时间内完成**。\n\n## 2.2.3 确定性\n\n算法的每一步骤具**有确定的含义，不会出现二义性**。\n\n## 2.2.4 可行性\n\n算法的每一步都必须可行的，**每一步都能狗通过执行有限次数完成**。\n\n# 2.3 算法设计的要求\n\n## 2.3.1 正确性\n\n指的是至少具有输入、输出和加工处理无歧义性，能正确反映问题的需求，能够得到问题的正确答案。\n\n## 2.3.2 可读性\n\n算法设计的另外一个目的，为了便于阅读、理解和交流。\n\n## 2.3.3 健壮性\n\n输入数据不合法，算法也能够做出相关处理，而不是产生异常或者莫名其妙的结果。\n\n## 2.3.4 时间效率高和存储量低\n\n时间效率高：算法的执行时间。存储量低：执行过中需要的最大存储控件，运行时所占用的内存或外部硬盘存储控件。\n\n应该满足时间效率和存储量低的需求。\n\n# 2.4 算法效率的度量方法\n\n## 2.4.1 事后统计方法\n\n通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行对比，确定算法效率的高低。\n\n## 2.4.2 事前分析估算方法\n\n在计算机程序编制前，依据统计方法对算法进行估算。\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/2/image_d45f1dfacd356e34e8403f42042e6882.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/2/image_d45f1dfacd356e34e8403f42042e6882.png)\n\n一个程序的运行时间，依据赖与算法的好坏和问题的输入规模。问题输出规模是指输入量的多少。\n\n# 2.5 函数的渐近增长\n\n给定义两个函数f（n）和g（n），如果存在一个整数N，使得对于所有的n>N，f（n）总是大于g（n），所以f（n）的增长渐近快于g（n）。\n\n**判断一个算法效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项（最高阶项） 的阶数。**\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/3/image_78cd7befd497306f3844f4fb583282fd.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/3/image_78cd7befd497306f3844f4fb583282fd.png)\n\n可以分析出：某个算法，随着n的增大，它会优越于另外一个算法，或者差于另外一个算法。\n\n# 2.6 算法时间的复杂度\n\n## 2.6.1 算法时间复杂度定义\n\n**在进行算法分析时，语句总的执行次数T（n）是关于问题规模n的函数，进而分析T（n）随n的变化情况并而确定T（n）的数量级。算法的时间复杂度（时间量度），记作T（n）=O（f（n））。表示随着问题规模n的增大，算法执行时间的增长率和f（n）的增长率相同，称为算法的渐近时间赋值度，简称时间复杂度。其中f（n）是问题规模n的某个函数。**\n\n## 2.6.2 推导大O阶方法\n\n推导大O阶：\n\n（1）常数1取代运行时间中的所有加法常数。\n\n（2）在修改后运行次数函数中，只保留最高阶项。\n\n（3）如果最高阶项存在且系数不是1，则去除与这个项相乘的系数，得到结果最大O阶。\n\n## 2.6.3 常数阶\n\n```c\nint sum = 0,n = 100;  //一次\nsum = (1 + n) * n /2; //一次\nprintf(\"%d\", sum);    //一次\n```\n","tags":["算法"],"categories":["数据结构"]},{"title":"第一章 数据结构绪论","url":"/2024/02/28/第一章 数据结构绪论/","content":"# 1.基本术语\n\n### 1.1 数据\n\n数据：**描述客观事物的符号，计算机中可以操作的对象，能被计算机识别并输入计算机处理的符号集合。**\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/2/image_6a4306bd1b7da2784e2b1a0700b5ccf8.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/2/image_6a4306bd1b7da2784e2b1a0700b5ccf8.png)\n\n### 1.2数据元素\n\n数据元素：**组成数据、有一定意义的单位，计算机中通常作为整体处理，也被称为记录。**\n\n### 1.3数据项\n\n数据项：一个数据元素可以由若干个数据项组成。\n\n数据项是**数据不可分割的最小单位**。\n\n### 1.4 数据对象\n\n数据对象：**性质相同的数据元素的集合，数据的子集。**\n\n性质相同的意思是指数据**元素具有相同数量的类型的数据项**。如，人都有姓名、生日等数据项。\n\n### 1.5 数据结构\n\n简单来说就是关系，比如分子结构，组成分子的原子之间的排列方式。\n\n严格来说，结构是指各个组成部分相互搭配和排序的方式。\n\n在现实中，不同数据元素之间不是独立的，而是存在特定的关系，称为结构。\n\n**数据结构：相互之间存在一种或多种特定关系的数据元素的集合。**\n\n## 1.2 逻辑机构与物理结构\n\n逻辑结构是指**数据对象中数据元素之间的相互关系**。\n\n#### 1.2.1 集合结构\n\n##### （1）集合结构\n\n集合结构中数据元素除了同属于一个集合外，它们之间没有其他关系。\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/2/image_c95dbd6adf3c3d0b14d35067f1f19269.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/2/image_c95dbd6adf3c3d0b14d35067f1f19269.png)\n\n##### （2）线性结构\n\n数据元素之间是一对的关系。\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/2/image_b31368fcfd0d6a0a13d89186230e7d82.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/2/image_b31368fcfd0d6a0a13d89186230e7d82.png)\n\n##### （3）树形结构\n\n数据元素之间存储一种一对多的层次关系。\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/2/image_a84ebebbb9cad5b1fb79995e211ca19b.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/2/image_a84ebebbb9cad5b1fb79995e211ca19b.png)\n\n##### （4）图形结构\n\n图形结构：数据元素是多对多的关系。\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/2/image_6a8288c246644054172bc1e5fc718c6b.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/2/image_6a8288c246644054172bc1e5fc718c6b.png)\n\n#### 1.2.2 物理结构（存储结构）\n\n物理结构：**是指数据的逻辑结构在计算机中的存储形式**。就是如何把数据元素存储到计算机的存储器中。存储器主要针对内存而言，数据组织通常用文件结构来描述。\n\n##### （1）顺序存储结构\n\n是把数据元素存放在地址连续的存储单元里，数据间的逻辑关系和物理关系是一样的。\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/2/image_5df1901b7d4bcff361718f672714226f.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/2/image_5df1901b7d4bcff361718f672714226f.png)\n\n##### （2）链式存储结构\n\n是把数据元素存放在任意的存储单元里，这组存储单元是可以连续的，也可以不是连续的。\n\n数据元素的存储关系不能反映逻辑关系，需要一个指针存放数据元素的地址，这一可以通过地址找到数据元素的位置。\n\n**逻辑结构是面向问题，物理结构是面向计算机的，基本是讲目标的数据以及逻辑关系存储到计算机的内存中。**\n\n## 1.3 数据类型\n\n是一组性质相同的值的集合以及定义在此集合上的一些操作的总称。\n\n### 1.3.1 数据类型定义\n\n在C语言中，按照取值的不同，数据类型可以分为：\n\n**原子类型：不可以再分解的基本类型，包括整形、实型、字符型等**\n\n**结构类型：若干个类型组合而成，是可以再分解的。例如，整型数组是由若干整型数据组成。**\n\n比如，定义int a，b，在给变量a，b赋值的时候不能超过int类型的取值范围。\n\n### 1.3.2 抽象数据类型\n\n抽象是**指抽取出事物具有普遍性的本质，对一个具体事务的一个概括。**\n\n抽象数据类型：**一个数学模型以及定义在该模型上的一组操作。**\n\n抽象数据类型的定义取决于**它的逻辑特性**，而在计算机内部如何表示和实现无关。\n\n抽象数据类型的标准格式：\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/2/image_c03a7894ac53233d5306841b4ca03ec9.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/2/image_c03a7894ac53233d5306841b4ca03ec9.png)\n\n### 1.4 总结\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/2/image_5caa3b65da33bdbfcb2a9dfd7ff6fe87.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/2/image_5caa3b65da33bdbfcb2a9dfd7ff6fe87.png)\n\n数据结构：**是相互之间存在一种或多种特定关系的数据元素的集合。**\n\n结构分类：\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/2/image_e2357b668f447cc27f6a96b755a5cfd1.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/2/image_e2357b668f447cc27f6a96b755a5cfd1.png)\n","tags":["算法"],"categories":["数据结构"]},{"title":"第一章 计算机系统基础知识","url":"/2024/02/26/第一章 计算机系统基础知识/","content":"# 第一章 计算机系统基础知识\n\n## 1.1 嵌入式计算机系统概述\n\n根据 IEEE 的定义，嵌入式系统是“**控制、监视或者辅助设备、机器和车间运行的配置**“。\n\n国内的系统定义是：以应用为中心、以计算机技术为基础，软件硬件可裁剪，适应应用系统对功能、可靠性、成本、体积、功耗严格要求的专用计算机系统。\n\n可以认为，是一种专用的计算机系统，作为装置或设备的一部分。通常嵌入式系统是一个控制程序存储在 ROM 中的嵌入式处理器控制板。\n\n### 1.计算机硬件\n\n计算机硬件系统由**运算器、控制器、存储器、输入设备和输出设备**。通信部件也成为计算机系统基本组件。\n\n**中央处理单元：**\n\n运算器和控制器和相关部件集成一起，称为中央处理单元（Central Processing Unit，CPU）。用于数据加工、完成算术、逻辑运算以及控制功能。\n\n**运算器：**\n\n对数据进行加工处理的部件，主要完成算术和逻辑运算。主要功能是从主存中取出指令并进行分析，以控制计算机各个部位完成指令。\n\n**存储器：**\n\n计算机系统的记忆设备，分为**内部存储器，简称内存、主存**和外部存储器，简称外存或者辅存。\n\n内存速度快、容量小，用于临时存储计算机运行所需要的程序、数据以及运算结果。\n\n外村容量大、速度慢，用于长期存钱信息。\n\n**寄存器**：\n\nCPU 存储器件，存放临时少量的数据、运算结果和整在执行的指令，速度快。\n\n主机：\n\nCPU 和主存器的有机组合。\n\n**输入/输出（I/O）：**\n\n设备位于主机之外，是计算机系统和外界交换信息的装置。\n\n输入：信息输入计算机中。\n\n输出：运算结果所要求的形式输出到外部设备或存储介质上。\n\n### 2.计算机软件\n\n计算机软件指的是管理、运行、维护以及应用计算机所开发的程序和相关文档的集合。\n\n分为系统软件、中间件和应用软件等类型。\n\n**系统软件：**\n\n管理系统的硬件和软件资源。\n\n**应用软件：**\n\n解决应用领域的具体问题。\n\n**中间件：**\n\n一类独立的系统软件或者服务程序，用来管理计算机资源和网络通信，提供通信处理、数据存取、事务处理、Web 服务、安全，跨平台等服务。\n\n### 3.计算机分类\n\n（1）个人移动设备：带有多媒体用户界面的无线设备，如手机、平板。\n\n（2）桌面计算机：台式计算机，笔记本等。\n\n（3）服务器：服务器代替传统的大型机，主要提供大规模和可靠文件以及计算服务，强调可用性、可扩展性，和很高的吞吐率。\n\n（4）集群/仓库级计算机：一组桌面计算机或者服务器用网络连接起来，类似如大型计算机\n\n（5）超级计算机：规格高，性能强大。\n\n（6）嵌入式计算机：针对某个特定的应用，如网络、通信、音频、视频等，对功能、可靠、成本、体积、功耗有严格要求。\n\n## 1.2 数据表示\n\n二进制是计算机采用的一种数制。数值、文字、声音、图形图像等必须经过数值化编码才能被传送、存储和处理。\n\n### 1.2.1 进位计数制及转换\n\n如果只用**r个基本符号**表示**数值**，则称其**r进制**（Radix-r Number System），r称为**改数制的基数**（Radix）。\n\n不同数制的共同特点：\n\n（1）有固定的符号集，例如。二进制的基本符号0和1。十进制的基本符号为0-9。\n\n（2）数制都是用位置表示法。不同位置的数符代表的值不同，与所在位置的权值有关。如**十进制数**1234.55表示为：\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/2/image_b50ff6cfb95a61dfe215996203ee8979.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/2/image_b50ff6cfb95a61dfe215996203ee8979.png)\n\n常用进位数制有二进制、八进制、十进制、十六进制，如图\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/2/image_73d4a641b1baacb83fe2ffe08fcbecf5.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/2/image_73d4a641b1baacb83fe2ffe08fcbecf5.png)\n\n不同数制的相互转换：\n\n（1）十进制与二进制转换\n\n在二进制中，r=2，基本符号为0和1。二进制中的一个0或者1称为1位（bit）。\n\n十进制数转换二进制数，整数部分和小数部分**分别转换**，然后**再合并**。\n\n十进制整数转换二进制整数是“**除2取余**”。\n\n十进制小数转换二进制小数是“**乘2取整**”。\n\n例如1：十进制175.71875转换二进制数。\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/2/image_c60529d879368a380c37d8040386230b.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/2/image_c60529d879368a380c37d8040386230b.png)\n\n十进制数写成二进制数权的大小展开的多显示，从高到低按照各项的系数。\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/2/image_72972f0515b07707cb1d3bfd8efe40d9.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/2/image_72972f0515b07707cb1d3bfd8efe40d9.png)\n\n二进制数转成十进制数的方法是：将二进制数的每一位乘以它的权再相加，可以求得对应的十进制数值。\n\n例如2：将二进制100110.101转换成十进制\n\n![https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/2/image_70bdc308e8b6121aeb50f09955f48622.png](https://cdn.jsdelivr.net/gh/weixuna/MyPic/24/2/image_70bdc308e8b6121aeb50f09955f48622.png)\n\n（2）八进制计数法与十进制、二进制计数法的相互转换\n\n八进制计数制的基本符号是0-7。\n\n十进制转换八进制数的方法：十进制整数采用“**除8取余**”的方法转换八进制整数。\n\n十进制小数采用“**乘8取整**”的方法转成八进制小数\n","tags":["软考"],"categories":["嵌入式设计"]},{"title":"疑难杂症","url":"/2024/02/18/疑难杂症/","categories":["报错"]},{"title":"项目测试","url":"/2024/02/18/项目测试/","categories":["项目"]},{"title":"大学生活","url":"/2024/02/17/大学生活/","categories":["阅读"]},{"title":"电子工程师入门篇-入门基础","url":"/2024/02/08/电子工程师入门篇-入门基础/","content":"\n## 1.1.1 电路与电路图\n\n电源的作用是提供电能；开关、导线的作用是控制和传递电能，称为中间环节；灯泡是消耗电能的用电器，它能将电能转变为光能，称为负载。\n\n![1707403891986](../assets/%E7%94%B5%E5%AD%90%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%85%A5%E9%97%A8%E7%AF%87-%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/1707403891986.png)\n\n## 1.1.2 电流与电阻\n\n### 1．电流\n\n​ 我们把电子运动的反方向作为电流方向，即把正电荷在电路中的移动方向规定为电流的方向。\n\n​ 电流通常用字母“I”表示，单位为安培（简称安），用“A”表示，比安培小的单位有毫安（mA）、微安（μA），它们之间的换算关系为\n\n![1707404033488](../assets/%E7%94%B5%E5%AD%90%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%85%A5%E9%97%A8%E7%AF%87-%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/1707404033488.png)\n\n### 2．电阻\n\n​ 导体对电流的阻碍称为该导体的电阻。\n\n​ 电阻通常用字母“R”表示，电阻的单位为欧姆（简称欧），用“Ω”表示，比欧姆大的单位 有千欧（kΩ）、兆欧（MΩ），它们之间的换算关系为\n\n![1707404090124](../assets/%E7%94%B5%E5%AD%90%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%85%A5%E9%97%A8%E7%AF%87-%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/1707404090124.png)\n\n​ 导体的电阻计算公式为\n\n![1707404106625](../assets/%E7%94%B5%E5%AD%90%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%85%A5%E9%97%A8%E7%AF%87-%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/1707404106625.png)\n\n​ L 为导体的长度（单位：m），S 为导体的横截面积（单位：m2），ρ 为导体的电阻率（单位：Ω·m）\n\n​ **在长度 L 和横截面积 S 相同的情况下，电阻率越大的导体其电阻越大**\n\n## 1.1.3 电位、电压和电动势\n\n### 1．电位\n\n​ 电源的正极输出电流，流到 A 点，再经 R1 流到 B 点，然后通过 R2 流到 C 点，最后流到电源的负极。\n\n​ 为了表明某点为零基准点，通常在该点处画一个“⊥”符号，该符号称为接地符号，接 地符号处的电位规定为 0V\n\n### 2．电压\n\n​ 电路中的 A 点和 B 点的电位是不同的，有一定的差距，这种电位之间的差距称为电位差，又称电压\n\n​ **因为 A 点和 B 点电位差实际上就是电阻器 R1 两端的电位差（即电压）， R1 两端的电压用 UR1 表示，所以 UAB=UR1。**\n\n### 3．电动势\n\n​ 电源消耗能量在两极建立的电位差称为电动势，电动势的单位也为伏特\n\n​ 由于电源内部的电流是由负极流向正极，故电源的电动势方向规定为从电源负极指向正极。\n\n![1707404233131](../assets/%E7%94%B5%E5%AD%90%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%85%A5%E9%97%A8%E7%AF%87-%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/1707404233131.png)\n\n## 1.1.4 电路的 3 种状态\n\n![1707404376520](../assets/%E7%94%B5%E5%AD%90%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%85%A5%E9%97%A8%E7%AF%87-%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/1707404376520.png)\n\n### 1．通路\n\n​ 电路处于通路状态的特点有：电路畅通，有正常的电流流过负载，负载正常工作。\n\n### 2．开路\n\n​ 电路处于开路状态的特点有：电路断开，无电流流过负载，负载不工作。\n\n### 3．短路\n\n​ 电路处于短路状态的特点有：电路中有很大电流流过，但电流不流过负载，负载不工作。\n\n## 1.1.5 接地与屏蔽\n\n### 1．接地\n\n（1）在电路中，接地符号处的电位规定为 0V。\n\n（2）在电路中，标有接地符号的地方都是相通的。\n\n![1707404504012](../assets/%E7%94%B5%E5%AD%90%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%85%A5%E9%97%A8%E7%AF%87-%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/1707404504012.png)\n\n### 2．屏蔽\n\n​ 屏蔽的具体做法是用金属材料（称为屏蔽罩）将元器件或电路封闭起来，再将屏蔽罩接地。\n\n## 1.1.6 欧姆定律\n\n​ 在电路中，流过电阻的电流 I 的大小与电阻两端的电压 U 成正比，与电阻 R 的大小成反比，即\n\n![1707404560995](../assets/%E7%94%B5%E5%AD%90%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%85%A5%E9%97%A8%E7%AF%87-%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/1707404560995.png)\n\n​ 也可以是**U=IR 或者 R=U/I 注意：在电路中，某点电压指的是该点与地之间的电压**\n\n## 1.1.7 电功、电功率和焦耳定律\n\n### 1．电功\n\n​ 可见电流流过一些用电设备时是会做功的，电流做的功称为电功。\n\n![1707404684171](../assets/%E7%94%B5%E5%AD%90%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%85%A5%E9%97%A8%E7%AF%87-%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/1707404684171.png)\n\n​ W 表示电功，单位为焦（J）；U 表示电压，单位为伏（V）；I 表示电流，单位为安（A）；t 表示时间，单位为秒（s）\n\n### 2．电功率\n\n​ 电功率是指单位时间里电流通过用电设备所做的功。\n\n​ 电功率常用 P 表示，单位为瓦（W），此外还有千瓦（kW）和毫瓦（mW），它们之间的换算关系是\n\n![1707404752953](../assets/%E7%94%B5%E5%AD%90%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%85%A5%E9%97%A8%E7%AF%87-%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/1707404752953.png)\n\n​ 电功率的计算公式是\n\n![1707404766965](../assets/%E7%94%B5%E5%AD%90%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%85%A5%E9%97%A8%E7%AF%87-%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/1707404766965.png)\n\n![1707404773605](../assets/%E7%94%B5%E5%AD%90%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%85%A5%E9%97%A8%E7%AF%87-%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/1707404773605.png)\n\n​ **1kW·h 可以这样理解：一个电功率为 100W 的灯泡连续使用 10h 消耗的电功为 1kW·h，即消耗 1 度电。**\n\n![1707404801341](../assets/%E7%94%B5%E5%AD%90%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%85%A5%E9%97%A8%E7%AF%87-%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/1707404801341.png)\n\n### 3．焦耳定律\n\n​ 电流流过导体，导体发出的热量与导体流过的电流、导体的电阻和通电的时间有关。\n\n![1707404824314](../assets/%E7%94%B5%E5%AD%90%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%85%A5%E9%97%A8%E7%AF%87-%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/1707404824314.png)\n\n​ Q 表示热量，单位为焦耳（J）；R 表示电阻，单位为欧姆（Ω）；t 表示时间，单位为秒（s）。\n\n该定律说明：电流流过导体产生的热量，与电流的平方、导体的电阻及通电时间成正比。\n\n## 1.2 电阻的连接方式\n\n### 1.2.1 电阻的串联\n\n![1707404874218](../assets/%E7%94%B5%E5%AD%90%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%85%A5%E9%97%A8%E7%AF%87-%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/1707404874218.png)\n\n​ 电阻串联电路的特点有以下几个。:\n\n​ ① 流过各串联电阻的电流相等，都为**I**。\n\n​ ② 电阻串联后的总电阻增大，总电阻等于各串联电阻之和，即**R=R1+R2**\n\n​ ③ 总电压等于各串联电阻上电压之和，即**U=U1+U2**\n\n​ ④ 电阻越大，两端电压越高，因为**R1<R2**，所以**UR1<UR2**。\n\n### 1.2.2 电阻的并联\n\n![1707404927903](../assets/%E7%94%B5%E5%AD%90%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%85%A5%E9%97%A8%E7%AF%87-%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/1707404927903.png)\n\n​ 电阻并联电路的特点有以下几个。\n\n​ ① 并联电阻两端的电压相等，即总电流等于流过各个并联电阻的电流之和，即**I=I1+I2**\n\n​ ③ 电阻并联总电阻减小，总电阻的倒数等于各并联电阻的倒数之 **1/R=1/R1+1/R2**和，即该式子可变形为 **R=R1R2/R1+R2**\n\n​ ④ 在并联电路中，电阻越小，流过电阻的电流越大，因为 R1<R2，所以 I1>I2。\n\n### 1.2.3 电阻的混联\n\n![1707405005870](../assets/%E7%94%B5%E5%AD%90%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%85%A5%E9%97%A8%E7%AF%87-%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/1707405005870.png)\n\n## 1.3 直流电与交流电\n\n### 1.3.1 直流电\n\n​ 直流电是指方向始终固定不变的电压或电流。\n\n#### 1．稳定直流电\n\n​ 稳定直流电是指方向固定不变并且大小也不变的直流电。\n\n#### 2．脉动直流电\n\n​ 脉动直流电是指方向固定不变，但大小随时间变化的直流电。\n\n![1707406123556](../assets/%E7%94%B5%E5%AD%90%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%85%A5%E9%97%A8%E7%AF%87-%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/1707406123556.png)\n\n### 1.3.2 交流电\n\n​ 交流电是指方向和大小都随时间作周期性变化的电压或电流\n\n#### 1．正弦交流电\n\n![1707406160307](../assets/%E7%94%B5%E5%AD%90%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%85%A5%E9%97%A8%E7%AF%87-%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/1707406160307.png)\n\n![1707406191267](../assets/%E7%94%B5%E5%AD%90%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%85%A5%E9%97%A8%E7%AF%87-%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/1707406191267.png)\n\n#### 2．周期和频率\n\n![1707406215283](../assets/%E7%94%B5%E5%AD%90%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%85%A5%E9%97%A8%E7%AF%87-%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/1707406215283.png)\n\n##### （1）周期\n\n​ 交流电变化过程是不断重复的，交流电重复 变化一次所需的时间称为周期，周期用 T 表示，单位是秒（s）。\n\n##### （2）频率\n\n​ 交流电在每秒钟内重复变化的次数称为频率，频率用 f 表示，它是 周期的倒数，即\n\n![1707406263380](../assets/%E7%94%B5%E5%AD%90%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%85%A5%E9%97%A8%E7%AF%87-%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/1707406263380.png)\n\n该交流电的频率 f=50Hz，说明在 1s 内交流电能重复 0 ～ t4 这个过程 50 次。交流电变化越快，变化一次所\n\n需要的时间越短，周期就越短，频率就越高。\n\n##### （3）高频、中频和低频\n\n​ 频率在 3MHz 以上的信号称为高频信号，频率在 300kHz ～ 3MHz 范围内的信 号称为中频信号，频率低于 300kHz 的信号称为低频信号。\n\n#### 3．瞬时值和有效值\n\n##### （1）瞬时值\n\n​ 交流电的大小和方向是不断变化的，交流电在某一时刻的值称为 交流电在该时刻的瞬时值。\n\n##### （2）有效值\n\n![1707406384977](../assets/%E7%94%B5%E5%AD%90%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%85%A5%E9%97%A8%E7%AF%87-%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/1707406384977.png)\n\n所示两个电路中的电热丝完全一样，现分别给电热丝通交流电和直流电，如果两电路通电时间相同，并且电热丝发出热量也相同，对电热丝来说，这里的交流电和直流电是等效的，那么就将图 1-21（b）中直流电的电压值或电流值称为图 1-21（a）中交流电的有效电压值或有效电流值。正弦交流电的有效值与最大瞬时值的关系是\n\n![1707406435105](../assets/%E7%94%B5%E5%AD%90%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%85%A5%E9%97%A8%E7%AF%87-%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/1707406435105.png)\n\n#### 4．相位与相位差\n\n##### （1）相位\n\n![1707406464006](../assets/%E7%94%B5%E5%AD%90%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%85%A5%E9%97%A8%E7%AF%87-%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/1707406464006.png)\n\n​ 交流电在某时刻的角度称为交流电在该时刻的相位。\n\n##### （2）相位差\n\n​ 相位差是指两个同频率交流电的相位之差。\n\n![1707406487924](../assets/%E7%94%B5%E5%AD%90%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%85%A5%E9%97%A8%E7%AF%87-%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/1707406487924.png)\n\n​ 两个交流电存在相位差实际上就是两个交流电变化存在着时间差。\n","tags":["电子技术"],"categories":["电子技术"]},{"title":"第五章-初始HAL库","url":"/2024/02/06/第五章-初始HAL库/","content":"\n![1707232401368](../assets/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%88%9D%E5%A7%8BHAL%E5%BA%93/1707232401368.png)\n\n## 一、库目录、文件介绍\n\n![1707232814478](../assets/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%88%9D%E5%A7%8BHAL%E5%BA%93/1707232814478.png)\n\n**Documentation：如何使用驱动库来编写自己的应用程序**\n\n**Drivers：文件夹下是官方的 CMSISI 库，HAL 库，板载外设驱动。**\n\n**Middlewares：中间件，包含 ST 官方的 STemWin、STM32_Audio、STM32_USB_Device_Library、STM32_USB_Host_Library；也有第三方的 fatfs 文件系统等等。**\n\n**_Project_ ：文件夹下是用驱动库写的针对官方发行 demo 板的例子和工程模板。**\n\n**Utilities：实用的公用组件比如 LCD_LOG 实用液晶打印调试信息。**\n\n**Release_Note.html:：库的版本更新说明。**\n\n## 2、CMSIS 文件\n\n![1707233331041](../assets/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%88%9D%E5%A7%8BHAL%E5%BA%93/1707233331041.png)\n","tags":["STM32"],"categories":["野火STM32"]},{"title":"第四章-自己创建函数库","url":"/2024/02/02/第四章-自己创建函数库/","content":"\n![1706848296026](../assets/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%87%AA%E5%B7%B1%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0%E5%BA%93/1706848296026.png)\n\n![1707148103038](../assets/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%87%AA%E5%B7%B1%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0%E5%BA%93/1707148103038.png)\n\n## 1、片上外设基地址\n\n```\n#define PERIPH_BASE           ((unsigned int)0x40000000)\n```\n\n## 2、总线基地址\n\n```\n#define AHB1PERIPH_BASE       (PERIPH_BASE + 0x00020000)\n```\n\n## 3、GPIO 外设基地址\n\n```\n#define GPIOH_BASE            (AHB1PERIPH_BASE + 0x1C00)\n```\n\n![1706889171120](../assets/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%87%AA%E5%B7%B1%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0%E5%BA%93/1706889171120.png)\n\n//H 高十位，L 低十位\n\n![1707231761899](../assets/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%87%AA%E5%B7%B1%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0%E5%BA%93/1707231761899.png)\n","tags":["STM32"],"categories":["野火STM32"]},{"title":"24年技能大赛广东样题","url":"/2024/01/17/24年技能大赛广东样题/","content":"\n# 24年样题1\n\n## 一、接线\n\n## 二、维护\n\n### 三、sql server维护\n\n![1705654362719](../assets/24%E5%B9%B4%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E5%B9%BF%E4%B8%9C%E6%A0%B7%E9%A2%98/1705654362719.png)\n\n![1705655155691](../assets/24%E5%B9%B4%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E5%B9%BF%E4%B8%9C%E6%A0%B7%E9%A2%98/1705655155691.png)\n\n![1705654843318](../assets/24%E5%B9%B4%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E5%B9%BF%E4%B8%9C%E6%A0%B7%E9%A2%98/1705654843318.png)\n\n![1705655131418](../assets/24%E5%B9%B4%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E5%B9%BF%E4%B8%9C%E6%A0%B7%E9%A2%98/1705655131418.png)\n\n# 24年样题2\n\n## 一、接线\n\n![1705468701401](../assets/24%E5%B9%B4%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E5%B9%BF%E4%B8%9C%E6%A0%B7%E9%A2%98/1705468701401.png)\n\n## 二、维护\n\n![1705472418742](../assets/24%E5%B9%B4%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E5%B9%BF%E4%B8%9C%E6%A0%B7%E9%A2%98/1705472418742.png)\n\n![1705472834357](../assets/24%E5%B9%B4%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E5%B9%BF%E4%B8%9C%E6%A0%B7%E9%A2%98/1705472834357.png)\n\n![1705472874215](../assets/24%E5%B9%B4%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E5%B9%BF%E4%B8%9C%E6%A0%B7%E9%A2%98/1705472874215.png)\n\n![1705473256503](../assets/24%E5%B9%B4%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E5%B9%BF%E4%B8%9C%E6%A0%B7%E9%A2%98/1705473256503.png)\n\n![1705473265323](../assets/24%E5%B9%B4%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E5%B9%BF%E4%B8%9C%E6%A0%B7%E9%A2%98/1705473265323.png)\n\n![1705473783244](../assets/24%E5%B9%B4%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E5%B9%BF%E4%B8%9C%E6%A0%B7%E9%A2%98/1705473783244.png)\n\n![1705473825000](../assets/24%E5%B9%B4%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E5%B9%BF%E4%B8%9C%E6%A0%B7%E9%A2%98/1705473825000.png)\n\n# 24年样题3\n\n## 一、接线\n\n## 二、维护\n\n![1705473942700](../assets/24%E5%B9%B4%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E5%B9%BF%E4%B8%9C%E6%A0%B7%E9%A2%98/1705473942700.png)\n\n\n\n![1705474322751](../assets/24%E5%B9%B4%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E5%B9%BF%E4%B8%9C%E6%A0%B7%E9%A2%98/1705474322751.png)\n\n\n\n![1705474268550](../assets/24%E5%B9%B4%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E5%B9%BF%E4%B8%9C%E6%A0%B7%E9%A2%98/1705474268550.png)\n\n# 24年样题4\n\n## 一、接线\n\n## 二、维护\n\n**重复的题省略**\n\n![1705475300335](../assets/24%E5%B9%B4%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E5%B9%BF%E4%B8%9C%E6%A0%B7%E9%A2%98/1705475300335.png)\n\n![1705474882469](../assets/24%E5%B9%B4%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E5%B9%BF%E4%B8%9C%E6%A0%B7%E9%A2%98/1705474882469.png)\n\n![1705474910725](../assets/24%E5%B9%B4%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E5%B9%BF%E4%B8%9C%E6%A0%B7%E9%A2%98/1705474910725.png)\n\n# 24年样题5\n\n## 一、接线\n\n## 二、维护\n\n![1705475461356](../assets/24%E5%B9%B4%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E5%B9%BF%E4%B8%9C%E6%A0%B7%E9%A2%98/1705475461356.png)\n\n![1705475449777](../assets/24%E5%B9%B4%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E5%B9%BF%E4%B8%9C%E6%A0%B7%E9%A2%98/1705475449777.png)\n\n![1705475668184](../assets/24%E5%B9%B4%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E5%B9%BF%E4%B8%9C%E6%A0%B7%E9%A2%98/1705475668184.png)\n\n![1705475763975](../assets/24%E5%B9%B4%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E5%B9%BF%E4%B8%9C%E6%A0%B7%E9%A2%98/1705475763975.png)\n\n![1705475906704](../assets/24%E5%B9%B4%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E5%B9%BF%E4%B8%9C%E6%A0%B7%E9%A2%98/1705475906704.png)\n\n# 24年样题6\n\n## 一、接线\n\n## 二、维护\n\n![1705476564047](../assets/24%E5%B9%B4%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E5%B9%BF%E4%B8%9C%E6%A0%B7%E9%A2%98/1705476564047.png)\n\n![1705476555115](../assets/24%E5%B9%B4%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E5%B9%BF%E4%B8%9C%E6%A0%B7%E9%A2%98/1705476555115.png)\n\n![1705476641917](../assets/24%E5%B9%B4%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E5%B9%BF%E4%B8%9C%E6%A0%B7%E9%A2%98/1705476641917.png)\n\n![1705476664813](../assets/24%E5%B9%B4%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E5%B9%BF%E4%B8%9C%E6%A0%B7%E9%A2%98/1705476664813.png)","tags":["样题"],"categories":["技能大赛"]},{"title":"SCREEPS","url":"/2023/11/27/SCREEPS/","content":"\n## 创建机器人\n\n```javascript\nvar crepp = Game.creeps['MiningRobot'];\nGame.spawns[\"Spawn1\"].spawnCreep([WORK, CARRY, MOVE], \"Harvester1\");\n```\n\n## 采集能量\n\n```javascript\nmodule.exports.loop = function () {\n    var creep = Game.creeps['Harvester1'];\n    var sources = creep.room.find(FIND_SOURCES);\n    if(creep.harvest(sources[0]) == ERR_NOT_IN_RANGE) {\n        creep.moveTo(sources[0]);\n    }\n}\n\n```\n\n## 采集能量返回\n\n```javascript\nmodule.exports.loop = function () {\n    var creep = Game.creeps['Harvester1'];\n    if(creep.store.getFreeCapacity() > 0) {\n        var sources = creep.room.find(FIND_SOURCES);\n        if(creep.harvest(sources[0]) == ERR_NOT_IN_RANGE) {\n            creep.moveTo(sources[0]);\n        }\n    }\n    else {\n        if( creep.transfer(Game.spawns['Spawn1'], RESOURCE_ENERGY) == ERR_NOT_IN_RANGE ) {\n            creep.moveTo(Game.spawns['Spawn1']);\n        }\n    }\n}\n```\n\n```javascript\nmodule.exports.loop = function () {\n    for(var name in Game.creeps) {\n        var creep = Game.creeps[name];\n        if(creep.store.getFreeCapacity() > 0) {\n            //检查是否又剩余的容量\n            var sources = creep.room.find(FIND_SOURCES);\n            //创建能量的变量，指的是找到这所房间的全部能量\n            if(creep.harvest(sources[0]) == ERR_NOT_IN_RANGE) {\n                 //让creep从列表的第一个能源点采集能源\n                creep.moveTo(sources[0]);\n                //如果不在能源采集范围，能会走向第一个能源点移动\n            }\n        }\n        else {//当容量已满时，返回Spawn1\n            if(creep.transfer(Game.spawns['Spawn1'], RESOURCE_ENERGY) == ERR_NOT_IN_RANGE) {\n                creep.moveTo(Game.spawns['Spawn1']);\n            }\n        }\n    }\n}\n```\n\n## 代码优化\n\n```javascript\nvar roleHarvester = require('role.harvester');\n\nmodule.exports.loop = function () {\n    for(var name in Game.creeps) {\n        var creep = Game.creeps[name];\n        roleHarvester.run(creep);\n    }\n}\n\nvar roleHarvester = {\n    /** @param {Creep} creep **/\n    run: function(creep) {\n\t    if(creep.store.getFreeCapacity() > 0) {\n            var sources = creep.room.find(FIND_SOURCES);\n            if(creep.harvest(sources[0]) == ERR_NOT_IN_RANGE) {\n                creep.moveTo(sources[0]);\n            }\n        }\n        else {\n            if(creep.transfer(Game.spawns['Spawn1'], RESOURCE_ENERGY) == ERR_NOT_IN_RANGE) {\n                creep.moveTo(Game.spawns['Spawn1']);\n            }\n        }\n\t}\n};\n\nmodule.exports = roleHarvester;\n```\n\n## 升级建筑\n\n```javascript\n//生成机器人\nGame.spawns['Spawn1'].spawnCreep( [WORK, CARRY, MOVE], 'Upgrader1' );\nvar roleHarvester = require('role.harvester');\nvar roleUpgrader = require('role.upgrader');\n\nmodule.exports.loop = function () {\n\n    for(var name in Game.creeps) {\n        var creep = Game.creeps[name];\n        if(creep.memory.role == 'harvester') {\n            roleHarvester.run(creep);\n        }\n        if(creep.memory.role == 'upgrader') {\n            roleUpgrader.run(creep);\n        }\n    }\n}\n```\n\n```javascript\nvar roleUpgrader = {\n\n    /** @param {Creep} creep **/\n    run: function(creep) {\n\t    if(creep.store[RESOURCE_ENERGY] == 0) {\n            var sources = creep.room.find(FIND_SOURCES);\n            if(creep.harvest(sources[0]) == ERR_NOT_IN_RANGE) {\n                creep.moveTo(sources[0]);\n            }\n        }\n        else {\n            if(creep.upgradeController(creep.room.controller) == ERR_NOT_IN_RANGE) {\n                creep.moveTo(creep.room.controller);\n            }\n        }\n\t}\n};\n\nmodule.exports = roleUpgrader;\n\n//每个 creep 都有的 memory 属性，该属性允许在 creep 的“内存”中写入自定义信息。\nGame.creeps['Harvester1'].memory.role = 'harvester';\nGame.creeps['Upgrader1'].memory.role = 'upgrader';\n\n//main\nvar roleHarvester = require('role.harvester');\nvar roleUpgrader = require('role.upgrader');\n\nmodule.exports.loop = function () {\n\n    for(var name in Game.creeps) {\n        var creep = Game.creeps[name];\n        if(creep.memory.role == 'harvester') {\n            roleHarvester.run(creep);\n        }\n        if(creep.memory.role == 'upgrader') {\n            roleUpgrader.run(creep);\n        }\n    }\n}\n```\n\n"},{"title":"技能大赛之Ubuntu维护","url":"/2023/10/30/技能大赛之Ubuntu维护/","content":"\n**如果是首次进入需要 sudo passwd root 启用 root 用户**\n\n## 一、修改网络 IP 地址\n\n```bash\n1、lm@lm-virtual-machine:~/桌面$ su root\n密码：\n2、root@lm-virtual-machine:/home/lm/桌面# cd /etc/netplan/\n3、root@lm-virtual-machine:/etc/netplan# ls\n01-network-manager-all.yaml\n4、root@lm-virtual-machine:/etc/netplan# vim 01-network-manager-all.yaml\n#键盘点击i，进行修改，\"esc\"退出编辑，输入\":wq\"退出回车保存。输入\"netplan apply\",ifconfig可以查看是否修改成功\n```\n\n```bash\nnetwork:\n　version: 2\n　ethernets:\n　　ens5:\n　　dhcp4: no\n　　addresses: [192.168.1.230/24]\n　　gateway4: 192.168.1.254\n　　nameservers:\n　　　addresses: [8.8.4.4,8.8.8.8]\n```\n\n## 二、使用命令查询磁盘空间使用情况 【df】\n\n![1698852278392](../assets/%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E4%B9%8BUbuntu%E7%BB%B4%E6%8A%A4/1698852278392.png)\n\n## 三、命令执行的历史记录【history】\n\n![1698852341664](../assets/%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E4%B9%8BUbuntu%E7%BB%B4%E6%8A%A4/1698852341664.png)\n\n## 四、配置允许 tcp 协议通过 eth0 网卡的 80 端口进入服务器\n\n```bash\niptables -A INPUT -p tcp --dport 80 -i th0 -j ACCEPT\niptables -L -n\n```\n\n![1698852524750](../assets/%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E4%B9%8BUbuntu%E7%BB%B4%E6%8A%A4/1698852524750.png)\n\n## 五、开启系统简单防火墙功能\n\n```bash\nufw enable\nufw status\n```\n\n![1698852634735](../assets/%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E4%B9%8BUbuntu%E7%BB%B4%E6%8A%A4/1698852634735.png)\n\n## 六、修改时区为中国\n\n```\ntzselect\n```\n\n![1698852764405](../assets/%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E4%B9%8BUbuntu%E7%BB%B4%E6%8A%A4/1698852764405.png)\n\n## 七、查看当前系统的内核版本\n\n```\nuname -a\n```\n\n![1698852836682](../assets/%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E4%B9%8BUbuntu%E7%BB%B4%E6%8A%A4/1698852836682.png)\n\n## 八、查看系统安装包的统计信息\n\n```bash\napt-cache stats\n```\n\n![1698853016548](../assets/%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E4%B9%8BUbuntu%E7%BB%B4%E6%8A%A4/1698853016548.png)\n\n## 九、查看/home 目录占用空间\n\n```bash\ndu -sh\n```\n\n![1698853060624](../assets/%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E4%B9%8BUbuntu%E7%BB%B4%E6%8A%A4/1698853060624.png)\n\n## 十、系统内存的使用情况\n\n```\nfree\n```\n\n![1698853106741](../assets/%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E4%B9%8BUbuntu%E7%BB%B4%E6%8A%A4/1698853106741.png)\n\n## 十一、修改 test 文件夹权限为 755\n\n```\nmkdir xxx\n      创建文件夹\nchmod xxx xxx\n    修改后文件夹名字  修改前\n```\n\n![1698853202599](../assets/%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E4%B9%8BUbuntu%E7%BB%B4%E6%8A%A4/1698853202599.png)\n\n## 十二、配置用户锁策略，用户尝试登录错误 5 次后锁定用户 5 分钟\n\n```bash\nauth required pam_tallu.so deny=5 unlock_time=300 even_deny_root root_unlock_time=300\n#文件夹在etc/pam.d/login\n#deny=尝试次数 unlock_time=被锁定，多少秒自动解锁\n#even_deny_root=对root用户生效 root_unlock_time=被锁后多少秒解锁\n```\n\n![1698853824171](../assets/%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E4%B9%8BUbuntu%E7%BB%B4%E6%8A%A4/1698853824171.png)\n\n## 十三、配置账户密码最短使用期限为 10 天，最长使用期限为 90 天\n\n```bash\nsudo chage -M 90 -m 10 liu\n#修改\n#查看\nsudo chage -l liu\n```\n\n## 十四、配置用户使用 ssh 登录边缘服务器有“For authorized users only”\n\n```bash\nvim /ect/motd\n```\n\n![1698884808296](../assets/%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E4%B9%8BUbuntu%E7%BB%B4%E6%8A%A4/1698884808296.png)\n\n## 十五、查询系统运行时间及负载的状态\n\n```\nuptime\n```\n\n![1698884864394](../assets/%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E4%B9%8BUbuntu%E7%BB%B4%E6%8A%A4/1698884864394.png)\n\n## 十六、统计系统 IO 信息（系统资源）\n\n```\ntop\n```\n\n![1698884920652](../assets/%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E4%B9%8BUbuntu%E7%BB%B4%E6%8A%A4/1698884920652.png)\n\n## 十七、查看当前登录系统的用户信息\n\n![1698885625168](../assets/%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E4%B9%8BUbuntu%E7%BB%B4%E6%8A%A4/1698885625168.png)\n\n## 十八、ubuntu 登录开通 ssh-server 和 root 用户登录权限\n\n![1705237320499](../assets/%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E4%B9%8BUbuntu%E7%BB%B4%E6%8A%A4/1705237320499.png)\n\n![1698886136723](../assets/%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E4%B9%8BUbuntu%E7%BB%B4%E6%8A%A4/1698886136723.png)\n\n![1698886175641](../assets/%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E4%B9%8BUbuntu%E7%BB%B4%E6%8A%A4/1698886175641.png)\n\n**sudo systemctl start ssh** 启动 ssh 服务\n\n## 十九、修改 root 用户密码\n\n![1698886297484](../assets/%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E4%B9%8BUbuntu%E7%BB%B4%E6%8A%A4/1698886297484.png)\n\n## 二十、切换当前用户为 root 用户\n\n![1698886334325](../assets/%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E4%B9%8BUbuntu%E7%BB%B4%E6%8A%A4/1698886334325.png)\n\n## 二十一、查看当前所有已连接端口\n\n```\nnetstar -ntlp\n```\n\n![1698886374037](../assets/%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E4%B9%8BUbuntu%E7%BB%B4%E6%8A%A4/1698886374037.png)\n\n## 二十二、查看指定端口状态\n\n```\nnetstat -ntlplgrep 3306\n```\n\n![1698888006633](../assets/%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E4%B9%8BUbuntu%E7%BB%B4%E6%8A%A4/1698888006633.png)\n\n## 二十三、查看所有进程信息\n\n```\nps -aux\n```\n\n![1698888087310](../assets/%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E4%B9%8BUbuntu%E7%BB%B4%E6%8A%A4/1698888087310.png)\n\n## 二十四、查看指定进程信息\n\n![1698888389492](../assets/%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E4%B9%8BUbuntu%E7%BB%B4%E6%8A%A4/1698888389492.png)\n\n## 二十五、终端查找文件\n\n**在当前目录中搜索**\n\n```\nfind -name \"文件名\"\n```\n\n**在不切换任何文件夹搜索，必须在命令中声明文件所在目录路劲**\n\n```\nfind /路径/ -name \"文件名\"\n```\n\n**如果在终端搜索文件**\n\n```\nfind -name \"文件名\"\n```\n\n**如果在终端搜索带某字符的文件**\n\n```\nfind / -type f -name \"*DB*\"\n```\n\n![1700143228913](../assets/%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E4%B9%8BUbuntu%E7%BB%B4%E6%8A%A4/1700143228913.png)\n\n## 二十六、在终端查看 sql 文件的记录\n\n```\nhead -n 文件名.sql\n```\n\n![1700144597727](../assets/%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E4%B9%8BUbuntu%E7%BB%B4%E6%8A%A4/1700144597727.png)\n\n## 二十七、 使用命令查看要求上传 sql 文件的内容中 包含“xxx”信息的记录行。\n\n```\ngrep \"xxx\" xxx.sql\n```\n\n![1700145383555](../assets/%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E4%B9%8BUbuntu%E7%BB%B4%E6%8A%A4/1700145383555.png)\n\n## 二十八、在 Ubuntu 的终端中使用命令查看要求上传 sql 文件内容并显示行号。\n\n```\ncat -n xx.sql\n```\n\n![1700145504953](../assets/%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E4%B9%8BUbuntu%E7%BB%B4%E6%8A%A4/1700145504953.png)\n\n## 二十九、在 Ubuntu 的终端中通过 iptables 配置规则链：允许本机开放 TCP 端口 5000-6000\n\n```bash\niptables -A INPUT -p tcp --match multiport --sports 5000:6000 -j ACCEPT\n# 如果需要重启后重新起效  iptables-save > /etc/iptables/rules.v4\n```\n\n## 三十、设置账号密码的最小长度\n\n```\nvim /etc/pam.d/common-password\n```\n\n![1701329835846](../assets/%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E4%B9%8BUbuntu%E7%BB%B4%E6%8A%A4/1701329835846.png)\n\n## 三十一、为 MySQL 配置远程访问功能，以便任何 IP 的客户端都能访问数据库\n\n```bash\n#配置用户信息\nmysql -u root -p\nALTER USER 'username'@'localhost' IDENTIFIED WITH 'mysql_native_password' BY 'new_password';\n#先配置mysql文件\nsudo nano /etc/mysql/mysql.conf.d/mysqld.cnf\n#添加\nbind-address = 0.0.0.0\n#更改用户权限\nCREATE USER 'username'@'%' IDENTIFIED BY 'password';\n            #用户名字 #允许任何ip连接         #密码\nGRANT ALL PRIVILEGES ON *.* TO 'username'@'%' WITH GRANT OPTION;\nFLUSH PRIVILEGES;\n#重启数据库\nsudo systemctl restart mysql\n#查询是否生效\nSELECT user,authentication_string,host FROM mysql.user;\n```\n\n![1701523808071](../assets/%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E4%B9%8BUbuntu%E7%BB%B4%E6%8A%A4/1701523808071.png)\n\n**开启成功**\n\n![1701524538009](../assets/%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E4%B9%8BUbuntu%E7%BB%B4%E6%8A%A4/1701524538009.png)\n\n## 三十二、命令行查询网卡 eth0 的工作状态\n\n```bash\nifconfig eth0\n```\n\n## 三十三、Xshell 登录 Ubuntu\n\n![1705415011698](../assets/%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E4%B9%8BUbuntu%E7%BB%B4%E6%8A%A4/1705415011698.png)\n\n![1705415023009](../assets/%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E4%B9%8BUbuntu%E7%BB%B4%E6%8A%A4/1705415023009.png)\n\n## 三十四、删除指令\n\n![1705416981495](../assets/%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E4%B9%8BUbuntu%E7%BB%B4%E6%8A%A4/1705416981495.png)\n\n## 三十五、在/home/iotuser 目录下创建 aaa,bbb 两个目录，在 aaa 目录下添加 a.txt 文件，在 bbb 目录下添加 ccc 目录和 b.txt 文件,在 ccc 目录下添加 c.txt 文件。 命令行将 bbb 文件夹权限设置为：每个人都有读和写以及执行的权限（包含子目录）。 合并压缩 aaa 和 bbb 目录为 xxx.tar.gz。\n\n```bash\nmkdir -p /home/iotuser/aaa /home/iotuser/bbb/ccc\ntouch /home/iotuser/aaa/a.txt\ntouch /home/iotuser/bbb/b.txt\ntouch /home/iotuser/bbb/ccc/c.txt\n\n\nchmod -R 777 /home/iotuser/bbb\n\n\ncd /home/iotuser\ntar -czvf xxx.tar.gz aaa bbb\n```\n\n## 三十六、在终端配置 ufw，要求设置允许 TCP 的 5505 端口可以访问本机。\n\n```bash\nsudo ufw allow 5505/tcp\n#保存\nsudo ufw status\n```\n\n## 三十七、在终端使用 ufw，要求允许 192.168.0.200 这台计算机访问本机。\n\n```\nsudo ufw allow from 192.168.0.200\n```\n\n## 三十八、修改配置将 ssh 服务远程连接的默认端口修改成 8888。\n\n```\nsudo vim /etc/ssh/sshd_config\n#修改\nPort 8888\n```\n\n## 三十九、离线安装 mysql、python，vim\n\n```bash\n#解压mysql\nunzip name.file\n#给权限\nsudo chmod 775 install.sh\n#开启服务\nsudo service mysql start\n#设置密码\nsudo mysql_secure_installation\n\n#安装python\nsudo dpkg -i python.deb python-libraries.deb\n\n#安装vim\nsudo dpkg -i vim.deb\n```\n\n## 四十、查看当前操作系统版本信息\n\n```bash\ncat /etc/lsb-release\n```\n\n![1705475005240](../assets/%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E4%B9%8BUbuntu%E7%BB%B4%E6%8A%A4/1705475005240.png)\n\n## 四十一、查看系统内核限制\n\n```\nipcs -l\n```\n\n![1705474996383](../assets/%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E4%B9%8BUbuntu%E7%BB%B4%E6%8A%A4/1705474996383.png)\n\n## 四十二、使用 scp 传输\n\n```bash\nscp /path/file root@172.20.1.1:/path/file\n```\n\n## 四十三、在终端中使用命令添加一个名为 lily 的用户名，要求在 home 目录下同步创建该用户目录。将该用户添加到名为 school Admin 的用户组\n\n```bash\n#创建schoolAdmin用户组\nsudo groupadd schoolAdmin\n#创建lily的用户名\nsudo useradd -m lily\n#将将该用户添加到名为school Admin的用户组\nsudo usermod -a -G schoolAdmin lily\n```\n\n## 四十五、查看 root 用户进程信息\n\n```bash\nps -u root\n```\n\n## 四十六、命令查询 Ubuntu 系统有几块物理硬盘\n\n```bash\n#只显示几块硬盘\nlsblk -d | grep disk | wc -l\n```\n\n## 四十七、mysql 命令查询主程序所在路径的参数\n\n```#bash\n#which mysqld\n#SHOW VARIABLES LIKE 'basedir';\n```\n\n![1705765441912](../assets/%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E4%B9%8BUbuntu%E7%BB%B4%E6%8A%A4/1705765441912.png)\n\n![1705765448044](../assets/%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E4%B9%8BUbuntu%E7%BB%B4%E6%8A%A4/1705765448044.png)\n\n## 四十八、查看数据库大小\n\n```bash\nSELECT CONCAT(ROUND(SUM(data_length / 1024 / 1024), 2), ' MB') AS data\nFROM information_schema.TABLES\nWHERE table_schema = 'testdatabase';\n```\n\n## 四十九、mysql 创建数据库然后导入 sql\n\n```mysql\nsource 文件路径;\n```\n\n## 五十、查看指定用户进程\n\n```bash\nps -u root\n```\n\n## 五十一、ubuntu 安装 mysql\n\n```\n#解压mysql\nunzip name.file\n#775权限\nsudo chmod 775 name.file\n#执行安装\nsudo ./install.sh\n#开启服务\nsudo server mysql start\n#输入密码\nmysql -u root -p\n```\n","tags":["Ubuntu维护"],"categories":["技能大赛"]},{"title":"CSS第二天","url":"/2023/10/24/CSS第二天/","content":"\n"},{"title":"CSS第一天","url":"/2023/10/24/CSS第一天/","content":"\n## 1.CSS 语法规范\n\n```\nh1{color:red; font-size:25px;}\n选择器 属性 值\n```\n\n## 2.类选择器\n\n```\n<div class=\"red font20\">亚瑟</div>\n```\n\n## 3.id 选择器\n\n```\n#id名{\n\t属性1：属性值1；\n}\n```\n\n## 4.通配符选择器\n\n```\n*{\n\t属性1：属性值1；\n}\n```\n","tags":["CSS"],"categories":["前端"]},{"title":"HTML第三天","url":"/2023/10/13/HTML第三天/","content":"\n### 1.font-family\n\n```html\nfont-family //定义文本系列\n```\n\n### 2. font-size\n\n属性定义字体大小。\n\n### 3.font-weight\n\n文本字体的粗细\n\n| notmal  | 默认值              |\n| ------- | ------------------- |\n| bold    | 加粗                |\n| 100-900 | 400=normal,700=bold |\n\n### 4.font-style\n\n文本风格\n\n```html\nnormal //默认值 italic//斜体\n```\n\n![1697178989345](../assets/HTML%E7%AC%AC%E4%B8%89%E5%A4%A9/1697178989345.png)\n\n### 5.text-align\n\n文本内容水平对齐方式\n\n```\nleft //左对齐 right //右对齐 center //居中对齐\n```\n\n### 6.text-decoration\n\n给文本添加下划线、删除线、上划线等\n\n| none         | 默认   |\n| ------------ | ------ |\n| underline    | 下划线 |\n| overline     | 上划线 |\n| line-through | 删除线 |\n\n### 7.text-indent\n\n段落首行缩进\n\n### 8.line-height\n\n设置行间的距离（行高）\n","tags":["HTML"],"categories":["前端"]},{"title":"HTML第二天","url":"/2023/10/12/HTML第二天/","content":"\n### 1.表格的基本语法\n\n```html\n    <table> //表格标签\n      <tr> //行\n        <td>单元文字</td>//单元格\n          <th>姓名</th>//表格头部份\n      </tr>\n    </table>\n```\n\n| align       | left\\center\\right | 对齐方式           |\n| ----------- | ----------------- | ------------------ |\n| border      | 1/\"\"              | 有没有边框         |\n| cellpadding | 像素              | 内容与单元格的空白 |\n| cellspacing | 像素              | 单元格之间的空白   |\n| wdith       | 像素              | 宽度               |\n\n### 2.表格结构标签\n\n```html\n<thead></thead> //表格的头部区域\n<tbody></tbody> //表格的主题区域\n```\n\n### 3.合并单元格\n\n```html\nrowspan=\"合并单元格个数\" //跨行\ncolspan=\"个数\" //跨列\n```\n\n### 4.无序列表\n\n```html\n<ul>\n<li></li>\n</ul>\n```\n\n### 5.有序列表\n\n```html\n<ol>\n<li></li>\n</ol>\n```\n\n### 6.自定义列表\n\n```html\n<dl>\n<dt></dt>\n</dl>\n```\n\n### 7.表单域\n\n```\n<form action=\"地址\" method=\"提交方式\" name=\"表单域名称\">\n各种表单元素控件\n</form>\n```\n\n### 8.表单元素\n\n```\n<input type=\"属性值\" />\n```\n\n| button   | 点击按钮                     |\n| -------- | ---------------------------- |\n| checkbox | 复选框                       |\n| file     | 输入字段和浏览按钮，文件上传 |\n| hidden   | 隐藏输入字段                 |\n| password | 密码字段                     |\n| radio    | 单选按钮                     |\n| reset    | 重置按钮                     |\n| submit   | 提交按钮                     |\n| text     | 输入文本                     |\n| image    | 图像形式的提交按钮           |\n\nchecked:规定此input元素怒首次加载时应当呗选中\n\nmaxlength：输入字段中字符的最大长度\n\nplaceholder:占位符\n\n### 8.label标签\n\n```\n<label for=\"sex\">男</label>\n<input type=\"radio\" name=\"sex\" id=\"sex\" />\n//一个和id属性相同\n```\n\n### 9.select表单元素\n\n![1697079442675](../assets/HTML%E7%AC%AC%E4%BA%8C%E5%A4%A9/1697079442675.png)\n\n```\n<select>\n<option>选项1</option>\n<option>选项2</option>\n<option>选项3</option>\n...\n</select>\n//在<option> 中定义 selected =“ selected \" 时，当前项即为默认选中项。\n```\n\n### 10.texttarea表单元素\n\n用于定义多行文本输入控件\n\n```html\n<textarea rows=\"3\" cols=\"20\">\n文本内容\n</textarea>\n//cols=\"每行中的字符\"\n//rows=\"显示的行数\"\n```\n\n```html\n<form>\n<input type=“text \" name=“username”>\n<select name=“jiguan”>\n<option>北京</option>\n</select>\n<textarea name= \"message\"></textarea>\n</form>\n```\n\n","tags":["HTML"],"categories":["前端"]},{"title":"HTML第一天","url":"/2023/10/11/HTML第一天/","content":"\n## HTML 语法规范\n\n```html\n<html></html>\n//html标签 <head></head> //文档的头部 <title></title> //文档的标签\n<body></body>\n//文档的主体\n```\n\n### 1.包含关系\n\n<head>\n    <title></title>\n</head>\n\n### 2.并列关系\n\n```html\n<head></head>\n<body></body>\n```\n\n### 3.文档类型声明标签\n\n采取的是 html5 版本的显示网页\n\n```html\n<!DOCTYPE html>\n```\n\n### 4.标题标签\n\n```html\n<h1>\n  --\n  <h6></h6>\n</h1>\n```\n\n### 5.段落和换行标签\n\n```html\n<p>段落标签</p>\n//根据浏览器窗口的大小自行换行 <br />\n//换行标签\n```\n\n### 6.文本格式化标签\n\n```html\n<strong></strong> <b></b> //加粗 <em></em> <i></i> //倾斜 <del></del>\n<s></s> //删除线 <ins></ins> <u></u> //下划线\n```\n\n### 7.div 和 span 标签\n\n```\n<div>这是盒子</div>  //分割\n<span>这也是盒子</span> //跨度\n```\n\n### 8.图像标签和路径\n\n```\n<img src=\"图像url\" />\n\nkey=\"value\"\n```\n\n| src    | 必须属性                   |\n| ------ | -------------------------- |\n| alt    | 替换文本。图像不能显示文字 |\n| title  | 提示文本。在图像上显示文字 |\n| width  | 图像的宽度                 |\n| height | 图像的盖度                 |\n| border | 边框粗细                   |\n\n### 9.超链接标签\n\n```html\n<a href=\"跳转目标\" target=\"目标窗口的弹出方式\">文本或者图像</a>\n```\n\n### 10.特殊字符\n\n```\n&nbsp; //空格\n&ly;  //小于号\n&gt;  //大于号\n```\n","tags":["HTML"],"categories":["前端"]},{"title":"第一章 电路模型和电路定律","url":"/2023/09/09/第一章-电路模型和电路定律/","content":"\n## 1.1 电路和电路模型\n\n实际电路：由电工设备和电气器件按预期目的连接构成的电路的通路。\n\n功能：a 能量的传输、分配与转换\n\n​              b 信息的传递、控制与处理\n\n共性：建立在痛一电路理论的基础上。\n\n### 1.1.1 电路模型\n\n![1694263535061](../assets/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%94%B5%E8%B7%AF%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%94%B5%E8%B7%AF%E5%AE%9A%E5%BE%8B/1694263535061.png)\n\n电路模型：反应实际电路部件的主要电磁性质的**理想电路**元件以及组合\n\n理想电路元件：由某种确定的电磁性能的理想元件。\n\n电阻元件：表示消耗电能的元件![1694263845243](../assets/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%94%B5%E8%B7%AF%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%94%B5%E8%B7%AF%E5%AE%9A%E5%BE%8B/1694263845243.png)\n\n电感元件：表示产生磁场，存储磁场能量的元件\n\n电容元件：表示产生电场，存储电厂能量的元件\n\n电压源与电流源：表示将其它形式的能量转变成电能的元件\n\n**注意：**\n\n![1694263950246](../assets/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%94%B5%E8%B7%AF%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%94%B5%E8%B7%AF%E5%AE%9A%E5%BE%8B/1694263950246.png)\n\n![1694263974908](../assets/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%94%B5%E8%B7%AF%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%94%B5%E8%B7%AF%E5%AE%9A%E5%BE%8B/1694263974908.png)\n\n## 1.2电流和电压的参考方向\n\n电路中的主要物理量由电压、电流、电荷、磁链、能量、电功率等。在线性电路分析中，主要关心的物理量是**电路、电压和功率**。\n\n### 1.电流的参考方向\n\n电流：带电粒子由规则运动的定向运动\n\n电流强度：单位时间内通过导体横截面的电荷量\n\n![1694265050074](../assets/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%94%B5%E8%B7%AF%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%94%B5%E8%B7%AF%E5%AE%9A%E5%BE%8B/1694265050074.png)\n\n![1694265100359](../assets/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%94%B5%E8%B7%AF%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%94%B5%E8%B7%AF%E5%AE%9A%E5%BE%8B/1694265100359.png)\n\n![1694265136194](../assets/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%94%B5%E8%B7%AF%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%94%B5%E8%B7%AF%E5%AE%9A%E5%BE%8B/1694265136194.png)\n\n![1694265155728](../assets/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%94%B5%E8%B7%AF%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%94%B5%E8%B7%AF%E5%AE%9A%E5%BE%8B/1694265155728.png)\n\n![1694265184041](../assets/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%94%B5%E8%B7%AF%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%94%B5%E8%B7%AF%E5%AE%9A%E5%BE%8B/1694265184041.png)\n\n![1694265234540](../assets/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%94%B5%E8%B7%AF%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%94%B5%E8%B7%AF%E5%AE%9A%E5%BE%8B/1694265234540.png)\n\n![1694265255827](../assets/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%94%B5%E8%B7%AF%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%94%B5%E8%B7%AF%E5%AE%9A%E5%BE%8B/1694265255827.png)\n\n![1694265274036](../assets/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%94%B5%E8%B7%AF%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%94%B5%E8%B7%AF%E5%AE%9A%E5%BE%8B/1694265274036.png)\n\n![1694265285159](../assets/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%94%B5%E8%B7%AF%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%94%B5%E8%B7%AF%E5%AE%9A%E5%BE%8B/1694265285159.png)\n\n![1694265305717](../assets/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%94%B5%E8%B7%AF%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%94%B5%E8%B7%AF%E5%AE%9A%E5%BE%8B/1694265305717.png)\n\n![1694265329854](../assets/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%94%B5%E8%B7%AF%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%94%B5%E8%B7%AF%E5%AE%9A%E5%BE%8B/1694265329854.png)\n\n\n\n\n\n\n\n","tags":["电路和电路模型"],"categories":["电路原理、电工学"]},{"title":"第三章 寄存器点亮LED","url":"/2023/09/01/第三章-寄存器点亮LED/","content":"\n## 一、GPIO\n\nGPIO 是通用输入输出端口的简称，就是可控的引脚。\n\n**上拉是高电平，下拉是低电平**\n\n![1693727391280](../assets/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AF%84%E5%AD%98%E5%99%A8%E7%82%B9%E4%BA%AELED/1693727391280.png)\n\n### 1、P-MOS 和 N-MOS 管\n\n**推挽输出： 低电平 0v，高电平 3.3v**\n\n输出高电平，经过反向后，上方 P-MOS 管导通，下方 N-MOS 管关闭，对外输出高电平。\n\n输入低电平，经过反向后，上方 P-MOS 管关闭，下方 N-MOS 管导通，对外输出低电平。\n\n当高低电平切换时，两个管轮流导通，P 负责电流，N 负责电流。\n\n\\*\\* 推挽输出一般应用在输出电平为 0，3.3v，需要高速切换开关的状态。\n\n**开漏输出：**\n\nP-MOS 管不工作。例如，输出 0，低电平，则 P-MOS 关闭，N-MOS 管导通，使输出接地。\n\n输出为 1，P-MOS，N-MOS 都关闭，所以不输出高电平，低电平，为高阻态。\n\n\\** 开漏输出一般应用在 I2C、SMBUS 通讯，需要“线与”（ *指的是它们任意一开关只要对地导通，这根线就一定是低电平\\* ）在总线电路上\n\n### 输出：\n\n#### 输出数据寄存器\n\nMOS 管结构电路的输出信号，由 GPIO“输出数据寄存器”GPIO_ODR 提供\n\n“置位/复位寄存器 GPIOx_BSRR”可以通过修改输出数据寄存器的值从而影响电路的输出\n\n#### 复用功能输出\n\n复用 是指 STM32 其它片上外设对 GPIO 引脚进行控制，此时 GPIO 引脚用作改外设功能的一部分。\n\n**例如我们使用 USART 串口通讯时，需要用到某个 GPIO 引脚作为通讯发送引脚，这个时候就可以把该 GPIO 引脚配置成 USART 串口复用功能，由串口外设控制该引脚，发送数据。**\n\n### 输入：\n\n**输出数据寄存器**\n\n连接到施密特触发器，模拟信号转换 0/1 数字信号，最好存储在“输出数据寄存器 GPIOx_IDR”中\n\n**复用功能输出**\n\nGPIO 引脚将信号传输到 stm32 其他片上外设，由该外设读取引脚状态\n\n**如我们使用 USART 串口通讯时，需要用到某个 GPIO 引脚作为通讯接收引脚，这个时候就可以把该 GPIO 引脚配置成 USART 串口复用功能，使 USART 可以通过该通讯引脚的接收远端数据。**\n","tags":["STM32"],"categories":["野火STM32"]},{"title":"数据库常用命令","url":"/2023/08/29/数据库常用命令/","content":"\n# 修订：\n\n查看表中的字段\n\n```java\nshow columns from 商品库存;xxxxxxxxxx columnshow columns from 商品库存;\n```\n\n![1694239120400](../assets/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1694239120400.png)\n\n![1694240340953](../assets/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1694240340953.png)\n\n```\nselect 所在区域 from 商品库存 limit 5;  检索此语句使用SELECT语句检索单个列。LIMIT 5指示MySQL返回\n不多于5行。\n```\n\n![1694240532823](../assets/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1694240532823.png)\n\n**统计四张表的记录数,要求 SQL 语句禁用联合查询（Union、JOIN、多表**\n\n```sql\nSELECT\n\t(SELECT COUNT(*) FROM d_3_1) AS dcount,\n\t(SELECT COUNT(*) FROM 商品库存) AS scount\n```\n\n![1701681099499](../assets/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1701681099499.png)\n\n## 一、连接数据库\n\n```\nmysql -h 主机IP -P 端口号 -u 用户名 -p 密码\n```\n\n### 在 Ubuntu\n\n```mysql\nMySQL -u root -p\n```\n\n**连接远程主机**\n\n```mysql\nmysql -h110.110.110.110 -u root -p 123;\n```\n\n## 二、修改用户密码\n\n```mysql\nmysqladmin -u root -password ab12\n```\n\n再次修改\n\n```mysql\nmysqladmin -u root -password djg345\n```\n\n## 三、新增用户\n\n（1）增加一个用户 test1，密码为 abc\n\n```mysql\ngrant select,insert,delete on *.*to [email]=test@\"%]test1@\"[/email]\"Indentified by\"abc\";\n# grant on 命令格式：grant select on 数据库.* to 用户名@登录主机 identified by “密码”;\n```\n\n（2）新增一个 test2 密码为 abc，只能 localhost 登录\n\n```mysql\ngrant select,insert,update,delete on mydb.* to [email=test2@localhost]test2@localhsot[/email] identified by \"abc\";\n# 如果不想test有密码可以在用一次打消密码\ngrant select,insert,update,delete on mydb.* to [email=test2@localhost]test2@localhost[/email] identified by “”;=\n```\n\n## 四、创建数据库\n\n（1）create database 命名;\n\n![1693301573827](../assets/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1693301573827.png)\n\n（2）创建数据库并分配用户\n\n```mysql\n#1\ncreate database 数据库名;\n#2\ncreate select,insert,update,delete,create,drop,alter on 数据库名.* to 数据库名@loclhost identified by '密码';\n#3\nselect password por '数据名'@'localhost' =old_password('密码');\n```\n\n## 五、显示数据库\n\n**show databases 显示所有数据库**\n\n![1693311907411](../assets/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1693311907411.png)\n\n## 六、删除数据库\n\n**drop database xhkdb;**\n\n![1693311993666](../assets/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1693311993666.png)\n\n## 七、使用数据库\n\n**use xhkdb;**\n\n（1）use 语句可以通告 mysql 把数据库当作默认使用。知道下一个不同的 use 语句。\n\n![1693314402433](../assets/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1693314402433.png)\n\n（2）use 语句不会阻碍访问其他数据库中的表。ab1 数据库访问 author 表，并从 db2 数据库访问 editor 表\n\n```mysql\nuse db1;\nselect author_name,editor_name from author,ab2,editor;\nwhere author.editor_id = ab2.editor.editor_id;\n```\n\n## 八、当前连接的数据库\n\n**select database();**\n\n（1）显示 mysql 版本\n\n```mysql\nselect version();\n```\n\n![1693314931707](../assets/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1693314931707.png)\n\n（2）显示当前时间\n\n```mysql\n select now();\n```\n\n![1693314952201](../assets/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1693314952201.png)\n\n（3）显示年月日\n\n![1693315145115](../assets/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1693315145115.png)\n\n![1693315128832](../assets/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1693315128832.png)\n\n![1693315054667](../assets/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1693315054667.png)\n\n（4）显示字符串\n\n![1693315209186](../assets/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1693315209186.png)\n\n（5）当计算器\n\n![1693315238981](../assets/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1693315238981.png)\n\n（5）串接字符串\n\n![1693315322414](../assets/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1693315322414.png)\n\n**//这里用到 CONCAT()函数，用来把字符串串接起来。**\n\n## 九、创建数据库表\n\n注意：要先使用 use 数据库名；\n\n```\ncreate table 表名\n(\n\t字段名1，数据类型 [列级别约束条件][默认值]，\n\t字段名2，数据类型 [列级别约束条件][默认值],\n\t……\n\t[表级别约束条件]\n)\n```\n\n![1693315552760](../assets/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1693315552760.png)\n\n例如:创建 tb_emp1 表结构\n\n![1693317121082](../assets/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1693317121082.png)\n\n![1693317243938](../assets/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1693317243938.png)\n\n## 十、获取表结构\n\n**查看表结构可以使用 describe 和 show create table；**\n\n```mysql\ndescribe 表名;\n```\n\n或\n\n```mysql\ndesc 表名；\n```\n\nshow create table 可以查看显示创建表时的 create table 语句。\n\n```mysql\nshow create table 表名\\G;\n```\n\n![1693317695853](../assets/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1693317695853.png)\n\n## 十一、删除数据表\n\n```mysql\ndrop table if exists 表1，表2,表n\n```\n\n![1693355675932](../assets/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1693355675932.png)\n\n## 十二、向表中插入数据\n\n**insert into 插入新行**\n\n```mysql\ninsert into 表名称 values(值1，值2);\n# 也可以指定要插入数据的列\ninsert into table_name(列1，列2)values(值1，值2)\n```\n\n## 十三、查询表中数据\n\n```mysql\nSELECT\n {* | <字段列表>}\n [\n\t FROM <表 1>,<表 2>...\n\t [WHERE <表达式>\n\t [GROUP BY <group by definition>]\n\t [HAVING <expression> [{<operator><expression>}...]]\n \t[ORDER BY <order by definition>]\n \t[LIMIT [<offset>,] <row count>]\n ]\nSELECT [字段 1,字段 2,…,字段 n]\nFROM [表或视图]\nWHERE [查询条件];\n```\n\n![1696756935287](../assets/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1696756935287.png)\n\n## 十四、删除记录\n\n```mysql\ndelete from table_name[where <condition>];\n#\t\t\t\t\t\t指定删除条件\ndelete from person where id=11;\n```\n\n## 十五、修改表中的数据\n\n```mysql\nupdate table_name\nset column_nmael=value1,column_name2=value2\nwhere(condition)\n```\n\ncolumn_name1，为指定更新的字段名称。value 为相对应指定字段的更新值。condition 更新记录需要满足的条件\n\n【例】在 person 表中，更新 id 值为 11 的记录，将 age 字段值改为 15，将 name 字段值改为 LiMing，SQL 语句如下：\n\n```mysql\nupdate person set age=15,name='liming'where id=11;\n```\n\n## 十六、增加字段\n\n```mysql\nalter add 表名 add 新字段 数据类型\n\t约束条件 first|after 已存在字段名\n\t        first将新添加的字段设置为表的第一个字段\n\t        after新添加的字段指定在‘已存在字段名’的后面\n```\n\n【例】在数据表 tb_dept1 中添加一个没有完整性约束的 INT 类型的字段 managerId（部门经理编号），SQL 语句如下：\n\n```mysql\nALTER TABLE tb_dept1 ADD managerId INT(10);\n```\n\n## 十七、修改表名\n\n```mysql\nalter table 旧表名 rename to新表名\n```\n\n【例】将数据表 tb_dept3 改名为 tb_deptment3，SQL 语句如下：\n\n```mysql\nALTER TABLE tb_dept3 RENAME tb_deptment3;\n```\n\n## 十八、备份数据库\n\n```mysql\nmysqldump -u user -h host -p password dbname[tbname,[tbname]]>filename.sql\n```\n\n## 十九、还原数据库\n\n```mysql\nmysql -u user -p [dbname]<filename.sql\n```\n\n【例 1】使用 mysql 命令将 C:\\backup\\booksdb_20130301.sql 文件中的备份导入到数据库中，输入语句如下：\n\n```mysql\nmysql –u root –p booksDB < C:/backup/booksdb_20130301.sql\n```\n\n如果已经登录 MySQL 服务器，还可以使用 source 命令导入 sql 文件。source 语句语法如下：\n\n```mysql\nsource filename\n```\n\n【 例 2 】 使 用 root 用 户 登 录 到 服 务 器 ， 然 后 使 用 source 导 入 本 地 的 备 份 文 件 booksdb_20110101.sql，输入语句如下：\n\n--选择要恢复到的数据库\n\n```mysql\nmysql> use booksDB;\n\nDatabase changed\n```\n\n--使用 source 命令导入备份文件\n\n```mysql\nmysql> source C:\\backup\\booksDB_20130301.sql\n```\n\n## 二十、快速恢复数据库\n\n在 MySQL 服务器停止运行时，将备份的数据库文件复制到 MySQL 存放数据的位置（MySQL 的 data 文件夹）\n\n```mysql\nchown -R mysql.mysql /var/lib/mysql/dbname\n```\n\n【例】从 mysqlhotcopy 复制的备份恢复数据库，输入语句如下：\n\n```mysql\ncp -R /usr/backup/test usr/local/mysql/data\n```\n\n## 二十一、在 Ubuntu 下安装 mysql\n\n```mysql\nsudo apt-get update #更新软件包\nsudo apt-get install mysql-server #安装数据库服务器\n\n启动：sudo /etc/init.d/mysql start\n停止：sudo /etc/init.d/mysql stop\n重启：sudo /etc/init.d/mysql restart\n登录：mysql -u root -p<pwd>\n```\n\n## 二十二、关闭防火墙\n\n```\n- sudo apt-get install ufw 安装防火墙\n- sudo ufw enable 打开防火墙\n- sudo ufw status 查看防火墙状态\n- sudo ufw disable 关闭防火墙\n```\n\n# MySQL 在 Ubuntu 使用\n\n## 二十三、在服务器 SQLSERVER 上，利用 U 盘“U 盘资料/test.sql”还原三张数据\n\n表。\n\n![1705417667865](../assets/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1705417667865.png)\n\n## 二十四、统计三张表的记录数，查询结果要求如图。\n\n```\nSELECT 'table1' AS TableName, COUNT(*) AS RecordCount FROM table1\nUNION ALL\nSELECT 'table2' AS TableName, COUNT(*) AS RecordCount FROM table2\nUNION ALL\nSELECT 'table3' AS TableName, COUNT(*) AS RecordCount FROM table3;\n```\n\n## 二十五、删除 AD_AccountsRole 表中不属于 AD_Accounts 用户的关系数据。重新查询三张表的记录数。\n\n![1705417785368](../assets/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/1705417785368.png)\n\n## 二十六、新建查询窗口，写出查询 nleedge 数据库中所有数据表和每个表的记录\n\n```mysql\nSELECT\n  (SELECT COUNT(*) FROM d_3_1) AS 表一,\n  (SELECT COUNT(*) FROM `商品库存`) AS 表二;\n```\n","tags":["数据库"],"categories":["Mysql"]},{"title":"Mysql数据库","url":"/2023/08/29/第一章-了解数据库/","content":"\n# 一、了解 SQL\n\n## 1、什么是数据库\n\n数据库是以某种组织的方式存储的数据集合。\n\n数据库（database）保存有组织的数据的容器（一个文件或者一组文件）\n\n**更准确的来说，数据库软件称为数据库管理系统（DBMS）。通过 DBMS 创建和操作的容器**\n\n## 2、什么是表\n\n**表 是一种结构化的文件，用来存储某种特定类型的数据。**\n\n## 3、什么是模式\n\n**模式 关于数据库和表的布局以及特性的信息。**\n\n## 4、列和数据类型\n\n表是由列组成。列中存储这表中某种部分的信息。\n\n**列 表中的一个字段。所有表都是由一个或多个列组成的。**\n\n**数据类型 所容许的数据的类型。每个字段都有相应的数据类型。**\n\n## 5、行\n\n表中的数据都是按行存储的，保存的记录存储在自己的行内。\n\n**行 表中的一个记录。**\n\n## 6、主键\n\n**主键（又称键码、码） 一列（一组列），其值能够唯一区分表中的每个行。**\n\n满足条件：\n\n**任意两行都不具有相同的主键值。**\n\n**每个行都必须具有一个主键值（主键列不允许 null 值）**\n\n# 二、了解 mysql\n\n## 一、客户机-服务器软件\n\nMySQL、Oracle 以及 Microsoft SQL Server 等数据库是基于客户机—服务器的数据库\n\nDBMS（数据库管理系统）可以分为两类：\n\n（1）基于共享文件系统的 DBMS（2）基于客户机-服务器的 DBMS\n\n- **与数据文件打交道的只有服务器软件。关于数据、数据添加、删除和数据更新的所有请求都是由服务器软件完成。**\n- **客户机是与用户打交道的软件。例如：请求一个按字母顺序列出的产品表，则客户机软件通过网阔提交该请求给服务器软件。服务器软件处理这个请求，根据需求过滤、丢弃和排序数据，然后送回客户机软件。**\n\n# 三、排序索检数据\n\n## 一、子句\n\n有些字句是必需，有一些是可选的。一个子句通常由一个**关键字和所提供的数据**组成。\n","tags":["数据库"],"categories":["Mysql"]},{"title":"物联网比赛之Windows维护","url":"/2023/08/29/物联网比赛之Windows维护/","content":"\n## 模块 B：物联网故障维修与运行维护\n\n## 1、Windows 系统维护\n\n![1693279392763](../assets/%E7%89%A9%E8%81%94%E7%BD%91%E6%AF%94%E8%B5%9B%E4%B9%8BWindows%E7%BB%B4%E6%8A%A4/1693279392763.png)\n\n![1693281108935](../assets/%E7%89%A9%E8%81%94%E7%BD%91%E6%AF%94%E8%B5%9B%E4%B9%8BWindows%E7%BB%B4%E6%8A%A4/1693281108935.png)\n\n### 一、出于安全考虑，需要对服务器计算机配置规则：“禁止工作站计算机访问本机任何程序或者端口，暂不启用此规则”。\n\n![1693279825531](../assets/%E7%89%A9%E8%81%94%E7%BD%91%E6%AF%94%E8%B5%9B%E4%B9%8BWindows%E7%BB%B4%E6%8A%A4/1693279825531.png)\n\n点击**自定义**\n\n![1693279967063](../assets/%E7%89%A9%E8%81%94%E7%BD%91%E6%AF%94%E8%B5%9B%E4%B9%8BWindows%E7%BB%B4%E6%8A%A4/1693279967063.png)\n\n![1693281331676](../assets/%E7%89%A9%E8%81%94%E7%BD%91%E6%AF%94%E8%B5%9B%E4%B9%8BWindows%E7%BB%B4%E6%8A%A4/1693281331676.png)\n\n![1693281411142](../assets/%E7%89%A9%E8%81%94%E7%BD%91%E6%AF%94%E8%B5%9B%E4%B9%8BWindows%E7%BB%B4%E6%8A%A4/1693281411142.png)\n\n![1693281443360](../assets/%E7%89%A9%E8%81%94%E7%BD%91%E6%AF%94%E8%B5%9B%E4%B9%8BWindows%E7%BB%B4%E6%8A%A4/1693281443360.png)\n\n![1693281455441](../assets/%E7%89%A9%E8%81%94%E7%BD%91%E6%AF%94%E8%B5%9B%E4%B9%8BWindows%E7%BB%B4%E6%8A%A4/1693281455441.png)\n\n![1693281662496](../assets/%E7%89%A9%E8%81%94%E7%BD%91%E6%AF%94%E8%B5%9B%E4%B9%8BWindows%E7%BB%B4%E6%8A%A4/1693281662496.png)\n\n**记得露出本地地址**\n\n### 二、在工作站电脑的命令行窗口中，使用命令查看网络连接以及每一个网络接口设备状态。\n\n**netstat -an**\n\n![1693281802478](../assets/%E7%89%A9%E8%81%94%E7%BD%91%E6%AF%94%E8%B5%9B%E4%B9%8BWindows%E7%BB%B4%E6%8A%A4/1693281802478.png)\n\n## 扩展：\n\n### **（1）netstat -b 可以显示在创建网络连接和侦听端口时所涉及的可执行程序**\n\n![1693282575271](../assets/%E7%89%A9%E8%81%94%E7%BD%91%E6%AF%94%E8%B5%9B%E4%B9%8BWindows%E7%BB%B4%E6%8A%A4/1693282575271.png)\n\n### （2）netstat -a 显示所有的有效连接信息列表，包括建立的连接（ESTABLISHED），也包括监听连接请求（LISTENLING）的那些连接\n\n![1693282697970](../assets/%E7%89%A9%E8%81%94%E7%BD%91%E6%AF%94%E8%B5%9B%E4%B9%8BWindows%E7%BB%B4%E6%8A%A4/1693282697970.png)\n\n### （3）netstat -e 可以显示关于以太网的统计数据，传送字节数、数据包、错误等信息，还可以和-s 结合使用\n\n![1693282829345](../assets/%E7%89%A9%E8%81%94%E7%BD%91%E6%AF%94%E8%B5%9B%E4%B9%8BWindows%E7%BB%B4%E6%8A%A4/1693282829345.png)\n\n### （4）netstat -f 显示外部地址的完全限定域名<FQDN>\n\n![1693282908580](../assets/%E7%89%A9%E8%81%94%E7%BD%91%E6%AF%94%E8%B5%9B%E4%B9%8BWindows%E7%BB%B4%E6%8A%A4/1693282908580.png)\n\n### （5）netstat -p 可以显示 proto 指定的协议连接情况\n\n![1693282978761](../assets/%E7%89%A9%E8%81%94%E7%BD%91%E6%AF%94%E8%B5%9B%E4%B9%8BWindows%E7%BB%B4%E6%8A%A4/1693282978761.png)\n\n### （6）netstat -r 显示路由表\n\n![1693283058738](../assets/%E7%89%A9%E8%81%94%E7%BD%91%E6%AF%94%E8%B5%9B%E4%B9%8BWindows%E7%BB%B4%E6%8A%A4/1693283058738.png)\n","tags":["windows维护"],"categories":["技能大赛"]},{"title":"第二章-寄存器","url":"/2023/08/17/第二章-寄存器/","content":"\n## 一、芯片组成\n\n负责在 内核之外设计部件并生产整个芯片，这些内核之外的部件被称为核外外设或片上外设。如 GPIO、 USART（串口）、I2C、SPI 等都叫做片上外设\n\n![1692290301872](../assets/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%AF%84%E5%AD%98%E5%99%A8/1692290301872.png)\n\n芯片内核和外设之间通过各种总线连接，其中主控总线有 8 条，被控总线有 7 条\n\n## 二、**存储器映射**\n\n给存储器分配地址的过程就称为存储器映射，具体见图 。给存储器再分配一个地址就叫存储器重映射\n\n## 三、寄存器\n\n以功能为名给这个\n\n内存单元取一个别名，这个别名就是我们经常说的寄存器，这个给已经分配好地址的有特定功能的内存单元取别名的过程就叫寄存器映射\n\n**寄存器的说明**\n\n![1692290420600](../assets/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%AF%84%E5%AD%98%E5%99%A8/1692290420600.png)\n\n① 名称\n\n(GPIOx_BSRR)(x=A…I)”是该寄存器名为“GPIOx_BSRR”其中的“x”可以为 A-I，也就是说这个寄存器说明适用于 GPIOA、GPIOB 至 GPIOI，这些 GPIO 端口都有这样的一个寄存器\n\n② 偏移地址\n\n偏移地址是指本寄存器相对于这个外设的基地址的偏移。查到 GPIOA 外设的基地址为 0x4002 0000 ，就可以算出 GPIOA 的这个 GPIOA_BSRR 寄存器的地址为：0x4002 0000+0x18\n\n③ 寄存器位表\n\n为读写权限，其中 w 表示只写，r 表示只读，rw 表示可读写\n\n④ 位功能说明\n\n本寄存器中有\n\n两种寄存器位，分别为 BRy 及 BSy，其中的 y 数值可以是 0-15，这里的 0-15 表示端口的引脚号，如 BR0、BS0 用于控制 GPIOx 的第 0 个引脚，若 x 表示 GPIOA，那就是控制 GPIOA 的第 0 引脚，而 BR1、BS1 就是控制 GPIOA 第 1 个引脚。\n\n这里的“复位”是将该位设置为 0 的意思，而“置位”表示将该位设置为 1；\n\n## 四、GPIO 输出初始化顺序\n\n1、确定 GPIO 是输入、通用输出、复用功能还是模拟输入（MODER）\n\n2、如果是输出还要确定推挽输出还是开漏输出（OTYPER）\n\n3、配置输出的速度（OSPEEDR）\n\n4、输出的时候内部是上/下拉电阻要不要开启（PUPDR）\n\n5、具体输出的内容（BSSR 和数据输出 ODR）\n","tags":["STM32"],"categories":["野火STM32"]},{"title":"第一章-初识STM32","url":"/2023/08/17/第一章-初识STM32/","content":"\n## 一、芯片里面有什么\n\n1.片上外设\n\n内核之外的部件叫**核外外设或片上外设**。GPIO，USART、I2C、SPI 都叫做**片上外设**。\n\n![1692286715541](../assets/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%88%9D%E8%AF%86STM32/1692286715541.png)\n\n芯片内核和外设之间，有总线连接，主控总线有 8 条，被控总线有 7 条。\n\n2、寄存器映射\n\n给存储器分配地址的过程称为**存储器映射**。如果是给吹气球再分配一个地址叫**存储器重映射**。\n\n3、存储器区域功能划分\n\n![1692287169333](../assets/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%88%9D%E8%AF%86STM32/1692287169333.png)\n\n（1）BLock0 功能划分\n\n![1692287359301](../assets/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%88%9D%E8%AF%86STM32/1692287359301.png)\n\n（2）Block1 功能划分\n\n![1692287500692](../assets/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%88%9D%E8%AF%86STM32/1692287500692.png)\n\n（3）Block2 功能划分\n\n![1692287707507](../assets/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%88%9D%E8%AF%86STM32/1692287707507.png)\n\n## 二、寄存器\n\n以**功能为名给这个内存单位取一个别名**，这个别名就是我们经常说的**寄存器**，**分配好地址的特定功能的内存单元**取别名的过程叫做**寄存器映射**\n\n**如何理解寄存器**\n\n![1692288238634](../assets/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%88%9D%E8%AF%86STM32/1692288238634.png)\n\n1、名称 (GPIOx_BSRR)(x=A…I)\n\n该寄存器名为(GPIOx_BSRR)(x=A…I)，其中 x 可以为 A-I，适用于 GPIOA、GPIOB 到 GPIOU\n\n2、偏移地址，寄存器相对这个外设的基地址的编译\n\n寄存器的编译地址是 0x18，可以查到 GPIOA 外设的基地址是 0x4002 0000，GPIOx_BSRR 寄存器地址为，0x4002 0000+0x18\n\n3、寄存器位表\n\n0-31 的名称以及权限。最上方是位编号，中间位名称，最下方是读写权限，w 只写，r 只读，rw 可读写\n\n4、位功能说明\n\nBRy 及 BSy，其中的 y 数值可以是 0-15，这里的 0-15 表示端口的引脚号， 如 BR0、BS0 用于控制 GPIOx 的第 0 个引脚，若 x 表示 GPIOA，那就是控制 GPIOA 的第 0 引脚， 而 BR1、BS1 就是控制 GPIOA 第 1 个引脚。\n\n其中，“复位”是将该位设置为 0 的意思，而“置位”表示将该位设置为 1；如果对 BR0 写入“\n\n1”的话，那么 GPIOx 的第 0 个引脚就会输出“低电平”，但是对\n\nBR0 写入“0”的话，却不会影响 ODR0 位，所以引脚电平不会改变。要想该引脚输出“高电平”， 就需要对“BS0”位写入“1”，寄存器位 BSy 与 BRy 是相反的操作\n\n## 三、C 语言对寄存器的封装\n\n总线基地址和外设基地址都以相应的宏定义起来，总线或者外设都以他们的名字作为宏名\n\n## 四、STM32 分类\n\n![1692284102687](../assets/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%88%9D%E8%AF%86STM32/1692284102687.png)\n\n## 五、STM32 命名方法\n\n以 STM32F407ZGT6 来讲解\n\n家族：32bit 的 MCU\n\n产品类型：F 表示基础型\n\n引脚数：Z 表示 144pin，C 为 48，R 为 64，V 为 100，Z 为 144，B 为 208，N216\n\nFLASH：G 表示 1024KB,C 表示 256，E 表示 512，I 表示 2048\n\n封装：T 表示 QFP 封装最常用的封装\n\n温度：6 表示等级为 A：-40~85°\n\n![1692284365745](../assets/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%88%9D%E8%AF%86STM32/1692284365745.png)\n","tags":["STM32"],"categories":["野火STM32"]},{"title":"第五章-指针","url":"/2023/08/14/第五章-指针/","content":"\n### 一、指针的概念\n\n操作系统给每个存储单元分配了一个编号，从 0x00 00 00 00 00 ~0xff ff ff ff 称之为内存\n\n指针变量：是变量也是指针变量，这个变量用来存放一个地址编号。在 32 位系统下，有 4 个字节\n\n注：\n\n​ 1、无论声明类型的地址，都有存储单元的编号，在 32 位下都是 4 个总控二。所以 任何类型的指针变量都是 4 个字节\n\n​ 2、对应类型的指针变量，只能存放对应类型的变量地址\n\n​ 比如：整形的指针变量，就是存放整型变量的地址\n\n扩展：\n\n字符变量 char ch; ch 占一个字节，它有一个地址编号，这个地址编号就是 ch 的地址整型变量 int a； a 占四个字节，占有四个字节的存储单位，有四个地址编号\n\n![1692111175278](../assets/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%8C%87%E9%92%88/1692111175278.png)\n\n### 二、指针的定义方法\n\n1、简单指针\n\n数据类型 \\* 指针变量名\n\n```c\nint * P;\n//定义一个指针变量P\n```\n\n2、指针的运算符\n\n& 取地址 ：获取一个变量的地址\n\n\\*取值：标识作用\n\n![1692111376174](../assets/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%8C%87%E9%92%88/1692111376174.png)\n\n```c\n#include <stdio.h>\n\nint main(){\n    int a = 100;\n    int * p;//指针变量\n    p = &a;//a的地址保存在p中\n\n    printf(\"a = %d %d\\n\",a,*p);\n    ptintf(\"&a = %p %p\\n\",&a,p);\n}\n```\n\n![1692111480916](../assets/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%8C%87%E9%92%88/1692111480916.png)\n\n3、指针大小\n\n在 32 位系统下，所以类型的指针都是 4 个字节\n\n### 三、指针的分类\n\n1、字符指针\n\n​ char \\*p;//只能存放字符串类型的地址编号\n\n​ char ch;\n\n​ p = &ch;\n\n2、短整型指针\n\n​ short int \\*p;\n\n​ short int a;\n\n​ p =&a;\n\n3、整形指针\n\n​ int \\*p;\n\n​ int a;\n\n​ p =&a;\n\n4：长整型指针\n\nlong int \\*p;\n\nlong int a;\n\np =&a;\n\n5：float 型的指针\n\nfloat \\*p;\n\nfloat a;\n\np =&a;\n\n6：double 型的指针\n\n​ double \\*p;\n\n​ double a;\n\n​ p =&a;\n\n7：函数指针\n\n8、结构体指针\n\n9、指针的指针\n\n10、数组指针\n\n### 四、指针和变量的关系\n\n**指针可以存放变量地址编号**\n\n1、变量的名称引用变量\n\n​ int a;\n\n​ a=100;\n\n2、通过指针变量引来变量\n\n​ int \\*p;\n\n​ p =&a;//p 保存了 a 的地址，也可以说 p 指向了 a\n\n​ \\*p=100;\n\n注意：指针变量的定义可以初始化\n\nint a;\n\nint \\*p=&a;//指针就是存放变量地址的\n\n```c\n#include <stdio.h>\nint main(){\n    int *p1,*p2,temp,a,b;\n    p1=&a;\n    p2=&b;\n\n    printf(\"输入a b的值：\\n\");\n    scanf(\"%d %d\",p1,p2);//70 90\n    temp = *p1;//p1指向a的值给temp赋值 70\n    *p1 = *p2;//p2指向b的值给p1的变量a赋值 90\n    *p2 = temp;//temp给p2指向的变量b赋值 70\n    printf(\"a=%d b=%d\\n\",a,b);\n\tprintf(\"*p1=%d *p2=%d\\n\",*p1,*p2);\n}\n```\n\n![1692112482696](../assets/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%8C%87%E9%92%88/1692112482696.png)\n\n扩展：\n\n对应类型的指针，只能保存对应类型数据的地址\n\n如果想让不同类型的指针互相赋值，需要强制类型转换\n\n```c\n#include <stdio.h>\nint main(){\n    int a=0x1234,b=5678;\n    char *p1,*p2;\n    printf(\"%#x %#x\\n\",a,b);\n    p1=(char *)&a;\n    p2=(char *)&b;\n    printf(\"%#x %#x\\n\",*p1,*p2);\n    p1++;\n    p2++;\n    printf(\"%#x %#x\\n\",*p1,*p2);\n}\n```\n\n![1692113002001](../assets/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%8C%87%E9%92%88/1692113002001.png)\n\n![1692113028355](../assets/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%8C%87%E9%92%88/1692113028355.png)\n\n### 五、指针和数组元素之间的关系\n\n1、数组元素和指针的基本关系\n\n变量存放在内存中，有地址编号，定义的数组，是的哟个相同类型的变量的集合。每个变量都占内存空间，都有地址编号。指针变量可以存放数组元素的地址（数组首元素）\n\n```c\nint a[10];\n//int *p =&a[0];\nint *p;\np=&a[0]; //指针变量p保存了数组a中第0个元素的地址，即a[0]的地址\n```\n\n2、数组元素的引用方式\n\n（1）数组名[下标]\n\n```c\nint a[10];\na[2]=100;\n```\n\n（2）指针名加下标\n\n```\nint a[10];\nint *p;\np=a;\np[2]=100;\n```\n\n（3）指针运算加取值\n\n```c\nint a[10];\nint *p;\np = a;\n*(p+2)=100;//a[2]=100\n```\n\n```c\n#include <stdio.h>\nint main(){\n    int a[5]={0,1,2,3,4};\n    int *p;\n    p=a;\n\n    printf(\"a[2]=%d\\n\",a[2]);//2\n    printf(\"p[2]=%d\\n\",p[2]);//2\n\n    printf(\"*(p+2) = %d\\n\",*(p+2));//2\n \tprintf(\"*(a+2) = %d\\n\",*(a+2));//2\n\n \tprintf(\"p=%p\\n\",p);\n \tprintf(\"p+2=%p\\n\",p+2);\n \tprintf(\"&a[0] = %p\\n\", &a[0]);\n \tprintf(\"&a[2] = %p\\n\", &a[2]);\n}\n```\n\n![1692113975759](../assets/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%8C%87%E9%92%88/1692113975759.png)\n","tags":["嵌入式C"],"categories":["千锋C语言"]},{"title":"第四章-预处理","url":"/2023/08/14/第四章-预处理/","content":"\n### 一、C 语言编译过程\n\n预处理、编译、汇编链接\n\ngcc -E hello.c -o hello.i 1、预处理\n\ngcc -S hello.i –o hello.s 2、编译\n\ngcc -c hello.s -o hello.o 3、汇编\n\ngcc hello.o -o hello_elf 4、链接\n\n1、预编译\n\n​ 将.c 的头文件、宏展开\n\n​ 生成.i 文件\n\n2、编译\n\n​ 将预处理的.i 文件生成 .s 汇编文件\n\n3、汇编\n\n​ 将.s 汇编文件生成.o 目标文件\n\n4、链接\n\n​ .o 文件链接成目标文件\n\n### 二、include\n\n#include<> 用尖括号包括头文件，在系统指定的路径找到头文件\n\n#include\"\" 用双引号包括头文件，先在当前目录下找到头文件，找不到再系统指定的路径下找\n\n### 三、define\n\n定义 宏用 define\n\n#### 1、不带参数的宏\n\n```c\n#define PI 3.14\n//终止宏的定义 定义\n#undef PI\n```\n\n#### 2、带参宏\n\n#define S(a,b) a\\*b\n\n注意带参宏的形参 ab 没有类名\n\nS(2,4)在预处理代替成字符串的形参 2 \\* 4\n\n```c\n#include <stdio.h>\n\n#define S(a,b) ((a)*(b))\n\nint main(){\n    printf(\"%d\\n\",S(2,4));\n    //((2+8))*(4))=40\n    printf(\"%d\\n\",S(2 + 8,4));\n}\n```\n\n#### 3、带参宏和代餐函数的区\n\n​ 带参宏被**调用**多少次就会**展开多少次**，执行代码的时候没有函数调用的过程，不需要压栈弹栈。带参宏，浪费空间\n\n​ 带参函数，代码只有一份，存放在代码段，调用的时候去代码段指令，调用的时候要压栈弹栈。带参函数浪费了时间，节省了空间\n\n### 四、选择性编译\n\n1、\n\n```c\n#ifdef AAA\n\t代码段一\n#else\n\t代码段二\n#endif\n\n//如果在当前.c ifdef上边定义AAA，就编译代码段一，否则编译代码段二\n #include AAA\n\n int main(){\n        #ifdef AAA\n        printf(\"hello kitty\\n\");\n        #else\n        printf(\"hello ddd\");\n        #endif\n        return 0;\n    }\n```\n\n2、\n\n```c\n#ifndef AAA\n\t代码段一\n#else\n\t代码段二\n#endif\n //和第一种互补，用在防止头文件重复包含，用于多文件编程中.h的第一行就是#indef #endif结尾\n```\n\n3、\n\n```c\n#if 表达式\n\t代码块一\n#else\n\t代码块二\n#endif\n//如果表达式为真，编译第一段，否则第二段\n//多用于注释多行代码\n```\n","tags":["嵌入式C"],"categories":["千锋C语言"]},{"title":"电路基础","url":"/2023/08/10/电路基础/","content":"\n## 一、电流、电压、电功率和能量\n\n## 电流：\n\n![1694242554424](../assets/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/1694242554424.png)\n\n**i 电流   q 电荷量  t时间**\n\n## 电压：\n\n![1694242617918](../assets/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/1694242617918.png)\n\n**u 电压 w 功 q电荷量**\n\n## 功率：\n\n![1694242654855](../assets/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/1694242654855.png)\n\n## 小结：\n\n![1694242683878](../assets/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/1694242683878.png)\n\n## 二、电流和电压的参考方向\n\n![1694242819757](../assets/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/1694242819757.png)\n\n![1694242852600](../assets/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/1694242852600.png)\n\n![1694242876285](../assets/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/1694242876285.png)\n\n![1694242905012](../assets/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/1694242905012.png)\n\n![1694242939314](../assets/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/1694242939314.png)\n\n![1694242973674](../assets/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/1694242973674.png)\n\n![1694242986138](../assets/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/1694242986138.png)\n\n![1694243025513](../assets/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/1694243025513.png)","tags":["电路基础"],"categories":["罗教授电路"]},{"title":"第三章-函数","url":"/2023/08/10/第三章-函数/","content":"\n### 一、函数的概念\n\n函数是 c 语言的功能单位，实现一个功能可以封装一个函数来实现。\n\n定义函数的时候一切以功能为目的，根据功能去定函数的参数和返回值。\n\n### 二、函数的分类\n\n#### 1、定义角度分类\n\n1、库函数 2、自定义函数 3、系统调用\n\n#### 2、参数角度分类\n\n1、有参函数\n\n​ 函数有形参，可以是一个，也可以是多个，类型随便\n\n例如：\n\n```c\nint fun(int a.float b.double c){\n\n}\nint max(int x,int y){\n\n}\n```\n\n2、无参函数\n\n函数没有参数，在形参列表的位置写 void 或者不写\n\n```c\nint fun(void){\n\n}\nint fun(){\n\n}\n```\n\n3、返回值角度分类\n\n（1）带返回值的函数\n\n在定义函数的时候，必须带有返回值类型，在函数题，必须有 return，没有返回值类型，默认返回值整形\n\n例如：\n\n```c\nchar fun() //定义一个返回字符数据的函数\n{\n\tchar b = 'a';\n\treturn b;\n}\n```\n\n```c\nfun(){\n\treturn 1;\n}\n```\n\n（2）没有返回值的函数\n\n在定义函数的时候，函数名字前面加个 void\n\n```c\nvoid fun(形参表){\n\t;\n\t;\n\treturn ;\n\t;\n}\n```\n\n在函数中不需要 return，如果想结束函数，返回到被调用的地方，return ;什么都不返回\n\n```c\n#include <stido.h>\nint main(int x,int y){\n    int z;\n    if(x>y)\n        z=x;\n    else\n        z=y;\n    return z;\n}\nvoid help(void){\n    printf(\"*********************\\n\");\n    printf(\"********帮助信息*****\\n\");\n    printf(\"*********************\\n\");\n}\nint main(){\n    int num;\n    help();\n    num = max(10,10+5);\n    printf(\"num=%d\\n\",num);\n    return 0;\n}\n```\n\n### 三、函数的定义\n\n1、定义方法\n\n返回值类型 函数名字（形参列表）{\n\n​ //函数体，函数的功能写在函数体实现\n\n}\n\n```c\n//定义一个没有参数也没有返回值的函数\nvoid myfun1(){\n    printf(\"hello world\\n\");\n}\nreturn ;\n//定义一个有参数的函数\nvoid myfun2(){\n    int sum;\n    sum = a + b;\n    printf(\"%d + %d = %d\\n\", a , b , sum);\n}\n//定义一个有返回值的函数\nint myfun3(int a,int b){\n    int sum;\n    sum = a + b;\n    return sum;\n}\n```\n\n### 四、函数的声明\n\n1、概念\n\n对已经定义的函数，进行声明，可以多次\n\n2、为什么声明\n\n编译器在编译 c 时，上到下编译\n\n3、声明方法\n\n（1）主调函数和被调函数在同一个.c 中\n\n```c\nvoid fun(void){\n\tprintf(\"hello world\\n\");\n}\nint main(){\n\tfun();\n}\n//不需要声明\n```\n\n（2）被调函数在下，主函数在上\n\n```c\nint main(){\n    fun();\n}\n\nvoid fun(void){\n    printf(\"hello world\\n\");\n}\n//需要声明\n//1.直接声明\n#include <stdio.h>\nvoid myfun1();\nvoid myfun2(int a,int b);\nint myfun3(int a,int b);\nint main(){\n    myfun1();\n    return 0;\n}\nvoid myfun1(){\n    printf(\"hello world\\n\");\n    return ;\n}\nvoid myfun2(int a,int b){\n    int sum;\n    sum = a + b;\n    printf(\"%d + %d = %d\\n\",a,b,sum);\n}\nint myfun3(int a,int b){\n    int sum;\n    sum = a + b;\n    return sum;\n}\n\n//2.间接声明\n//a.c文件\n#include \"a.h\"\nint main(){\n    fun();\n}\nvoid fun(void){\n    printf(\"hellow world\");\n}\n//a.h文件\nextern void fun(void);\n```\n\n（2）主调函数和被调函数不在同一个.c 文件\n\n1.直接声明 2.间接声明\n\n```c\n//myfun.c\n#include \"myfun.h\"\n\nvoid myfun1(){\n\tprintf(\"hellow world\\n\");\n\treturn;\n}\n\n//myfun.h\n#ifndef MYFUN_H\n#define MYFUN_H\n\nvoid myfun1();\n\n#endif\n\n\n//main.c\n#include <stdio.h>\n#include \"myfun.h\"\n\nint main(){\n    muyfun1();\n    return 0;\n}\n```\n\n### 五、函数调用\n\n变量 = 函数名（实参列表）；带返回值\n\n函数名（实参列表）；不带返回值\n\n```c\n#include <stdio.h>\n\nvoid myfun1();\nvoid myfun2(int a,int b);\nint myfun(int a,int b);\n\nint main(){\n    //没有参数也没有返回值\n    myfun1();\n    printf(\"*******************\\n\");\n\n    //有参数，没有返回值，需要在函数名传入实参\n    myfun2(100,90);\n    int x = 10, y=10;\n\n    //x、y:实参，实际参数，本质就是在被调函数的时候将参数的值传递给形参\n    myfun2(x,y);\n    printf(\"*******************\\n\");\n\n    //有参数也有返回值，可以一个变量接收函数执行结果（返回值），或者直接输出\n    int n;\n    n = myfun3(100,90);\n\n    printf(\"n = %d\\n\",n);\n    printf(\"sum=&d\\n\",myfun3(90,66));\n    return 0;\n}\n\nvoid myfun1(){\n    printf(\"hello world\\n\");\n    return ;\n}\n\n//a、b形参，存在实参的值\nvoid myfun2(int a,int b){\n    int sum;\n    sum = a + b;\n\n    printf(\"%d + %d = %d\\n\",a,b,sum);\n}\nint myfun3(int a,int b){\n    int sum;\n    sum = a + b;\n    return sum;\n}\n```\n\n![1691654665160](../assets/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%87%BD%E6%95%B0/1691654665160.png)\n\n### 六、变量的存储类别\n\n#### 1、内存的分区\n\n物理内存：存储在存储设备\n\n虚拟内存：操作系统虚拟出来的内存\n\n操作系统会在物理内存和虚拟内存之间叫映射\n\n#### 2、运行程序的时候，操作系统会将虚拟内存进行分区\n\n（1）堆\n\n在动态申请内存的时候，在堆里开辟内存\n\n（2）栈\n\n存放局部变量\n\n（3）静态全局区\n\n1：未初始化的静态全局区\n\n​ 静态变量（就是在前面添加 statiic），或者全局变量，没有初始化，存储在这里\n\n2：初始化的静态全局区\n\n​ 全局变量，静态变量，赋值初始值的，存储在这里\n\n4、代码区\n\n​ 存储在程序代码\n\n5、文字常量区\n\n​ 存放常量的\n\n#### 3、普通全局变量\n\n在函数外部定义的变量\n\n```c\nint num =100;//全局变量,需要声明 extern int num;\nint main(){\nreturn 0;\n}\n//生命周期：程序运行，整个过程，一直存在，知道程序结束\n```\n\n```c\n#include <stdio.h>\n\n//定义一个普通全局变量，在main函数外的变量就是全局变量\n//没有赋值，系统将赋值初始化0\nint num;\n\nvoid myfun(){\n    num= 888;\n}\nint main()\n{\n    printf(\"num=%d\\n\",num);\n\n    myfun();\n\n    printf(\"num=%d\\n\",num);\n    return 0;\n}\n```\n\n![1691658185939](../assets/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%87%BD%E6%95%B0/1691658185939.png)\n\n#### 4、静态全局变量\n\n定义全局变量的时候，用 static\n\n作用范围：限定了静态全局变量的作业范围\n\n生命周期：在程序整个运行中，都一直存在\n\n```c\n#include <stdio.h>\n\n //定义一个静态全局变量\n //静态全局变量只能在其定义的.c文件中任意位置使用，不能跨文件使用\n static int num;\n\n void myfun()\n {\n num++;\n }\n\n int main(int argc, char *argv[])\n {\n printf(\"num = %d\\n\", num);\n\n myfun();\n\n printf(\"num = %d\\n\", num);\n\n return 0;\n}\n```\n\n![1691658406783](../assets/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%87%BD%E6%95%B0/1691658406783.png)\n\n#### 5、局部变量\n\n在函数内部定义，或者复合语句定义的变量\n\n```c\nint main(){\n    int num;//局部\n    {\n        int a;//局部\n    }\n}\n```\n\n作用范围：\n\n在函数中定义的变量，在函数中有效\n\n在复合语句中定义的，在复合语句中有效。\n\n生命周期：\n\n在函数调用之前，局部变量不占用空间，调用函数的时候，\n\n才为局部变量开辟空间，函数结束了，局部变量就释放了。\n\n```c\n#include <stdio.h>\n\n //定义一个局部变量\n //在函数内部定义的，不加任何修饰的变量都是局部变量\n void myfun()\n {\n int num = 100;\n num++;\n\n printf(\"num = %d\\n\", num);\n\n return ;\n }\n\n int main(int argc, char *argv[])\n {\n //局部变量只能在定义的函数内部使用，声明周期相对较短，函数结束，局部变量就会释\n放\n//printf(\"num = %d\\n\", num);\n myfun();\n myfun();\n myfun();\n\n return 0;\n}\n```\n\n![1691658579818](../assets/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%87%BD%E6%95%B0/1691658579818.png)\n\n#### 6、静态的局部变量\n\n定义局部变量的时候，前面加 static 修饰\n\n作用范围：\n\n在它定义的函数或复合语句中有效。\n\n生命周期：\n\n第一次调用函数的时候，开辟空间赋值，函数结束后，不释放， 以后再调用函数的时候，就不再为其开辟空间，也不赋初值， 用的是以前的那个变量。\n\n```c\n#include <stdio.h>\n\n//定义一个静态局部变量\n//在函数内部定义的使用static修饰的变量就是静态局部变量\n\nvoid myfun()\n{\n//如果普通局部变量不进行初始化，则默认是随机值\n//如果静态局部变量不进行初始化，则默认是0\n int a; //普通局部变量\n static int num; //静态局部变量\n\n printf(\"a = %d\\n\", a);\n printf(\"num = %d\\n\", num);\n }\n\n void myfun1()\n {\n //静态局部变量不会随着当前函数执行结束而释放空间，下次使用的函数之前的空间\n //静态局部变量只会初始化一次\n static int num1 = 100;\n num1++;\n\n printf(\"num1 = %d\\n\", num1);\n }\n\n int main(int argc, char *argv[])\n {\n     myfun();\n\n     myfun1();\n     myfun1();\n     myfun1();\n\n return 0;\n }\n```\n\n![1691658688779](../assets/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%87%BD%E6%95%B0/1691658688779.png)\n\n1：定义普通局部变量，如果不赋初值，它的值是随机的。\n\n定义静态局部变量，如果不赋初值，它的值是 0\n\n2：普通全局变量，和静态全局变量如果不赋初值，它的值为 0\n\n#### 7、外部函数\n\n咱们定义的普通函数，都是外部函数。 即函数可以在程序的任何一个文件中调用。\n\n在分文件编程中，只需要将函数的实现过程写在指定的.c 文件中，然后将其声明写在指定\n\n的.h 文件中，其他文件只要包含了头文件，就可以使用外部函数\n\n#### 8、内部函数\n\n内部函数也称之为静态函数，就是用 static 修饰的函数\n\n在定义函数的时候，返回值类型前面加 static 修饰。这样的函数被称为内部函数。\n\nstatic 限定了函数的作用范围，在定义的.c 中有效。\n\n外部函数，在所有地方都可以调用，\n\n内部函数，只能在所定义的.c 中的函数调用\n\n扩展：\n\n在同一作用范围内，不允许变量重名。\n\n作用范围不同的可以重名。\n\n局部范围内，重名的全局变量不起作用。（就近原则）\n\n```c\nint num = 100; //全局变量\n int main()\n {\n //如果出现可以重名的情况，使用的时候满足向上就近原则\n int num = 999; //局部变量\n\n return 0;\n }\n```\n","tags":["嵌入式C"],"categories":["千锋C语言"]},{"title":"第二章 数组","url":"/2023/08/06/第二章-数组/","content":"\n### 一、数组的概念\n\n数组是若干个相同类型的变量在内存中有序存储的集合。\n\n概念理解：\n\n数组用于存储一组数据\n\n数组里面存储的数据类型必须是相同的\n\n数组在内存中会开辟一块连续的空间\n\nint a[10];//定义了一个整型的数组 a，a 是数组的名字，数组中有 10 个元素，每个元素的类型都是 int 类型，而且在内存中连续存储。\n\n这十个元素分别是 a[0] a[1] …. a[9]\n\na[0]~a[9]在内存中连续的顺序存储\n\n### 二、数组的分类\n\n**1）字符数组**\n\n即若干个字符变量的集合，数组中的每个元素都是字符型的变量\n\nchar s[10]; s[0],s[1]....s[9];\n\n**2）短整型的数组**\n\nshort int a[10]; a[0] ,a[9]; a[0]=4;a[9]=8;\n\n**3）整型的数组**\n\nint a[10]; a[0] a[9]; a[0]=3;a[0]=6;\n\n**4) 长整型的数组**\n\nlont int a[5];\n\n**5）浮点型的数组（单、双）**\n\nfloat a[6]; a[4]=3.14f;\n\ndouble a[8]; a[7]=3.115926;\n\n**6）指针数组**\n\nchar \\*a[10]\n\nint \\*a[10];\n\n**7）结构体数组**\n\nstruct stu boy[10];\n\n**2.2 按维数分类**\n\n**一维数组**\n\nint a[30];\n\n类似于一排平房\n\n**二维数组**\n\nint a[2] [30] ;\n\n可以看成一栋楼房 有多层，每层有多个房间，也类似于数学中的矩阵\n\n二维数组可以看成由多个一维数组构成的。\n\n有行，有列，\n\n**多维数组**\n\nint a[4] [2] [10];\n\n三维数组是由多个相同的二维数组构成的\n\nint a[5] [4] [ 2] [10];\n\n**三、数组的定义**\n\n**3.1 一维数组的定义**\n\n格式：\n\n数据类型 数组名[数组元素个数];\n\n例如：\n\nint a[10]; //定义了一个名为 a 的数组，数组中每一个元素都是 int 类型，一共有 10 个元素\n\n//每一个元素都保存在一个变量中，每一个变量都是有数组名和数组下标组成的\n\n//并且是从 0 开始的，分别是 a[0] a[1] a[2]... a[9]\n\n注意：数组元素的个数在定义的时候也可以不写，但是如果不写，必须初始化（定义的时候赋值）\n\n```c\n#include <stdio.h>\n\nint main(int argc, char *argv[])\n{\n//定义一个一维数组\nint a[10];\n//通过sizeof关键字可以获取数组的大小\nprintf(\"sizeof(a) = %d %d\\n\", sizeof(a), 10 * sizeof(int));\n\n //如果定义数组的同时赋值（初始化），可以不指定数组元素的个数，系统会根据初始化\n元素的个数自动指定数组元素的个数\n int b[] = {10, 20, 30};\n printf(\"sizeof(b) = %d\\n\", sizeof(b));\n\n return 0;\n }\n```\n\n### **3.2 二维数组的定义**\n\n格式:\n\n数据类型 数组名[行的个数][列的个数];\n\n例如：\n\nint a[2][4];\n\n解释：\n\n定义一个名为 a 的二维数组，每一个元素都是 int 类型\n\n这个二维数组中包含两行四列的元素，一共有 8 个元素\n\n二维数组也是连续开辟空间，访问元素是行和列都是从 0 开始，分别是 a[0] [0] a[0] [1] a[0] [2] a[0] [3] a[1] [0] a[1] [1] a[1] [2] a[1] [3]\n\n注意：二维数组的下标也是可以省略的，但是有条件，在初始化时行数可以省略，但是列数不能省略\n\n```c\n//定义一个二维数组\n int c[2][4];\n printf(\"sizeof(c) = %d %d\\n\", sizeof(c), 2 * 4 * sizeof(int));\n\n //二维数组的行数可以省略，但是列数不能省略，在初始化时可以这样操作\n //系统会根据列数自动指定行数，最终得到的函数所得到得元素个数移动是列的整数倍\n int d[][4] = {1, 2, 3, 4, 5};\n printf(\"sizeof(d) = %d\\n\", sizeof(d));\n```\n\n### **四、定义并初始化**\n\n**4.1 一维数组的初始化**\n\n```c\n#include <stdio.h>\n\n int main(int argc, char *argv[])\n {\n //以一维数组的初始化\n //如果不初始化，直接使用会是随机值\n //int a[4];\n\n//初始化方式1：全部初始化\n //int a[4] = {123, 78, 666, 476};\n //如果是全部 初始化，可以不指定数组元素的个数，系统会自动分配\n //int a[] = {10, 20, 30, 40};\n\n //初始化方式2：局部初始化\n //未初始化的位置的元素自动赋值为0\n int a[4] = {10, 20};\n\n printf(\"%d\\n\", a[0]);\n printf(\"%d\\n\", a[1]);\n printf(\"%d\\n\", a[2]);\n printf(\"%d\\n\", a[3]);\n\n return 0;\n }\n```\n\n**4.2 二维数组的初始化**\n\n**按行初始化：**\n\na、全部初始化\n\n```c\nint a[2][2]={{1,2},{4,5}};\n\na[0][0] =1; a[0][1] = 2;\na[1][0] =4, a[1][1]=5;\n```\n\nb、部分初始化\n\n```c\nint a[3][3]={{1,2},{1}};\n\na[0][0] = 1;a[0][2] =0;\n```\n\n**逐个初始化：**\n\n全部初始化：\n\n```c\nint a [2][3]={2,5,4,2,3,4};\n```\n\n部分初始化：\n\n```c\nint a[2][3]={3,5,6,8};\n```\n\n```c\n#include <stdio.h>\n\nint main(int argc, char *argv[])\n{\n//二维数组的初始化\n//int a[2][3];\n\n//初始化方式1：按行初始化\n//全部初始化\n //int a[2][3] = {{10, 20, 30}, {666, 777, 888}};\n //局部初始化\n //没有赋值的位置的元素自动为0\n //int a[2][3] = {{10, 20}, {666}};\n\n //初始化方式2：逐个初始化\n //全部初始化\n //int a[2][3] = {1, 2, 3, 4, 5, 6};\n //局部初始化\n //没有赋值的位置的元素自动为0\n int a[2][3] = {1, 2, 3};\n\n printf(\"%d\\n\", a[0][0]);\n printf(\"%d\\n\", a[0][1]);\n printf(\"%d\\n\", a[0][2]);\n printf(\"%d\\n\", a[1][0]);\n printf(\"%d\\n\", a[1][1]);\n printf(\"%d\\n\", a[1][2]);\n\n return 0;\n }\n```\n\n### **五、数组元素的引用方法**\n\n一维数组元素的引用方法\n\n数组名[下标]；\n\n//下标代表数组元素在数组中的位置，注意从 0 开始\n\nint a[10];a[2];\n\n二维数组元素的引用方法\n\n数组名[行下标] [列下标];\n\nint a[3] [4];\n\na[1] [2]\n\n```c\n#include <iostream>\n\nusing namespace std;\n\nint main(int argc, char *argv[])\n{\n//一维数组的引用以及一维数组的遍历\nint a[6] = {111, 222, 333, 444, 555, 666};\n\n a[3] = 10000;\n\n //一维数组的遍历\n int i;\n for(i = 0; i < sizeof(a) / sizeof(int); i++)\n {\n printf(\"a[%d] = %d\\n\", i, a[i]);\n }\n\n printf(\"**********************\\n\");\n\n //二维数组的引用以及二维数组的遍历\n int b[3][4] = {1, 2, 3, 4,\n 5, 6, 7, 8,\n 9, 10, 11, 12};\n\n b[2][0] = 666;\n\n //二维数组的遍历\n int m, n;\n //外层循环控制行数\n for(m = 0; m < 3; m++)\n {\n //内层循环控制列数\n for(n = 0; n < 4; n++)\n {\n printf(\"%‐4d\", b[m][n]);\n }\n printf(\"\\n\");\n }\n\n return 0;\n }\n```\n\n### **六、字符数组的定义和初始化问题**\n\n```c\nchar c1[] ={‘c’,’ ’,’p’,’r’,’o’,’g’};\n\nchar c2[] = “c prog”;\n\nchar a[][5] = {\n\n{‘B’,’A’,’S’,’I’,’C’},\n\n{‘d’,’B’,’A’,’S’,’E’}\n\n};\nchar a[][6] = {“hello”,“world”}\n```\n\n**字符数组的引用**\n\n1.用字符串方式赋值比用字符逐个赋值要多占 1\n\n个字节,用于存放字符串结束标志‘\n\n\\0’;\n\n2.上面的数组 c2 在内存中的实际存放情况为：\n\n![1691335523766](../assets/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E7%BB%84/1691335523766.png)\n\n3.由于采用了'\\0'标志，字符数组的输入输出将变得简单方便\n\n```c\n#include <stdio.h>\n\nint main(int argc, char *argv[])\n{\n//定义一个字符数组，通过scanf函数输入字符串并输出结果\n//通过赋值\"\"这样的方式可以清除字符数组中的垃圾字符，让每一个元素都是\\0\nchar ch[32] = \"\";\n\n//数组名就是当前数组的首地址，所以scanf的第二个参数直接传数组名即可\n scanf(\"%s\", ch);\n\n printf(\"ch = %s\\n\", ch);\n\n return 0;\n }\n```\n","tags":["嵌入式C"],"categories":["千锋C语言"]},{"title":"第一章 C数据类型及语句02","url":"/2023/08/06/第一章-C数据类型及语句02/","content":"\n### 1.2 数据类型\n\n**1.2.1 基本类型**\n\nchar 、short int 、int、long int、float、double\n\n**1.2.2 构造类型**\n\n由若干个相同或不同类型数据构成的集合，这种数据类型被称为构造类型\n\n```c\nint a[10];\n```\n\n**格式化输出字符：**\n\n%d 十进制有符号整数\n\n%ld 十进制 long 有符号整数\n\n%u 十进制无符号整数\n\n%o 以八进制表示的整数\n\n%x 以十六进制表示的整数\n\n%f float 型浮点数\n\n%lf double 型浮点数\n\n%e 指数形式的浮点数\n\n%c 单个字符\n\n%s 字符串\n\n%p 指针的值\n\n**特殊应用：**\n\n%3d 要求宽度为 3 位，如果不足 3 位，前面空格补齐;如果足够 3 位，此语句无效\n\n%03d 要求宽度为 3 位，如果不足 3 位，前面 0 补齐;如果足够 3 位，此语句无效\n\n%-3d 要求宽度为 3 位，如果不足 3 位，后面空格补齐;如果足够 3 位，此语句无效\n\n%.2f 小数点后只保留 2 位\n\n**1.2.3 类型转换**\n\n**自动转换:**\n\n遵循一定的规则,由编译系统自动完成.\n\n**强制类型转换：**\n\n把表达式的运算结果强制转换成所需的数据类型\n\n**自动转换的原则：**\n\n1、 占用内存字节数少(值域小)的类型，向占用内存字节数多(值域大)的类型转换,以保证精度不降低.\n\n2、 转换方向:\n\n![1691332523358](../assets/%E7%AC%AC%E4%B8%80%E7%AB%A0-C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E8%AF%AD%E5%8F%A502/1691332523358.png)\n\n**1.2.4** **指针**\n\n### **1.3** **运算符**\n\n**1.3.1** **运算符**\n\n用运算符将运算对象(也称操作数）连接起来的、符合Ｃ语法规则的式子，称为Ｃ表达式运算对象包括常量、变量、函数等\n\n**1.3.2** **运算符的分类：**\n\n1、双目运算符：即参加运算的操作数有两个\n\n例： +\n\n​ a+b\n\n2、单目运算符：参加运算的操作数只有一个\n\n​ ++自增运算符 给变量值+1\n\n​ --自减运算符\n\n​ int a=10;\n\n​ a++;\n\n3、三目运算符:即参加运算的操作数有 3 个\n\n()?():()\n\n**1.3.3** **算数运算符**\n\n\\+ - _ / % += -= _= /= %=\n\n**1.3.4** **关系运算符**\n\n（＞、＜、= =、>=、<=、!= ）\n\n**1.3.5** **逻辑运算符**\n\n**1、&& 逻辑与**\n\n两个条件都为真，则结果为真\n\nif((a>b) && (a<c))\n\n**2、|| 逻辑或**\n\n两个条件至少有一个为真，则结果为真\n\nif((a>b) || (a<c))\n\n**3、! 逻辑非**\n\nif(!(a>b))\n\n{\n\n}\n\n**1.3.6** **位运算符**\n\n**1、&按位与**\n\n任何值与 0 得 0，与 1 保持不变\n\n使某位清 0\n\n0101 1011 &\n\n1011 0100\n\n0001 0000\n\n**2、| 按位或**\n\n任何值或 1 得 1，或 0 保持不变\n\n0101 0011 |\n\n1011 0100\n\n1111 0111\n\n**3、~ 按位取反**\n\n1 变 0，0 变 1\n\n0101 1101 ~\n\n1010 0010\n\n**4、^ 按位异或**\n\n相异得 1，相同得 0\n\n1001 1100 ^\n\n0101 1010\n\n1100 0110\n\n**5、位移**\n\n\\>>右移\n\n<< 左移\n\n注意右移分：逻辑右移、算数右移\n\n（1）右移\n\n​ 逻辑右移 高位补 0 低位溢出\n\n​ 算数右移 高位补符号位，低位溢出\n\n（2）、左移\\***\\*<<** **高位溢出，低位补** **0**\n\n​ 5<<1\n\n**1.3.7** **条件运算符号**\n\n()?():()\nA?B:C;\n如果？前边的表达式成立，整个表达式的值，是？和：之//间的表达式的结果否则是：之后的表达式的结果\n\n**1.3.8** **逗号运算符**\n\n(... , ... , ...)\n\n例如：A = (B , C , D)\n\n**1.3.9** **自增自减运算符**\n\n++ ++i 先加 ，后用\n\n\\--\n\ni++ i--\n\n**1.3.10** **运算符优先级表**\n\n![1691333205109](../assets/%E7%AC%AC%E4%B8%80%E7%AB%A0-C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E8%AF%AD%E5%8F%A502/1691333205109.png)\n\n**1.4** **控制语句相关关键字**\n\n**1、 if 语句**\n\n形式：\n\n1. if(条件表达式)\n\n{ //复合语句，若干条语句的集合\n\n语句 1;\n\n语句 2；\n\n}\n\n如果条件成立执行大括号里的所有语句，不成立的话大括号里的语句不执行\n\n```c\n#include <stdio.h>\nint main()\n{\n\tint a=10;\n\tif(a>5)\n\t{\n\t\tprintf(\"a>5\\n\");\n\t}\n\treturn 0;\n}\n```\n\n2. if(条件表达式)\n\n{\n\n语句块 1\n\n}\n\nelse\n\n{\n\n语句块 2\n\n}\n\nif else 语句的作用是，如果 if 的条件成立，执行 if 后面{}内的语句，否则执行 else 后的语句\n\n```c\n#include <stdio.h>\nint main()\n{\n\tint a=10;\n\tif(a>5)\n\t{\n\t\tprintf(\"a>5\\n\");\n\t}\n\telse\n\t{\n\t\tprintf(\"a<=5\\n\");\n\t}\n\treturn 0;\n\t}\n```\n\n3. if(条件表达式)\n\n{\n\n}\n\nelse if(条件表达式)\n\n{\n\n}\n\nelse if(条件表达式)\n\n{\n\n}\n\nelse\n\n{\n\n}\n\n在判断的时候，从上往下判断，一旦有成立的表达式，执行对应的复合语句， 下边的就不再判断了，各个条件判断是互斥的\n\n```c\n#include <stdio.h>\nint main(void)\n{\n\tchar ch;\n\tfloat score = 0;\n\tprintf(\"请输入学生分数:\\n\");\n\tscanf(\"%f\",&score);\n\tif(score<0 || score >100)\n\t{\n\t\tprintf(\"你所输入的信息有错\\n\");\n\t\treturn 0;\n\t}\n\telse if( score<60)\n\t{\n\t\tch = 'E';\n\t}\n\telse if ( score < 70 )\n\t{\n\t\tch = 'D';\n\t}\n\telse if ( score < 80 )\n\t{\n\t\tch = 'C';\n\t}\n\telse if ( score < 90 )\n\t{\n\t\tch = 'B';\n\t}\n\telse\n\t{\n\t\tch = 'A';\n\t}\n\tprintf(\"成绩评定为：%c\\n\",ch);\n\treturn 0;\n\t}\n```\n\n2、 switch 语句\n\nswitch（表达式）//表达式只能是字符型或整型的(short int int long int)\n\n{\n\ncase 常量表达式 1：\n\n语句 1；\n\nbreak；\n\ncase 常量表达式 2：\n\n语句 2;\n\nbreak；\n\ndefault：\n\n语句 3；\n\nbreak;\n\n}\n\n```c\n#include <stdio.h>\nint main(int argc, char *argv[])\n{\n\tint n;\n\tprintf(\"请输入一个 1~7 的数\\n\");\n\tscanf(\"%d\",&n);\n\tswitch(n)\n\t{\n\t\tcase 1:\n\t\t\tprintf(\"星期一\\n\");\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tprintf(\"星期二\\n\");\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tprintf(\"星期三\\n\");\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tprintf(\"星期四\\n\");\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tprintf(\"星期五\\n\");\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tprintf(\"星期六\\n\");\n\t\t\tbreak;\n\t\tcase 7:\n\t\t\tprintf(\"星期天\\n\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"您的输入有误，请输入 1~7 的数\\n\");\n\t\t\tbreak;\n\t}\n\t\treturn 0\n```\n\n**1.4.2** **循环控制语句相关的关键字**\n\n**1、 for 循环**\n\nfor(表达式 1;表达式 2;表达式 3)\n\n{//复合语句，循环体\n\n}\n\n第一次进入循环的时候执行表达式 1，表达式 1 只干一次，\n\n表达式 2，是循环的条件，只有表达式 2 为真了，才执行循环体，也就是说\n\n每次进入循环体之前要判断表达式 2 是否为真。\n\n每次执行完循环体后，首先执行表达式 3\n\n```c\n#include <stdio.h>\nint main(void)\n{\n\tint i;\n\tint sum=0;\n\tfor(i=1;i<=100;i++)\n\t{\n\t\tsum = sum+i;\n\t}\n\t\tprintf(\"sum=%d\\n\",sum);\n\t\treturn 0;\n\t}\n//例 26：\n#include <stdio.h>\nint main(int argc, char *argv[])\n{\n\tint i,j;\n\tfor(i=1;i<=9;i++)\n\t{\n\tfor(j=1;j<=i;j++)\n\t{\n\t\tprintf(\"%d*%d=%d \",i,j,i*j);\n\t}\n\t\tprintf(\"\\n\");\n\t}\n\t\treturn 0;\n\t}\n```\n\n**2、 while 循环**\n\n1. 形式 1：\n\nwhile(条件表达式)\n\n{//循环体，复合语句\n\n}\n\n进入 while 循环的时候，首先会判断条件表达式是否为真，为真进入循环体，否则退出循环\n\n```c\n#include <stdio.h>\nint main(void)\n{\n/* 2) 形式 1：\nwhile(条件表达式)\n{//循环体，复合语句\n}\n*/\n\tint i=1;\n\tint sum=0;\n\twhile(i<=100)\n\t{\n\t\tsum = sum+i;\n\t\ti++;\n\t}\n\t\tprintf(\"sum=%d\\n\",sum);\n\treturn 0;\n}\n```\n\n3. 形式 2 ： do\n\ndo{//循环体\n\n}while(条件表达式);\n\n先执行循环体里的代码，然后去判断条件表达式是否为真，为真再次执行循环体，否则退出循环\n\n```c\n#include <stdio.h>\nint main(void)\n{\n\tint i=1;\n\tint sum=0;\n\tdo\n\t{\n\t\tsum = sum+i;\n\t\ti++;\n\t}while(i<=100);\n\t\tprintf(\"sum=%d\\n\",sum);\n\treturn 0;\n}\n```\n\n形式 1 和形式 2 的区别是，形式 1 先判断在执行循环体，形式 2 先执行循环体，再判断\n\nbreak 跳出循环\n\ncontinue 结束本次循环，进入下一次循环\n\n```c\n#include <stdio.h>\nint main(void)\n\t{\n\t\tint i;\n\t\tint sum=0;\n\tfor(i=1;i<=100;i++)\n\t{\n\t\tif(i==10)\n\t\tbreak;//将 break 修改成 continue 看效果\n\t\tsum = sum+i;\n\t}\n\t\tprintf(\"sum=%d\\n\",sum);\n\t\treturn 0;\n\t}\n\treturn 0;\n//返回函数的意思。结束 return 所在的函数，\n//在普通函数中，返回到被调用处，在 main 函数中的话，结束程序\n```\n\n**3、 goto**\n\n```c\n#include <stdio.h>\nint main(int argc, char *argv[])\n{\n\tprintf(\"test000000000000000000\\n\");\n\tprintf(\"test1111111111111111\\n\");\n\tgoto xiutao;\n\tprintf(\"test222222222222222222\\n\");\n\tprintf(\"test3333333333333333\\n\");\n\tprintf(\"test444444444444444444444\\n\");\n\tprintf(\"test55555555555555555555\\n\");\n\txiutao:\n\tprintf(\"test66666666666666666\\n\");\n\treturn 0;\n}\n```\n","tags":["嵌入式C"],"categories":["千锋C语言"]},{"title":"第一章 C数据类型及语句01","url":"/2023/08/06/第一章-C数据类型及语句01/","content":"\n### 1.1 C 语言的特点\n\n1.#include<stdio.h> 头文件包含，一定要有\n\n2.每一个 c 语言的程序有且只有一个 main 函数，这是整个程序的开始位置\n\n3.C 语言中()、[]、{}、“”、’’、都必须成对出现,必须是英文符号\n\n4.C 语言中语句要以分号结束。\n\n5.//为注释 /\\* \\*/为多行注释\n\n### 1.2 关键字\n\n1、char 字符型\n\n```c\nchar ch1 = 'zifu';\n```\n\n2、short 短整型 占 2 个字节\n\n```c\nshort int a = 11; -32768 - ---32767\n```\n\n3、int 整形，在 32 位占 4 个字节，16 位站 2 个\n\n```c\nint a = 44; -20 亿---20 亿\n```\n\n4、long 长整型 在 32 位占 4 个字节\n\n```c\nlong int a = 66;\n```\n\n5、float 单精度浮点型（实数），占 4 个字节\n\n```c\nfloat b = 3.8f;\n```\n\n6、 double 双精度浮点型 （实数），占 8 个字节\n\n```c\ndouble b=3.8;\n```\n\n7、 struct 这个关键字是与结构体类型相关的关键字，可以用它来定义结构体类型\n\n8、 union 这个关键字是与共用体（联合体）相关的关键字\n\n9、 enum 与枚举类型相关的关键字\n\n10、signed 有符号(正负)的意思\n\n```c\n//定义cahr，整形数据使用signed修饰，代表数据是有符号的，可以保存整数，复数\nsigned int b = -6;  //关键字可以省略\n```\n\n11、unsigned 无符号的意思\n\n```c\nunsigned int a = 101; //只能保存整数和0\n```\n\n12、void 空类型的关键字\n\n```c\n//void 是用来修饰函数的参数或者返回值，代表函数没有参数或没有返回值\n//例：\nvoid fun(void)\n{\n\n}\n//代表 fun 函数没有返回值，fun 函数没有参数\n```\n\n1.1.2 存储相关关键字\n\n1、**register** 是寄存器的意思，用 register 修饰的变量是寄存器变量（尽量分配存储空间在寄存器中）\n\n(1): 定义的变量不一定真的存放在寄存器中。\n\n(2)：cpu 取数据的时候去寄存器中拿数据比去内存中拿数据要快\n\n(3)：因为寄存器比较宝贵，所以不能定义寄存器数组\n\n(4)：register 只能修饰 字符型及整型的，不能修饰浮点型\n\n(5)：因为 register 修饰的变量可能存放在寄存器中不存放在内存中，所以不能对寄存器变量取地址。因为只有存放在内存中的数据才有地址\n\n```c\nregister int a;\nint *p;\np = &a; //错误的，a 可能没有地址\n```\n\n2、static 是静态的意思\n\nstatic 可以修饰全局变量、局部变量、函数\n\n3、const 常量的意思\n\n用 const 修饰的变量是只读的，不能修改它的值（**可以修改指针**）\n\n4、auto int a;和 int a 是等价的，auto 关键字现在基本不用\n\n5、extern 是外部的意思，一般用于函数和全局变量的声明\n\n### 1.1.3 控制语句相关的关键字\n\nif 、else 、break、continue、for 、while、do、switch case、goto、default\n\n### 1.1.4 其他关键字\n\n1、sizeof\n\n使用来测变量、数组的占用存储空间的大小（字节数）\n\n例 3：\n\n```c\nint a=10;\nint num;\nnum=sizeof(a);\n```\n\n2、typedef 重命名相关的关键字\n\n关键字 ，作用是给一个已有的类型，重新起个类型名，并没有创造一个新的类型\n\n以前大家看程序的时候见过类似的变量定义方法\n\nINT16 a;\n\nU8 ch;\n\nINT32 b\n\n3、volatile 易改变的意思\n\n用 volatile 定义的变量，是易改变的，即告诉 cpu 每次用 volatile 变量的时候，重新去内存中取 。保证用的是最新的值,而不是寄存器中的备份。\n\n```c\n//volatile 关键字现在较少适用\nvolatile int a=10;\n```\n","tags":["嵌入式C"],"categories":["千锋C语言"]}]