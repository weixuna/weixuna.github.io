<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2024年金砖竞赛--云边端赛项</title>
    <url>/2024/10/08/2024%E5%B9%B4%E9%87%91%E7%A0%96%E7%AB%9E%E8%B5%9B--%E4%BA%91%E8%BE%B9%E7%AB%AF%E8%B5%9B%E9%A1%B9/</url>
    <content><![CDATA[大致打开视频文件：使用 cv2.VideoCapture 打开指定路径的视频文件。检查是否成功打开：通过 cap.isOpened() 方法检查是否成功打开了视频文件。读取视频帧：在循环中使用 cap.read() 方法逐帧读取视频。显示视频帧：使用 cv2.imshow() 方法显示每一帧。保存视频帧：定义 save_image 函数来保存当前帧，并以 frame_计数.jpg 的形式命名。释放资源并关闭窗口：定义 release_resources函数或者cap.release()cv2.destroyAllWindows()释放摄像头并关闭所有窗口键盘输入监听：使用 cv2.waitKey() 方法等待一小段时间（这里设置为 1 毫秒），并在用户按下 &#x27;q&#x27; 键时退出循环。

读取视频video_path = &#x27;path_to_your_video.mp4&#x27;  # 将此处替换为你的MP4文件路径cap = cv2.VideoCapture(video_path)

判断是否打开# 检查视频是否成功打开if not cap.isOpened():    print(&quot;Error: Could not open video.&quot;)

获取视频的宽度&#x2F;长度像素# 获取视频的宽度frame_width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))# 获取视频的长度frame_height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))

读取视频图像，赋值给ret，framewhile True:        # 读取帧        ret, frame = cap.read()        if not ret:            print(&quot;Cannot receive frame (stream end?). Exiting ...&quot;)            break            # 显示帧        cv2.imshow(&#x27;Video&#x27;, frame)            # 按下 &#x27;q&#x27; 键退出        if cv2.waitKey(1) == ord(&#x27;q&#x27;):            break            # 保存当前帧        save_image(frame, frame_count)        frame_count += 1

释放资源# 释放摄像头并关闭所有窗口    cap.release()    cv2.destroyAllWindows()

判断文件夹是否存在# 检查输出目录是否存在，如果不存在则创建output_dir = &#x27;rename&#x27;if not os.path.exists(output_dir):    os.makedirs(output_dir)

查看文件夹的文件，并且返回给一个数组filenamer_list = [entry.name for entry in os.scandir(folder_path) if entry.is_file()]os.scandir(picture) 会扫描指定文件夹picture下的所有内容

将picture文件夹内的所有.png 拓展名文件修改为.jpg拓展名，保存在rename 文件夹内# 将文件名的拓展名从.png修改为.jpgnew_filename = filename.replace(&quot;.png&quot;, &quot;.jpg&quot;)# 重命名文件到目标文件夹os.rename(source_file, target_file)

读取当前路径的图片img = cv2.imread(&#x27;test.png&#x27;)

将图像转换成灰度img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

传入灰色图像，阈值变量为threshold，超过阈值的像素修改为255，采用cv2.THRESH_BINARY_INVcv2.threshold(img_gray, threshold, 255, cv2.THRESH_BINARY_INV)              图像       阈值变量

读取当前目录下的wuyanzu.png的灰度图片；进行图像边缘检测传入最小阈值为128，最大阈值为 200# 读取当前路径下的“wuyanzu.png”图片，并转为灰度图img_wuyanzu = cv2.imread(&#x27;wuyanzu.png&#x27;, cv2.IMREAD_GRAYSCALE)# 使用 Canny 边缘检测，设置最小阈值为128，最大阈值为200edges = cv2.Canny(img_wuyanzu, 128, 200)

对图像进行图像的均衡化对比度限制值为2直方图均衡化的网格大小为 8*8。# 创建CLAHE对象，设置对比度限制为2，网格大小为8x8clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))


]]></content>
  </entry>
  <entry>
    <title>24年技能大赛广东样题</title>
    <url>/2024/01/17/24%E5%B9%B4%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E5%B9%BF%E4%B8%9C%E6%A0%B7%E9%A2%98/</url>
    <content><![CDATA[24年样题1一、接线二、维护三、sql server维护



24年样题2一、接线
二、维护






24年样题3一、接线二、维护


24年样题4一、接线二、维护重复的题省略



24年样题5一、接线二、维护




24年样题6一、接线二、维护



]]></content>
      <categories>
        <category>技能大赛</category>
      </categories>
      <tags>
        <tag>样题</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS第一天</title>
    <url>/2023/10/24/CSS%E7%AC%AC%E4%B8%80%E5%A4%A9/</url>
    <content><![CDATA[1.CSS 语法规范h1&#123;color:red; font-size:25px;&#125;选择器 属性 值

2.类选择器&lt;div class=&quot;red font20&quot;&gt;亚瑟&lt;/div&gt;

3.id 选择器#id名&#123;	属性1：属性值1；&#125;

4.通配符选择器*&#123;	属性1：属性值1；&#125;
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS第二天</title>
    <url>/2023/10/24/CSS%E7%AC%AC%E4%BA%8C%E5%A4%A9/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Dx-C511模块连接华为云OTA</title>
    <url>/2024/09/26/Dx-C511%E6%A8%A1%E5%9D%97%E8%BF%9E%E6%8E%A5%E5%8D%8E%E4%B8%BA%E4%BA%91%E4%B8%8B%E8%BD%BD%E5%9B%BA%E4%BB%B6/</url>
    <content><![CDATA[1、配置APN
AT+QICSGP&#x3D;1,1,”cmnbiot”,””,””
2、开启移动网络
AT+NETOPEN
3、设置客户端ID
AT+MCONFIG&#x3D;”id”,”用户名”,”密码”AT+MCONFIG=&quot;667145986bc31504f06f60ee_wulianwang_0_0_20&quot;,&quot;667145986bc31504f06f60ee_wulianwang&quot;,&quot;63e106dff798f9ed7d313f33c5e1cffe4ad206abe2121b993d464a8f111a97ba&quot;
4、连接mqtt服务器
AT+MIPSTART&#x3D;”服务器IP地址”,1883,4
AT+MIPSTART=&quot;0ae1ed433d.st1.iotda-device.cn-north-4.myhuaweicloud.com&quot;,1883,4
5、连接服务器，设置心跳60秒
AT+MCONNECT&#x3D;1,60
6、订阅数据
AT+MSUB=&quot;$oc/devices/667145986bc31504f06f6/sys/events/down&quot;,0
7、发布长数据
AT+MPUBEX=&quot;$oc/devices/667145986bc31504f06f/sys/events/up&quot;,0,0,149
{“services”:[{“service_id”:”$ota”,”event_type”:”version_report”,”event_time”:”20151212T121212Z”,”paras”:{“sw_version”:”v1.0”,”fw_version”: “v1.0”}}]}
8、开启HTTP模式
AT$HTTPOPEN
9、发送请求头
AT$HTTPRQH&#x3D;Authorization,Bearer 627fd1b1a3f07e7e977b388c112a3af8acf60349c885e3d7c4490661e208b64a
10、发送URL
AT$HTTPPARA&#x3D;https://117.78.5.125:8943/iodm/dev/v2.0/upgradefile/applications/d47eeb52098345898ba95b1be5cbd7c4/devices/667145986bc31504f06f60ee_wulianwang/packages/66e2cfd51bd30f6d19a24533,8943,1,0
11、发送get请求
AT$HTTPACTION&#x3D;0
]]></content>
      <categories>
        <category>华为云IOT连接</category>
      </categories>
      <tags>
        <tag>华为IOT</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML第一天</title>
    <url>/2023/10/11/HTML%E7%AC%AC%E4%B8%80%E5%A4%A9/</url>
    <content><![CDATA[HTML 语法规范&lt;html&gt;&lt;/html&gt;//html标签 &lt;head&gt;&lt;/head&gt; //文档的头部 &lt;title&gt;&lt;/title&gt; //文档的标签&lt;body&gt;&lt;/body&gt;//文档的主体

1.包含关系
    


2.并列关系&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;

3.文档类型声明标签采取的是 html5 版本的显示网页
&lt;!DOCTYPE html&gt;

4.标题标签&lt;h1&gt;  --  &lt;h6&gt;&lt;/h6&gt;&lt;/h1&gt;

5.段落和换行标签&lt;p&gt;段落标签&lt;/p&gt;//根据浏览器窗口的大小自行换行 &lt;br /&gt;//换行标签

6.文本格式化标签&lt;strong&gt;&lt;/strong&gt; &lt;b&gt;&lt;/b&gt; //加粗 &lt;em&gt;&lt;/em&gt; &lt;i&gt;&lt;/i&gt; //倾斜 &lt;del&gt;&lt;/del&gt;&lt;s&gt;&lt;/s&gt; //删除线 &lt;ins&gt;&lt;/ins&gt; &lt;u&gt;&lt;/u&gt; //下划线

7.div 和 span 标签&lt;div&gt;这是盒子&lt;/div&gt;  //分割&lt;span&gt;这也是盒子&lt;/span&gt; //跨度

8.图像标签和路径&lt;img src=&quot;图像url&quot; /&gt;key=&quot;value&quot;




src
必须属性



alt
替换文本。图像不能显示文字


title
提示文本。在图像上显示文字


width
图像的宽度


height
图像的盖度


border
边框粗细


9.超链接标签&lt;a href=&quot;跳转目标&quot; target=&quot;目标窗口的弹出方式&quot;&gt;文本或者图像&lt;/a&gt;

10.特殊字符&amp;nbsp; //空格&amp;ly;  //小于号&amp;gt;  //大于号
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML第三天</title>
    <url>/2023/10/13/HTML%E7%AC%AC%E4%B8%89%E5%A4%A9/</url>
    <content><![CDATA[1.font-familyfont-family //定义文本系列

2. font-size属性定义字体大小。
3.font-weight文本字体的粗细



notmal
默认值



bold
加粗


100-900
400&#x3D;normal,700&#x3D;bold


4.font-style文本风格
normal //默认值 italic//斜体


5.text-align文本内容水平对齐方式
left //左对齐 right //右对齐 center //居中对齐

6.text-decoration给文本添加下划线、删除线、上划线等



none
默认



underline
下划线


overline
上划线


line-through
删除线


7.text-indent段落首行缩进
8.line-height设置行间的距离（行高）
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML第二天</title>
    <url>/2023/10/12/HTML%E7%AC%AC%E4%BA%8C%E5%A4%A9/</url>
    <content><![CDATA[1.表格的基本语法&lt;table&gt; //表格标签  &lt;tr&gt; //行    &lt;td&gt;单元文字&lt;/td&gt;//单元格      &lt;th&gt;姓名&lt;/th&gt;//表格头部份  &lt;/tr&gt;&lt;/table&gt;




align
left\center\right
对齐方式



border
1&#x2F;“”
有没有边框


cellpadding
像素
内容与单元格的空白


cellspacing
像素
单元格之间的空白


wdith
像素
宽度


2.表格结构标签&lt;thead&gt;&lt;/thead&gt; //表格的头部区域&lt;tbody&gt;&lt;/tbody&gt; //表格的主题区域

3.合并单元格rowspan=&quot;合并单元格个数&quot; //跨行colspan=&quot;个数&quot; //跨列

4.无序列表&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt;

5.有序列表&lt;ol&gt;&lt;li&gt;&lt;/li&gt;&lt;/ol&gt;

6.自定义列表&lt;dl&gt;&lt;dt&gt;&lt;/dt&gt;&lt;/dl&gt;

7.表单域&lt;form action=&quot;地址&quot; method=&quot;提交方式&quot; name=&quot;表单域名称&quot;&gt;各种表单元素控件&lt;/form&gt;

8.表单元素&lt;input type=&quot;属性值&quot; /&gt;




button
点击按钮



checkbox
复选框


file
输入字段和浏览按钮，文件上传


hidden
隐藏输入字段


password
密码字段


radio
单选按钮


reset
重置按钮


submit
提交按钮


text
输入文本


image
图像形式的提交按钮


checked:规定此input元素怒首次加载时应当呗选中
maxlength：输入字段中字符的最大长度
placeholder:占位符
8.label标签&lt;label for=&quot;sex&quot;&gt;男&lt;/label&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;sex&quot; /&gt;//一个和id属性相同

9.select表单元素
&lt;select&gt;&lt;option&gt;选项1&lt;/option&gt;&lt;option&gt;选项2&lt;/option&gt;&lt;option&gt;选项3&lt;/option&gt;...&lt;/select&gt;//在&lt;option&gt; 中定义 selected =“ selected &quot; 时，当前项即为默认选中项。

10.texttarea表单元素用于定义多行文本输入控件
&lt;textarea rows=&quot;3&quot; cols=&quot;20&quot;&gt;文本内容&lt;/textarea&gt;//cols=&quot;每行中的字符&quot;//rows=&quot;显示的行数&quot;

&lt;form&gt;&lt;input type=“text &quot; name=“username”&gt;&lt;select name=“jiguan”&gt;&lt;option&gt;北京&lt;/option&gt;&lt;/select&gt;&lt;textarea name= &quot;message&quot;&gt;&lt;/textarea&gt;&lt;/form&gt;

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>SCREEPS</title>
    <url>/2023/11/27/SCREEPS/</url>
    <content><![CDATA[创建机器人var crepp = Game.creeps[&#x27;MiningRobot&#x27;];Game.spawns[&quot;Spawn1&quot;].spawnCreep([WORK, CARRY, MOVE], &quot;Harvester1&quot;);

采集能量module.exports.loop = function () &#123;    var creep = Game.creeps[&#x27;Harvester1&#x27;];    var sources = creep.room.find(FIND_SOURCES);    if(creep.harvest(sources[0]) == ERR_NOT_IN_RANGE) &#123;        creep.moveTo(sources[0]);    &#125;&#125;

采集能量返回module.exports.loop = function () &#123;    var creep = Game.creeps[&#x27;Harvester1&#x27;];    if(creep.store.getFreeCapacity() &gt; 0) &#123;        var sources = creep.room.find(FIND_SOURCES);        if(creep.harvest(sources[0]) == ERR_NOT_IN_RANGE) &#123;            creep.moveTo(sources[0]);        &#125;    &#125;    else &#123;        if( creep.transfer(Game.spawns[&#x27;Spawn1&#x27;], RESOURCE_ENERGY) == ERR_NOT_IN_RANGE ) &#123;            creep.moveTo(Game.spawns[&#x27;Spawn1&#x27;]);        &#125;    &#125;&#125;

module.exports.loop = function () &#123;    for(var name in Game.creeps) &#123;        var creep = Game.creeps[name];        if(creep.store.getFreeCapacity() &gt; 0) &#123;            //检查是否又剩余的容量            var sources = creep.room.find(FIND_SOURCES);            //创建能量的变量，指的是找到这所房间的全部能量            if(creep.harvest(sources[0]) == ERR_NOT_IN_RANGE) &#123;                 //让creep从列表的第一个能源点采集能源                creep.moveTo(sources[0]);                //如果不在能源采集范围，能会走向第一个能源点移动            &#125;        &#125;        else &#123;//当容量已满时，返回Spawn1            if(creep.transfer(Game.spawns[&#x27;Spawn1&#x27;], RESOURCE_ENERGY) == ERR_NOT_IN_RANGE) &#123;                creep.moveTo(Game.spawns[&#x27;Spawn1&#x27;]);            &#125;        &#125;    &#125;&#125;

代码优化var roleHarvester = require(&#x27;role.harvester&#x27;);module.exports.loop = function () &#123;    for(var name in Game.creeps) &#123;        var creep = Game.creeps[name];        roleHarvester.run(creep);    &#125;&#125;var roleHarvester = &#123;    /** @param &#123;Creep&#125; creep **/    run: function(creep) &#123;	    if(creep.store.getFreeCapacity() &gt; 0) &#123;            var sources = creep.room.find(FIND_SOURCES);            if(creep.harvest(sources[0]) == ERR_NOT_IN_RANGE) &#123;                creep.moveTo(sources[0]);            &#125;        &#125;        else &#123;            if(creep.transfer(Game.spawns[&#x27;Spawn1&#x27;], RESOURCE_ENERGY) == ERR_NOT_IN_RANGE) &#123;                creep.moveTo(Game.spawns[&#x27;Spawn1&#x27;]);            &#125;        &#125;	&#125;&#125;;module.exports = roleHarvester;

升级建筑//生成机器人Game.spawns[&#x27;Spawn1&#x27;].spawnCreep( [WORK, CARRY, MOVE], &#x27;Upgrader1&#x27; );var roleHarvester = require(&#x27;role.harvester&#x27;);var roleUpgrader = require(&#x27;role.upgrader&#x27;);module.exports.loop = function () &#123;    for(var name in Game.creeps) &#123;        var creep = Game.creeps[name];        if(creep.memory.role == &#x27;harvester&#x27;) &#123;            roleHarvester.run(creep);        &#125;        if(creep.memory.role == &#x27;upgrader&#x27;) &#123;            roleUpgrader.run(creep);        &#125;    &#125;&#125;

var roleUpgrader = &#123;    /** @param &#123;Creep&#125; creep **/    run: function(creep) &#123;	    if(creep.store[RESOURCE_ENERGY] == 0) &#123;            var sources = creep.room.find(FIND_SOURCES);            if(creep.harvest(sources[0]) == ERR_NOT_IN_RANGE) &#123;                creep.moveTo(sources[0]);            &#125;        &#125;        else &#123;            if(creep.upgradeController(creep.room.controller) == ERR_NOT_IN_RANGE) &#123;                creep.moveTo(creep.room.controller);            &#125;        &#125;	&#125;&#125;;module.exports = roleUpgrader;//每个 creep 都有的 memory 属性，该属性允许在 creep 的“内存”中写入自定义信息。Game.creeps[&#x27;Harvester1&#x27;].memory.role = &#x27;harvester&#x27;;Game.creeps[&#x27;Upgrader1&#x27;].memory.role = &#x27;upgrader&#x27;;//mainvar roleHarvester = require(&#x27;role.harvester&#x27;);var roleUpgrader = require(&#x27;role.upgrader&#x27;);module.exports.loop = function () &#123;    for(var name in Game.creeps) &#123;        var creep = Game.creeps[name];        if(creep.memory.role == &#x27;harvester&#x27;) &#123;            roleHarvester.run(creep);        &#125;        if(creep.memory.role == &#x27;upgrader&#x27;) &#123;            roleUpgrader.run(creep);        &#125;    &#125;&#125;

]]></content>
  </entry>
  <entry>
    <title>eps32连接华为云iot，并且实现arkts控制点灯</title>
    <url>/2024/04/02/eps32%E8%BF%9E%E6%8E%A5%E5%8D%8E%E4%B8%BA%E4%BA%91iot%EF%BC%8C%E5%B9%B6%E4%B8%94%E5%AE%9E%E7%8E%B0arkts%E6%8E%A7%E5%88%B6%E7%82%B9%E7%81%AF/</url>
    <content><![CDATA[ESP32连接华为云我使用的是arduinoied所写的代码，要注意，在mqtt请求华为云中，需要写心跳间隔，不然上云不了（client.setKeepAlive(60);  &#x2F;&#x2F;心跳间隔，很重要！！！）。代码如下：
#include &lt;ArduinoJson.h&gt;#include &lt;WiFi.h&gt;#include &lt;PubSubClient.h&gt;// 定义 LED 和按键引脚const int led_pin = 48; // 根据你的实际硬件更改const int button_pin = 0; // 通常用于ESP32的引脚// 定义 LED 状态变量，默认为假即低电平，通过它判断 LED 的状态是否改变过bool led_status = false;// WiFi 连接参数const char* ssid = &quot;LMJZ&quot;;     // 修改为你的WiFi名称const char* password = &quot;12345678&quot;; // 修改为你的WiFi密码// MQTT 连接参数const char* mqttServer = &quot;f31531a1fe.iot-mqtts.cn-north-4.myhuaweicloud.com&quot;;const int mqttPort = 1883;const char* clientId =&quot;65f5bd99fb8177243a4f32c3_wenshidu_0_0_2024033011&quot;;const char* mqttUser =&quot;65f5bd99fb8177243a4f32c3_wenshidu&quot;;const char* mqttPassword = &quot;def7f41de80e802a96a29f04eec1561c6a63057d2d0a0ed0aba966041ee6a5f1&quot;;// MQTT 客户端WiFiClient espClient;PubSubClient client(espClient);// MQTT 主题#define device_id &quot;65f5bd99fb8177243a4f32c3_wenshidu&quot;#define secret &quot;630aa442fa0fa9956ea95016189a5186&quot;#define Iot_link_Body_Format &quot;&#123;\&quot;services\&quot;:[&#123;\&quot;service_id\&quot;:\&quot;BasicData\&quot;,\&quot;properties\&quot;:&#123;%s&quot;// 设备属性上报#define Iot_link_MQTT_Topic_Report &quot;$oc/devices/&quot; device_id &quot;/sys/properties/report&quot;// 接收平台下发的命令#define Iot_link_MQTT_Topic_Commands &quot;$oc/devices/&quot; device_id &quot;/sys/commands/#&quot; // 设备响应平台的命令#define Iot_link_MQTT_Topic_CommandsRes &quot;$oc/devices/&quot; device_id &quot;/sys/commands/response/request_id=&quot;// 其他变量和函数声明int data_temp = 20; // 模拟上报的温度值long lastMsg = 0;void setup() &#123;  // 设置 LED 和按键引脚模式  pinMode(led_pin, OUTPUT);  pinMode(button_pin, INPUT_PULLUP);  // WiFi 初始化  Serial.begin(115200);  WiFi.begin(ssid, password);  while (WiFi.status() != WL_CONNECTED) &#123;    delay(500);    Serial.println(&quot;Connecting to WiFi..&quot;);  &#125;  Serial.println(&quot;Connected to the WiFi network&quot;);  // MQTT 初始化  MQTT_Init();&#125;void loop() &#123;  // 检测按键状态并控制 LED  if (digitalRead(button_pin) == LOW) &#123;    delay(100); // 去抖动    if (digitalRead(button_pin) == LOW) &#123;      while(digitalRead(button_pin) == LOW); // 等待按钮释放      led_status = !led_status;      digitalWrite(led_pin, led_status ? HIGH : LOW);    &#125;  &#125;  // MQTT 连接和数据上报  if (!client.connected()) &#123;    MQTT_Init();  &#125; else &#123;    client.loop();  &#125;  long now = millis();  if (now - lastMsg &gt; 5000) &#123;    lastMsg = now;    MQTT_POST();    data_temp++; // 递增温度值以模拟温度变化  &#125;&#125;void MQTT_Init() &#123;  client.setKeepAlive(60);  //心跳间隔，很重要！！！  client.setServer(mqttServer, mqttPort);  client.setCallback(callback);  while (!client.connected()) &#123;    Serial.println(&quot;Attempting to connect to MQTT server...&quot;);    if (client.connect(clientId, mqttUser, mqttPassword)) &#123;      Serial.println(&quot;Connected to MQTT server&quot;);      // 订阅命令主题      client.subscribe(Iot_link_MQTT_Topic_Commands);    &#125; else &#123;      Serial.print(&quot;Failed to connect to MQTT server, state: &quot;);      Serial.println(client.state());      delay(5000);    &#125;  &#125;&#125;void MQTT_POST() &#123;  char properties[50];  char jsonBuf[200];  sprintf(properties, &quot;\&quot;temperature\&quot;:%d&#125;&#125;]&#125;&quot;, data_temp);  sprintf(jsonBuf, Iot_link_Body_Format, properties);  client.publish(Iot_link_MQTT_Topic_Report, jsonBuf);  Serial.println(&quot;MQTT Publish OK!&quot;);&#125;void callback(char* topic, byte* payload, unsigned int length) &#123;  String recdata = &quot;&quot;;  Serial.printf(&quot;接收到订阅的消息:主题为：%s\n&quot;, topic);   Serial.print(&quot;数据内容：&quot;);  for (int i = 0; i &lt; length; i++) &#123;    recdata += (char)payload[i];  &#125;  Serial.println(recdata);  // 解析JSON数据  DynamicJsonDocument jsonBuffer(1024);  deserializeJson(jsonBuffer, recdata);  JsonObject obj = jsonBuffer.as&lt;JsonObject&gt;();  JsonObject paras = obj[&quot;paras&quot;].as&lt;JsonObject&gt;();  String ledcom = paras[&quot;value&quot;];  Serial.printf(&quot;解析命令：%s\n&quot;, ledcom.c_str());  // 解析request id，设备响应时的topic需要包含命令的request id，且会动态变化  String request_id = topic;  request_id.remove(0, request_id.lastIndexOf(&#x27;=&#x27;) + 1);  Serial.printf(&quot;request_id：%s\n&quot;, request_id.c_str());  // 命令设备响应  String response = &quot;&#123;&#125;&quot;;  client.publish((Iot_link_MQTT_Topic_CommandsRes + request_id).c_str(), response.c_str());  if (ledcom == &quot;ON&quot;) &#123;    digitalWrite(led_pin, LOW); // 关闭LED    Serial.println(&quot;关灯&quot;);  &#125; else if (ledcom == &quot;OFF&quot;) &#123;    digitalWrite(led_pin, HIGH); // 打开LED    Serial.println(&quot;开灯&quot;);  &#125;&#125;

在鸿蒙开发中，要进行http请求，arkts代码
下面是ui代码：
Button(&#x27;点击&#x27;).onClick(async () =&gt; &#123;  if (this.led) &#123;    try &#123;      await greenHousesHttpRequest.sendDeviceCommand(&#x27;BasicData&#x27;, &#x27;Switch&#x27;, &#x27;OFF&#x27;);      console.log(&#x27;LED已关闭&#x27;);      this.led = false; // 更新LED状态为关闭      this.leddevice = &#x27;离线&#x27;; // 更新设备状态显示为不在线    &#125; catch (error) &#123;      console.error(&#x27;关闭LED失败&#x27;, error);    &#125;  &#125; else &#123;    try &#123;      await greenHousesHttpRequest.sendDeviceCommand(&#x27;BasicData&#x27;, &#x27;Switch&#x27;, &#x27;ON&#x27;);      console.log(&#x27;LED已点亮&#x27;);      this.led = true;      this.leddevice = &#x27;在线&#x27;;    &#125; catch (error) &#123;      console.error(&#x27;点亮LED失败&#x27;, error);    &#125;  &#125;&#125;).margin(&#123;top:10&#125;);

http请求代码：
// 设备下发命令  async sendDeviceCommand(serviceId, commandName, commandValue) &#123;    if (!this.token) &#123;      await this.getAuthToken();    &#125;    return new Promise((resolve, reject) =&gt; &#123;      let httpRequest = http.createHttp();      const url = &quot;https://f31531a1fe.iotda.cn-north-4.myhuaweicloud.com:443/v5/iot/34dd0bcb3a0b46fab400809bca1b6e3e/devices/65f5bd99fb8177243a4f32c3_wenshidu/commands&quot;      httpRequest.request(url,&#123;        method: http.RequestMethod.POST,        header: &#123;          &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,          &#x27;X-Auth-Token&#x27;: this.token // 确保已经获取了token        &#125;,        extraData: &#123;          &quot;service_id&quot;: serviceId,          &quot;command_name&quot;: commandName,          &quot;paras&quot;: &#123;            &quot;value&quot;: commandValue          &#125;        &#125;      &#125;).then(resp =&gt; &#123;        if (resp.responseCode == 200) &#123;          resolve(JSON.parse(resp.result.toString()));        &#125; else &#123;          reject(&#x27;Failed to send command, response code: &#x27; + resp.responseCode);        &#125;      &#125;).catch(error =&gt; &#123;        console.error(&#x27;Error sending command:&#x27;, JSON.stringify(error));        reject(error);      &#125;);    &#125;);  &#125;
]]></content>
      <categories>
        <category>华为云IOT连接</category>
      </categories>
      <tags>
        <tag>华为云IOT</tag>
      </tags>
  </entry>
  <entry>
    <title>一、harmonyOS开发</title>
    <url>/2024/03/09/%E4%B8%80%E3%80%81HarmonyOS4%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[一、TS基础语法二、声明变量
二、条件控制

三、循环迭代
四、函数
五、类和接口
六、模块
七、UI布局分析
八、image组件
一些代码示例
]]></content>
      <categories>
        <category>鸿蒙开发</category>
      </categories>
      <tags>
        <tag>APP开发</tag>
      </tags>
  </entry>
  <entry>
    <title> 一篇牢骚</title>
    <url>/2024/03/30/%E4%B8%80%E7%AF%87%E7%89%A2%E9%AA%9A/</url>
    <content><![CDATA[愿我此生脚步不停，览尽世间美景。即使路途遥远且艰难，至少，至少，我经历过。以巽为名，行遍千山万水，看尽人间青山。青山不言，我自知晓其壮美。来自抖音博主hx888888000长穿毕



来自抖音博主zkai6999那拉提


来自抖音博主zkai6999阿勒泰


]]></content>
  </entry>
  <entry>
    <title>关于使用wsl使用idf提供编译速度遇到的问题</title>
    <url>/2024/04/20/%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8wsl%E4%BD%BF%E7%94%A8idf%E6%8F%90%E4%BE%9B%E7%BC%96%E8%AF%91%E9%80%9F%E5%BA%A6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[
在wsl的ubuntu安装idf遇到没有串口的报错，是因为wsl不自带usb的驱动，需要手动安装
教程使用他人的：https://blog.csdn.net/qq_40695642/article/details/127270039
]]></content>
  </entry>
  <entry>
    <title>许久没有发文章了</title>
    <url>/2024/09/04/%E5%85%B3%E4%BA%8E%E5%9C%A8%E7%89%A9%E8%81%94%E7%BD%91%E7%AB%9E%E8%B5%9B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%84%9F%E6%83%B3/</url>
    <content><![CDATA[从四月份到八月份的比赛结束，取得了华东赛区一等奖和全国总决赛二等奖。说起来，也是跟在梦中似的~没有想过真的可以进去国赛，也算是吃到了赛道的福利了。在华东赛区和总决赛的作品演示室看到他们的作品，看的我都自卑了，很高级，我们的作品很简陋，太简陋了，搞得我都想跑了 ~

我负责的是写APP和数据大屏，但是连整合单片机的部分都是我来写的，一个字“累”！写鸿蒙APP，也是只学习了三天ArkTs就直接开始写了，ArkTs也是基于TS来的，与JS相对，TS确实简单很多，我主要是有基础啦。总结就是，UI很烦很烦！！！没有艺术细胞的我，画UI简直是酷刑！！！

整合单片机的也是一个折磨，两个队友的代码习惯不一样，不能直接调用函数，而且出现的bug最多的就是单片机……语音，WIFI，LoRa这部分都是我来的，有时候LoRa很奇怪，节点能发数据，但是网关收不到，在华东赛区的时候出现这个问题，吓得我手都在抖哈哈哈。
数据大屏这部分没啥好说的，用的是低代码，会搞Http请求就没有任何问题了，挺简单的。
在总决赛的之前，临时买了一个ESP32Cam，缺点就是卡(供电需要5V2A的，他的烧录板没有！！！)，清晰度倒还好，加入了一个火焰检测，本来是加入烟雾的，摄像头模糊，老是识别到模糊的地方是烟雾，可恶。ESP32Cam视频流转成一个服务器地址，Python再用OpenCV获取，再加入YOLOV8训练的模型就可以了，不过这些部分不是熟悉，实现效果有就行啦。不过在比赛的时候，没有演示出来。

]]></content>
  </entry>
  <entry>
    <title>大学生活</title>
    <url>/2024/02/17/%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%B4%BB/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>阅读</category>
      </categories>
  </entry>
  <entry>
    <title>技能大赛之Ubuntu维护</title>
    <url>/2023/10/30/%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B%E4%B9%8BUbuntu%E7%BB%B4%E6%8A%A4/</url>
    <content><![CDATA[如果是首次进入需要 sudo passwd root 启用 root 用户
一、修改网络 IP 地址1、lm@lm-virtual-machine:~/桌面$ su root密码：2、root@lm-virtual-machine:/home/lm/桌面# cd /etc/netplan/3、root@lm-virtual-machine:/etc/netplan# ls01-network-manager-all.yaml4、root@lm-virtual-machine:/etc/netplan# vim 01-network-manager-all.yaml#键盘点击i，进行修改，&quot;esc&quot;退出编辑，输入&quot;:wq&quot;退出回车保存。输入&quot;netplan apply&quot;,ifconfig可以查看是否修改成功

network:　version: 2　ethernets:　　ens5:　　dhcp4: no　　addresses: [192.168.1.230/24]　　gateway4: 192.168.1.254　　nameservers:　　　addresses: [8.8.4.4,8.8.8.8]

二、使用命令查询磁盘空间使用情况 【df】
三、命令执行的历史记录【history】
四、配置允许 tcp 协议通过 eth0 网卡的 80 端口进入服务器iptables -A INPUT -p tcp --dport 80 -i th0 -j ACCEPTiptables -L -n


五、开启系统简单防火墙功能ufw enableufw status


六、修改时区为中国tzselect


七、查看当前系统的内核版本uname -a


八、查看系统安装包的统计信息apt-cache stats


九、查看&#x2F;home 目录占用空间du -sh


十、系统内存的使用情况free


十一、修改 test 文件夹权限为 755mkdir xxx      创建文件夹chmod xxx xxx    修改后文件夹名字  修改前


十二、配置用户锁策略，用户尝试登录错误 5 次后锁定用户 5 分钟auth required pam_tallu.so deny=5 unlock_time=300 even_deny_root root_unlock_time=300#文件夹在etc/pam.d/login#deny=尝试次数 unlock_time=被锁定，多少秒自动解锁#even_deny_root=对root用户生效 root_unlock_time=被锁后多少秒解锁


十三、配置账户密码最短使用期限为 10 天，最长使用期限为 90 天sudo chage -M 90 -m 10 liu#修改#查看sudo chage -l liu

十四、配置用户使用 ssh 登录边缘服务器有“For authorized users only”vim /ect/motd


十五、查询系统运行时间及负载的状态uptime


十六、统计系统 IO 信息（系统资源）top


十七、查看当前登录系统的用户信息
十八、ubuntu 登录开通 ssh-server 和 root 用户登录权限


sudo systemctl start ssh 启动 ssh 服务
十九、修改 root 用户密码
二十、切换当前用户为 root 用户
二十一、查看当前所有已连接端口netstar -ntlp


二十二、查看指定端口状态netstat -ntlplgrep 3306


二十三、查看所有进程信息ps -aux


二十四、查看指定进程信息
二十五、终端查找文件在当前目录中搜索
find -name &quot;文件名&quot;

在不切换任何文件夹搜索，必须在命令中声明文件所在目录路劲
find /路径/ -name &quot;文件名&quot;

如果在终端搜索文件
find -name &quot;文件名&quot;

如果在终端搜索带某字符的文件
find / -type f -name &quot;*DB*&quot;


二十六、在终端查看 sql 文件的记录head -n 文件名.sql


二十七、 使用命令查看要求上传 sql 文件的内容中 包含“xxx”信息的记录行。grep &quot;xxx&quot; xxx.sql


二十八、在 Ubuntu 的终端中使用命令查看要求上传 sql 文件内容并显示行号。cat -n xx.sql


二十九、在 Ubuntu 的终端中通过 iptables 配置规则链：允许本机开放 TCP 端口 5000-6000iptables -A INPUT -p tcp --match multiport --sports 5000:6000 -j ACCEPT# 如果需要重启后重新起效  iptables-save &gt; /etc/iptables/rules.v4

三十、设置账号密码的最小长度vim /etc/pam.d/common-password


三十一、为 MySQL 配置远程访问功能，以便任何 IP 的客户端都能访问数据库#配置用户信息mysql -u root -pALTER USER &#x27;username&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH &#x27;mysql_native_password&#x27; BY &#x27;new_password&#x27;;#先配置mysql文件sudo nano /etc/mysql/mysql.conf.d/mysqld.cnf#添加bind-address = 0.0.0.0#更改用户权限CREATE USER &#x27;username&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;password&#x27;;            #用户名字 #允许任何ip连接         #密码GRANT ALL PRIVILEGES ON *.* TO &#x27;username&#x27;@&#x27;%&#x27; WITH GRANT OPTION;FLUSH PRIVILEGES;#重启数据库sudo systemctl restart mysql#查询是否生效SELECT user,authentication_string,host FROM mysql.user;


开启成功

三十二、命令行查询网卡 eth0 的工作状态ifconfig eth0

三十三、Xshell 登录 Ubuntu

三十四、删除指令
三十五、在&#x2F;home&#x2F;iotuser 目录下创建 aaa,bbb 两个目录，在 aaa 目录下添加 a.txt 文件，在 bbb 目录下添加 ccc 目录和 b.txt 文件,在 ccc 目录下添加 c.txt 文件。 命令行将 bbb 文件夹权限设置为：每个人都有读和写以及执行的权限（包含子目录）。 合并压缩 aaa 和 bbb 目录为 xxx.tar.gz。mkdir -p /home/iotuser/aaa /home/iotuser/bbb/ccctouch /home/iotuser/aaa/a.txttouch /home/iotuser/bbb/b.txttouch /home/iotuser/bbb/ccc/c.txtchmod -R 777 /home/iotuser/bbbcd /home/iotusertar -czvf xxx.tar.gz aaa bbb

三十六、在终端配置 ufw，要求设置允许 TCP 的 5505 端口可以访问本机。sudo ufw allow 5505/tcp#保存sudo ufw status

三十七、在终端使用 ufw，要求允许 192.168.0.200 这台计算机访问本机。sudo ufw allow from 192.168.0.200

三十八、修改配置将 ssh 服务远程连接的默认端口修改成 8888。sudo vim /etc/ssh/sshd_config#修改Port 8888

三十九、离线安装 mysql、python，vim#解压mysqlunzip name.file#给权限sudo chmod 775 install.sh#开启服务sudo service mysql start#设置密码sudo mysql_secure_installation#安装pythonsudo dpkg -i python.deb python-libraries.deb#安装vimsudo dpkg -i vim.deb

四十、查看当前操作系统版本信息cat /etc/lsb-release


四十一、查看系统内核限制ipcs -l


四十二、使用 scp 传输scp /path/file root@172.20.1.1:/path/file

四十三、在终端中使用命令添加一个名为 lily 的用户名，要求在 home 目录下同步创建该用户目录。将该用户添加到名为 school Admin 的用户组#创建schoolAdmin用户组sudo groupadd schoolAdmin#创建lily的用户名sudo useradd -m lily#将将该用户添加到名为school Admin的用户组sudo usermod -a -G schoolAdmin lily

四十五、查看 root 用户进程信息ps -u root

四十六、命令查询 Ubuntu 系统有几块物理硬盘#只显示几块硬盘lsblk -d | grep disk | wc -l

四十七、mysql 命令查询主程序所在路径的参数#which mysqld#SHOW VARIABLES LIKE &#x27;basedir&#x27;;



四十八、查看数据库大小SELECT CONCAT(ROUND(SUM(data_length / 1024 / 1024), 2), &#x27; MB&#x27;) AS dataFROM information_schema.TABLESWHERE table_schema = &#x27;testdatabase&#x27;;

四十九、mysql 创建数据库然后导入 sqlsource 文件路径;

五十、查看指定用户进程ps -u root

五十一、ubuntu 安装 mysql#解压mysqlunzip name.file#775权限sudo chmod 775 name.file#执行安装sudo ./install.sh#开启服务sudo server mysql start#输入密码mysql -u root -p
]]></content>
      <categories>
        <category>技能大赛</category>
      </categories>
      <tags>
        <tag>Ubuntu维护</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库常用命令</title>
    <url>/2023/08/29/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[修订：查看表中的字段
show columns from 商品库存;xxxxxxxxxx columnshow columns from 商品库存;



select 所在区域 from 商品库存 limit 5;  检索此语句使用SELECT语句检索单个列。LIMIT 5指示MySQL返回不多于5行。


统计四张表的记录数,要求 SQL 语句禁用联合查询（Union、JOIN、多表
SELECT	(SELECT COUNT(*) FROM d_3_1) AS dcount,	(SELECT COUNT(*) FROM 商品库存) AS scount


一、连接数据库mysql -h 主机IP -P 端口号 -u 用户名 -p 密码

在 UbuntuMySQL -u root -p

连接远程主机
mysql -h110.110.110.110 -u root -p 123;

二、修改用户密码mysqladmin -u root -password ab12

再次修改
mysqladmin -u root -password djg345

三、新增用户（1）增加一个用户 test1，密码为 abc
grant select,insert,delete on *.*to [email]=test@&quot;%]test1@&quot;[/email]&quot;Indentified by&quot;abc&quot;;# grant on 命令格式：grant select on 数据库.* to 用户名@登录主机 identified by “密码”;

（2）新增一个 test2 密码为 abc，只能 localhost 登录
grant select,insert,update,delete on mydb.* to [email=test2@localhost]test2@localhsot[/email] identified by &quot;abc&quot;;# 如果不想test有密码可以在用一次打消密码grant select,insert,update,delete on mydb.* to [email=test2@localhost]test2@localhost[/email] identified by “”;=

四、创建数据库（1）create database 命名;

（2）创建数据库并分配用户
#1create database 数据库名;#2create select,insert,update,delete,create,drop,alter on 数据库名.* to 数据库名@loclhost identified by &#x27;密码&#x27;;#3select password por &#x27;数据名&#x27;@&#x27;localhost&#x27; =old_password(&#x27;密码&#x27;);

五、显示数据库show databases 显示所有数据库

六、删除数据库drop database xhkdb;

七、使用数据库use xhkdb;
（1）use 语句可以通告 mysql 把数据库当作默认使用。知道下一个不同的 use 语句。

（2）use 语句不会阻碍访问其他数据库中的表。ab1 数据库访问 author 表，并从 db2 数据库访问 editor 表
use db1;select author_name,editor_name from author,ab2,editor;where author.editor_id = ab2.editor.editor_id;

八、当前连接的数据库select database();
（1）显示 mysql 版本
select version();


（2）显示当前时间
select now();


（3）显示年月日



（4）显示字符串

（5）当计算器

（5）串接字符串

&#x2F;&#x2F;这里用到 CONCAT()函数，用来把字符串串接起来。
九、创建数据库表注意：要先使用 use 数据库名；
create table 表名(	字段名1，数据类型 [列级别约束条件][默认值]，	字段名2，数据类型 [列级别约束条件][默认值],	……	[表级别约束条件])


例如:创建 tb_emp1 表结构


十、获取表结构查看表结构可以使用 describe 和 show create table；
describe 表名;

或
desc 表名；

show create table 可以查看显示创建表时的 create table 语句。
show create table 表名\G;


十一、删除数据表drop table if exists 表1，表2,表n


十二、向表中插入数据insert into 插入新行
insert into 表名称 values(值1，值2);# 也可以指定要插入数据的列insert into table_name(列1，列2)values(值1，值2)

十三、查询表中数据SELECT &#123;* | &lt;字段列表&gt;&#125; [	 FROM &lt;表 1&gt;,&lt;表 2&gt;...	 [WHERE &lt;表达式&gt;	 [GROUP BY &lt;group by definition&gt;]	 [HAVING &lt;expression&gt; [&#123;&lt;operator&gt;&lt;expression&gt;&#125;...]] 	[ORDER BY &lt;order by definition&gt;] 	[LIMIT [&lt;offset&gt;,] &lt;row count&gt;] ]SELECT [字段 1,字段 2,…,字段 n]FROM [表或视图]WHERE [查询条件];


十四、删除记录delete from table_name[where &lt;condition&gt;];#						指定删除条件delete from person where id=11;

十五、修改表中的数据update table_nameset column_nmael=value1,column_name2=value2where(condition)

column_name1，为指定更新的字段名称。value 为相对应指定字段的更新值。condition 更新记录需要满足的条件
【例】在 person 表中，更新 id 值为 11 的记录，将 age 字段值改为 15，将 name 字段值改为 LiMing，SQL 语句如下：
update person set age=15,name=&#x27;liming&#x27;where id=11;

十六、增加字段alter add 表名 add 新字段 数据类型	约束条件 first|after 已存在字段名	        first将新添加的字段设置为表的第一个字段	        after新添加的字段指定在‘已存在字段名’的后面

【例】在数据表 tb_dept1 中添加一个没有完整性约束的 INT 类型的字段 managerId（部门经理编号），SQL 语句如下：
ALTER TABLE tb_dept1 ADD managerId INT(10);

十七、修改表名alter table 旧表名 rename to新表名

【例】将数据表 tb_dept3 改名为 tb_deptment3，SQL 语句如下：
ALTER TABLE tb_dept3 RENAME tb_deptment3;

十八、备份数据库mysqldump -u user -h host -p password dbname[tbname,[tbname]]&gt;filename.sql

十九、还原数据库mysql -u user -p [dbname]&lt;filename.sql

【例 1】使用 mysql 命令将 C:\backup\booksdb_20130301.sql 文件中的备份导入到数据库中，输入语句如下：
mysql –u root –p booksDB &lt; C:/backup/booksdb_20130301.sql

如果已经登录 MySQL 服务器，还可以使用 source 命令导入 sql 文件。source 语句语法如下：
source filename

【 例 2 】 使 用 root 用 户 登 录 到 服 务 器 ， 然 后 使 用 source 导 入 本 地 的 备 份 文 件 booksdb_20110101.sql，输入语句如下：
–选择要恢复到的数据库
mysql&gt; use booksDB;Database changed

–使用 source 命令导入备份文件
mysql&gt; source C:\backup\booksDB_20130301.sql

二十、快速恢复数据库在 MySQL 服务器停止运行时，将备份的数据库文件复制到 MySQL 存放数据的位置（MySQL 的 data 文件夹）
chown -R mysql.mysql /var/lib/mysql/dbname

【例】从 mysqlhotcopy 复制的备份恢复数据库，输入语句如下：
cp -R /usr/backup/test usr/local/mysql/data

二十一、在 Ubuntu 下安装 mysqlsudo apt-get update #更新软件包sudo apt-get install mysql-server #安装数据库服务器启动：sudo /etc/init.d/mysql start停止：sudo /etc/init.d/mysql stop重启：sudo /etc/init.d/mysql restart登录：mysql -u root -p&lt;pwd&gt;

二十二、关闭防火墙- sudo apt-get install ufw 安装防火墙- sudo ufw enable 打开防火墙- sudo ufw status 查看防火墙状态- sudo ufw disable 关闭防火墙

MySQL 在 Ubuntu 使用二十三、在服务器 SQLSERVER 上，利用 U 盘“U 盘资料&#x2F;test.sql”还原三张数据表。

二十四、统计三张表的记录数，查询结果要求如图。SELECT &#x27;table1&#x27; AS TableName, COUNT(*) AS RecordCount FROM table1UNION ALLSELECT &#x27;table2&#x27; AS TableName, COUNT(*) AS RecordCount FROM table2UNION ALLSELECT &#x27;table3&#x27; AS TableName, COUNT(*) AS RecordCount FROM table3;

二十五、删除 AD_AccountsRole 表中不属于 AD_Accounts 用户的关系数据。重新查询三张表的记录数。
二十六、新建查询窗口，写出查询 nleedge 数据库中所有数据表和每个表的记录SELECT  (SELECT COUNT(*) FROM d_3_1) AS 表一,  (SELECT COUNT(*) FROM `商品库存`) AS 表二;
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>物联网比赛之Windows维护</title>
    <url>/2023/08/29/%E7%89%A9%E8%81%94%E7%BD%91%E6%AF%94%E8%B5%9B%E4%B9%8BWindows%E7%BB%B4%E6%8A%A4/</url>
    <content><![CDATA[模块 B：物联网故障维修与运行维护1、Windows 系统维护

一、出于安全考虑，需要对服务器计算机配置规则：“禁止工作站计算机访问本机任何程序或者端口，暂不启用此规则”。
点击自定义






记得露出本地地址
二、在工作站电脑的命令行窗口中，使用命令查看网络连接以及每一个网络接口设备状态。netstat -an

扩展：（1）netstat -b 可以显示在创建网络连接和侦听端口时所涉及的可执行程序
（2）netstat -a 显示所有的有效连接信息列表，包括建立的连接（ESTABLISHED），也包括监听连接请求（LISTENLING）的那些连接
（3）netstat -e 可以显示关于以太网的统计数据，传送字节数、数据包、错误等信息，还可以和-s 结合使用
（4）netstat -f 显示外部地址的完全限定域名
（5）netstat -p 可以显示 proto 指定的协议连接情况
（6）netstat -r 显示路由表
]]></content>
      <categories>
        <category>技能大赛</category>
      </categories>
      <tags>
        <tag>windows维护</tag>
      </tags>
  </entry>
  <entry>
    <title>电子工程师入门篇-入门基础</title>
    <url>/2024/02/08/%E7%94%B5%E5%AD%90%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%85%A5%E9%97%A8%E7%AF%87-%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[1.1.1 电路与电路图电源的作用是提供电能；开关、导线的作用是控制和传递电能，称为中间环节；灯泡是消耗电能的用电器，它能将电能转变为光能，称为负载。

1.1.2 电流与电阻1．电流​ 我们把电子运动的反方向作为电流方向，即把正电荷在电路中的移动方向规定为电流的方向。
​ 电流通常用字母“I”表示，单位为安培（简称安），用“A”表示，比安培小的单位有毫安（mA）、微安（μA），它们之间的换算关系为

2．电阻​ 导体对电流的阻碍称为该导体的电阻。
​ 电阻通常用字母“R”表示，电阻的单位为欧姆（简称欧），用“Ω”表示，比欧姆大的单位 有千欧（kΩ）、兆欧（MΩ），它们之间的换算关系为

​ 导体的电阻计算公式为

​ L 为导体的长度（单位：m），S 为导体的横截面积（单位：m2），ρ 为导体的电阻率（单位：Ω·m）
​ 在长度 L 和横截面积 S 相同的情况下，电阻率越大的导体其电阻越大
1.1.3 电位、电压和电动势1．电位​ 电源的正极输出电流，流到 A 点，再经 R1 流到 B 点，然后通过 R2 流到 C 点，最后流到电源的负极。
​ 为了表明某点为零基准点，通常在该点处画一个“⊥”符号，该符号称为接地符号，接 地符号处的电位规定为 0V
2．电压​ 电路中的 A 点和 B 点的电位是不同的，有一定的差距，这种电位之间的差距称为电位差，又称电压
​ 因为 A 点和 B 点电位差实际上就是电阻器 R1 两端的电位差（即电压）， R1 两端的电压用 UR1 表示，所以 UAB&#x3D;UR1。
3．电动势​ 电源消耗能量在两极建立的电位差称为电动势，电动势的单位也为伏特
​ 由于电源内部的电流是由负极流向正极，故电源的电动势方向规定为从电源负极指向正极。

1.1.4 电路的 3 种状态
1．通路​ 电路处于通路状态的特点有：电路畅通，有正常的电流流过负载，负载正常工作。
2．开路​ 电路处于开路状态的特点有：电路断开，无电流流过负载，负载不工作。
3．短路​ 电路处于短路状态的特点有：电路中有很大电流流过，但电流不流过负载，负载不工作。
1.1.5 接地与屏蔽1．接地（1）在电路中，接地符号处的电位规定为 0V。
（2）在电路中，标有接地符号的地方都是相通的。

2．屏蔽​ 屏蔽的具体做法是用金属材料（称为屏蔽罩）将元器件或电路封闭起来，再将屏蔽罩接地。
1.1.6 欧姆定律​ 在电路中，流过电阻的电流 I 的大小与电阻两端的电压 U 成正比，与电阻 R 的大小成反比，即

​ 也可以是U&#x3D;IR 或者 R&#x3D;U&#x2F;I 注意：在电路中，某点电压指的是该点与地之间的电压
1.1.7 电功、电功率和焦耳定律1．电功​ 可见电流流过一些用电设备时是会做功的，电流做的功称为电功。

​ W 表示电功，单位为焦（J）；U 表示电压，单位为伏（V）；I 表示电流，单位为安（A）；t 表示时间，单位为秒（s）
2．电功率​ 电功率是指单位时间里电流通过用电设备所做的功。
​ 电功率常用 P 表示，单位为瓦（W），此外还有千瓦（kW）和毫瓦（mW），它们之间的换算关系是

​ 电功率的计算公式是


​ 1kW·h 可以这样理解：一个电功率为 100W 的灯泡连续使用 10h 消耗的电功为 1kW·h，即消耗 1 度电。

3．焦耳定律​ 电流流过导体，导体发出的热量与导体流过的电流、导体的电阻和通电的时间有关。

​ Q 表示热量，单位为焦耳（J）；R 表示电阻，单位为欧姆（Ω）；t 表示时间，单位为秒（s）。
该定律说明：电流流过导体产生的热量，与电流的平方、导体的电阻及通电时间成正比。
1.2 电阻的连接方式1.2.1 电阻的串联
​ 电阻串联电路的特点有以下几个。:
​ ① 流过各串联电阻的电流相等，都为I。
​ ② 电阻串联后的总电阻增大，总电阻等于各串联电阻之和，即R&#x3D;R1+R2
​ ③ 总电压等于各串联电阻上电压之和，即U&#x3D;U1+U2
​ ④ 电阻越大，两端电压越高，因为R1&lt;R2，所以UR1&lt;UR2。
1.2.2 电阻的并联
​ 电阻并联电路的特点有以下几个。
​ ① 并联电阻两端的电压相等，即总电流等于流过各个并联电阻的电流之和，即I&#x3D;I1+I2
​ ③ 电阻并联总电阻减小，总电阻的倒数等于各并联电阻的倒数之 1&#x2F;R&#x3D;1&#x2F;R1+1&#x2F;R2和，即该式子可变形为 R&#x3D;R1R2&#x2F;R1+R2
​ ④ 在并联电路中，电阻越小，流过电阻的电流越大，因为 R1&lt;R2，所以 I1&gt;I2。
1.2.3 电阻的混联
1.3 直流电与交流电1.3.1 直流电​ 直流电是指方向始终固定不变的电压或电流。
1．稳定直流电​ 稳定直流电是指方向固定不变并且大小也不变的直流电。
2．脉动直流电​ 脉动直流电是指方向固定不变，但大小随时间变化的直流电。

1.3.2 交流电​ 交流电是指方向和大小都随时间作周期性变化的电压或电流
1．正弦交流电

2．周期和频率
（1）周期​ 交流电变化过程是不断重复的，交流电重复 变化一次所需的时间称为周期，周期用 T 表示，单位是秒（s）。
（2）频率​ 交流电在每秒钟内重复变化的次数称为频率，频率用 f 表示，它是 周期的倒数，即

该交流电的频率 f&#x3D;50Hz，说明在 1s 内交流电能重复 0 ～ t4 这个过程 50 次。交流电变化越快，变化一次所
需要的时间越短，周期就越短，频率就越高。
（3）高频、中频和低频​ 频率在 3MHz 以上的信号称为高频信号，频率在 300kHz ～ 3MHz 范围内的信 号称为中频信号，频率低于 300kHz 的信号称为低频信号。
3．瞬时值和有效值（1）瞬时值​ 交流电的大小和方向是不断变化的，交流电在某一时刻的值称为 交流电在该时刻的瞬时值。
（2）有效值
所示两个电路中的电热丝完全一样，现分别给电热丝通交流电和直流电，如果两电路通电时间相同，并且电热丝发出热量也相同，对电热丝来说，这里的交流电和直流电是等效的，那么就将图 1-21（b）中直流电的电压值或电流值称为图 1-21（a）中交流电的有效电压值或有效电流值。正弦交流电的有效值与最大瞬时值的关系是

4．相位与相位差（1）相位
​ 交流电在某时刻的角度称为交流电在该时刻的相位。
（2）相位差​ 相位差是指两个同频率交流电的相位之差。

​ 两个交流电存在相位差实际上就是两个交流电变化存在着时间差。
]]></content>
      <categories>
        <category>电子技术</category>
      </categories>
      <tags>
        <tag>电子技术</tag>
      </tags>
  </entry>
  <entry>
    <title>电路基础</title>
    <url>/2023/08/10/%E7%94%B5%E8%B7%AF%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[一、电流、电压、电功率和能量电流：
i 电流   q 电荷量  t时间
电压：
u 电压 w 功 q电荷量
功率：
小结：
二、电流和电压的参考方向







]]></content>
      <categories>
        <category>罗教授电路</category>
      </categories>
      <tags>
        <tag>电路基础</tag>
      </tags>
  </entry>
  <entry>
    <title>疑难杂症</title>
    <url>/2024/02/18/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>报错</category>
      </categories>
  </entry>
  <entry>
    <title>第一章 FreeRTOS 源码</title>
    <url>/2025/04/10/%E7%AC%AC%E4%B8%80%E7%AB%A0%20FreeRTOS%20%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[1.1FreeRTOS目录结构
核心文件有两个：

FreeRTOS&#x2F;Source&#x2F;tasks            必选，任务操作
FreeRTOS&#x2F;Source&#x2F;list.c             必选，列表
FreeRTOS&#x2F;Source&#x2F;queue.c        基本必需，提供队列操作、信号量操作
FreeRTOS&#x2F;Source&#x2F;timer.c          可选，重置事件
FreeRTOS&#x2F;Source&#x2F;event_groups.c         可选，提供时间组（event froup）
FreeRTOS&#x2F;Source&#x2F;croutine.c             可选，过时了

1.2头文件1、FreeRTOSConfig.c
FreeRTOS的配置文件，例如：选择跳读算法 configUSE_PREEMPTION，每个DEMO都必定含有，修改demo的时候是修改这个文件
2、FreeRTOS.h
调用API必需含有此文件，在包含其他头文件例如task.h
3、内存管理
文件放在Middlewares\Third_Party\FreeRTOS\Source\portable\MemMang，放在portable可以提供自己的函数
对于内存管理有5种方法



文件
优点
缺点



heap_1.c
分配简单，时间确定
只分配，不回收


heap_2.c
动态分配、最佳匹配
碎片，时间不定


heap_3.c
调用标准库函数
速度慢、时间不定


heap_4.c
相邻空闲内存可以合并
解决碎片问题，时间不定


heap_5.c
在4的基础上支持分隔的内存块
可解决碎片问题、时间不定


1.3入口函数在main函数中，初始化FreeRTOS、创建任务，启动调度器
/* Init scheduler */osKernelInitialize();  /* 初始化FreeRTOS运行环境 */MX_FREERTOS_Init();    /* 创建任务 *//* Start scheduler */osKernelStart();       /* 启动调度器 */

1.4 数据类型1、在portmacro.h头文件，里面定义了2个数据类型

TickType_t：
FreeRTOS配置了一个周期性的时钟中断：Tick Interrupt
每发生一次中断，中断次数累加，这被称为tick count
tick count这个变量的类型就是TickType_t
TickType_t可以是16位的，也可以是32位的
FreeRTOSConfig.h中定义configUSE_16_BIT_TICKS时，TickType_t就是uint16_t
否则TickType_t就是uint32_t
对于32位架构，建议把TickType_t配置为uint32_t


BaseType_t：
这是该架构最高效的数据类型
32位架构中，它就是uint32_t
16位架构中，它就是uint16_t
8位架构中，它就是uint8_t
BaseType_t通常用作简单的返回值的类型，还有逻辑值，比如pdTRUE&#x2F;pdFALSE



2、变量名

3、函数名

4、宏定义


]]></content>
      <categories>
        <category>RTOS</category>
      </categories>
      <tags>
        <tag>RTOS</tag>
      </tags>
  </entry>
  <entry>
    <title>第一章 数据结构绪论</title>
    <url>/2024/02/28/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA/</url>
    <content><![CDATA[1.基本术语1.1 数据数据：描述客观事物的符号，计算机中可以操作的对象，能被计算机识别并输入计算机处理的符号集合。

1.2数据元素数据元素：组成数据、有一定意义的单位，计算机中通常作为整体处理，也被称为记录。
1.3数据项数据项：一个数据元素可以由若干个数据项组成。
数据项是数据不可分割的最小单位。
1.4 数据对象数据对象：性质相同的数据元素的集合，数据的子集。
性质相同的意思是指数据元素具有相同数量的类型的数据项。如，人都有姓名、生日等数据项。
1.5 数据结构简单来说就是关系，比如分子结构，组成分子的原子之间的排列方式。
严格来说，结构是指各个组成部分相互搭配和排序的方式。
在现实中，不同数据元素之间不是独立的，而是存在特定的关系，称为结构。
数据结构：相互之间存在一种或多种特定关系的数据元素的集合。
1.2 逻辑机构与物理结构逻辑结构是指数据对象中数据元素之间的相互关系。
1.2.1 集合结构（1）集合结构集合结构中数据元素除了同属于一个集合外，它们之间没有其他关系。
（2）线性结构数据元素之间是一对的关系。

（3）树形结构数据元素之间存储一种一对多的层次关系。

（4）图形结构图形结构：数据元素是多对多的关系。

1.2.2 物理结构（存储结构）物理结构：是指数据的逻辑结构在计算机中的存储形式。就是如何把数据元素存储到计算机的存储器中。存储器主要针对内存而言，数据组织通常用文件结构来描述。
（1）顺序存储结构是把数据元素存放在地址连续的存储单元里，数据间的逻辑关系和物理关系是一样的。

（2）链式存储结构是把数据元素存放在任意的存储单元里，这组存储单元是可以连续的，也可以不是连续的。
数据元素的存储关系不能反映逻辑关系，需要一个指针存放数据元素的地址，这一可以通过地址找到数据元素的位置。
逻辑结构是面向问题，物理结构是面向计算机的，基本是讲目标的数据以及逻辑关系存储到计算机的内存中。
1.3 数据类型是一组性质相同的值的集合以及定义在此集合上的一些操作的总称。
1.3.1 数据类型定义在C语言中，按照取值的不同，数据类型可以分为：
原子类型：不可以再分解的基本类型，包括整形、实型、字符型等
结构类型：若干个类型组合而成，是可以再分解的。例如，整型数组是由若干整型数据组成。
比如，定义int a，b，在给变量a，b赋值的时候不能超过int类型的取值范围。
1.3.2 抽象数据类型抽象是指抽取出事物具有普遍性的本质，对一个具体事务的一个概括。
抽象数据类型：一个数学模型以及定义在该模型上的一组操作。
抽象数据类型的定义取决于它的逻辑特性，而在计算机内部如何表示和实现无关。
抽象数据类型的标准格式：

1.4 总结
数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。
结构分类：

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>第一章 计算机系统基础知识</title>
    <url>/2024/02/26/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[第一章 计算机系统基础知识1.1 嵌入式计算机系统概述根据 IEEE 的定义，嵌入式系统是“控制、监视或者辅助设备、机器和车间运行的配置“。
国内的系统定义是：以应用为中心、以计算机技术为基础，软件硬件可裁剪，适应应用系统对功能、可靠性、成本、体积、功耗严格要求的专用计算机系统。
可以认为，是一种专用的计算机系统，作为装置或设备的一部分。通常嵌入式系统是一个控制程序存储在 ROM 中的嵌入式处理器控制板。
1.计算机硬件计算机硬件系统由运算器、控制器、存储器、输入设备和输出设备。通信部件也成为计算机系统基本组件。
中央处理单元：
运算器和控制器和相关部件集成一起，称为中央处理单元（Central Processing Unit，CPU）。用于数据加工、完成算术、逻辑运算以及控制功能。
运算器：
对数据进行加工处理的部件，主要完成算术和逻辑运算。主要功能是从主存中取出指令并进行分析，以控制计算机各个部位完成指令。
存储器：
计算机系统的记忆设备，分为内部存储器，简称内存、主存和外部存储器，简称外存或者辅存。
内存速度快、容量小，用于临时存储计算机运行所需要的程序、数据以及运算结果。
外村容量大、速度慢，用于长期存钱信息。
寄存器：
CPU 存储器件，存放临时少量的数据、运算结果和整在执行的指令，速度快。
主机：
CPU 和主存器的有机组合。
输入&#x2F;输出（I&#x2F;O）：
设备位于主机之外，是计算机系统和外界交换信息的装置。
输入：信息输入计算机中。
输出：运算结果所要求的形式输出到外部设备或存储介质上。
2.计算机软件计算机软件指的是管理、运行、维护以及应用计算机所开发的程序和相关文档的集合。
分为系统软件、中间件和应用软件等类型。
系统软件：
管理系统的硬件和软件资源。
应用软件：
解决应用领域的具体问题。
中间件：
一类独立的系统软件或者服务程序，用来管理计算机资源和网络通信，提供通信处理、数据存取、事务处理、Web 服务、安全，跨平台等服务。
3.计算机分类（1）个人移动设备：带有多媒体用户界面的无线设备，如手机、平板。
（2）桌面计算机：台式计算机，笔记本等。
（3）服务器：服务器代替传统的大型机，主要提供大规模和可靠文件以及计算服务，强调可用性、可扩展性，和很高的吞吐率。
（4）集群&#x2F;仓库级计算机：一组桌面计算机或者服务器用网络连接起来，类似如大型计算机
（5）超级计算机：规格高，性能强大。
（6）嵌入式计算机：针对某个特定的应用，如网络、通信、音频、视频等，对功能、可靠、成本、体积、功耗有严格要求。
1.2 数据表示二进制是计算机采用的一种数制。数值、文字、声音、图形图像等必须经过数值化编码才能被传送、存储和处理。
1.2.1 进位计数制及转换如果只用r个基本符号表示数值，则称其r进制（Radix-r Number System），r称为改数制的基数（Radix）。
不同数制的共同特点：
（1）有固定的符号集，例如。二进制的基本符号0和1。十进制的基本符号为0-9。
（2）数制都是用位置表示法。不同位置的数符代表的值不同，与所在位置的权值有关。如十进制数1234.55表示为：

常用进位数制有二进制、八进制、十进制、十六进制，如图

不同数制的相互转换：
（1）十进制与二进制转换
在二进制中，r&#x3D;2，基本符号为0和1。二进制中的一个0或者1称为1位（bit）。
十进制数转换二进制数，整数部分和小数部分分别转换，然后再合并。
十进制整数转换二进制整数是“除2取余”。
十进制小数转换二进制小数是“乘2取整”。
例如1：十进制175.71875转换二进制数。

十进制数写成二进制数权的大小展开的多显示，从高到低按照各项的系数。

二进制数转成十进制数的方法是：将二进制数的每一位乘以它的权再相加，可以求得对应的十进制数值。
例如2：将二进制100110.101转换成十进制

（2）八进制计数法与十进制、二进制计数法的相互转换
八进制计数制的基本符号是0-7。
十进制转换八进制数的方法：十进制整数采用“除8取余”的方法转换八进制整数。
十进制小数采用“乘8取整”的方法转成八进制小数
]]></content>
      <categories>
        <category>嵌入式设计</category>
      </categories>
      <tags>
        <tag>软考</tag>
      </tags>
  </entry>
  <entry>
    <title>第一章 C数据类型及语句01</title>
    <url>/2023/08/06/%E7%AC%AC%E4%B8%80%E7%AB%A0-C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E8%AF%AD%E5%8F%A501/</url>
    <content><![CDATA[1.1 C 语言的特点1.#include&lt;stdio.h&gt; 头文件包含，一定要有
2.每一个 c 语言的程序有且只有一个 main 函数，这是整个程序的开始位置
3.C 语言中()、[]、{}、“”、’’、都必须成对出现,必须是英文符号
4.C 语言中语句要以分号结束。
5.&#x2F;&#x2F;为注释 &#x2F;* *&#x2F;为多行注释
1.2 关键字1、char 字符型
char ch1 = &#x27;zifu&#x27;;

2、short 短整型 占 2 个字节
short int a = 11; -32768 - ---32767

3、int 整形，在 32 位占 4 个字节，16 位站 2 个
int a = 44; -20 亿---20 亿

4、long 长整型 在 32 位占 4 个字节
long int a = 66;

5、float 单精度浮点型（实数），占 4 个字节
float b = 3.8f;

6、 double 双精度浮点型 （实数），占 8 个字节
double b=3.8;

7、 struct 这个关键字是与结构体类型相关的关键字，可以用它来定义结构体类型
8、 union 这个关键字是与共用体（联合体）相关的关键字
9、 enum 与枚举类型相关的关键字
10、signed 有符号(正负)的意思
//定义cahr，整形数据使用signed修饰，代表数据是有符号的，可以保存整数，复数signed int b = -6;  //关键字可以省略

11、unsigned 无符号的意思
unsigned int a = 101; //只能保存整数和0

12、void 空类型的关键字
//void 是用来修饰函数的参数或者返回值，代表函数没有参数或没有返回值//例：void fun(void)&#123;&#125;//代表 fun 函数没有返回值，fun 函数没有参数

1.1.2 存储相关关键字
1、register 是寄存器的意思，用 register 修饰的变量是寄存器变量（尽量分配存储空间在寄存器中）
(1): 定义的变量不一定真的存放在寄存器中。
(2)：cpu 取数据的时候去寄存器中拿数据比去内存中拿数据要快
(3)：因为寄存器比较宝贵，所以不能定义寄存器数组
(4)：register 只能修饰 字符型及整型的，不能修饰浮点型
(5)：因为 register 修饰的变量可能存放在寄存器中不存放在内存中，所以不能对寄存器变量取地址。因为只有存放在内存中的数据才有地址
register int a;int *p;p = &amp;a; //错误的，a 可能没有地址

2、static 是静态的意思
static 可以修饰全局变量、局部变量、函数
3、const 常量的意思
用 const 修饰的变量是只读的，不能修改它的值（可以修改指针）
4、auto int a;和 int a 是等价的，auto 关键字现在基本不用
5、extern 是外部的意思，一般用于函数和全局变量的声明
1.1.3 控制语句相关的关键字if 、else 、break、continue、for 、while、do、switch case、goto、default
1.1.4 其他关键字1、sizeof
使用来测变量、数组的占用存储空间的大小（字节数）
例 3：
int a=10;int num;num=sizeof(a);

2、typedef 重命名相关的关键字
关键字 ，作用是给一个已有的类型，重新起个类型名，并没有创造一个新的类型
以前大家看程序的时候见过类似的变量定义方法
INT16 a;
U8 ch;
INT32 b
3、volatile 易改变的意思
用 volatile 定义的变量，是易改变的，即告诉 cpu 每次用 volatile 变量的时候，重新去内存中取 。保证用的是最新的值,而不是寄存器中的备份。
//volatile 关键字现在较少适用volatile int a=10;
]]></content>
      <categories>
        <category>千锋C语言</category>
      </categories>
      <tags>
        <tag>嵌入式C</tag>
      </tags>
  </entry>
  <entry>
    <title>第一章 C数据类型及语句02</title>
    <url>/2023/08/06/%E7%AC%AC%E4%B8%80%E7%AB%A0-C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E8%AF%AD%E5%8F%A502/</url>
    <content><![CDATA[1.2 数据类型1.2.1 基本类型
char 、short int 、int、long int、float、double
1.2.2 构造类型
由若干个相同或不同类型数据构成的集合，这种数据类型被称为构造类型
int a[10];

格式化输出字符：
%d 十进制有符号整数
%ld 十进制 long 有符号整数
%u 十进制无符号整数
%o 以八进制表示的整数
%x 以十六进制表示的整数
%f float 型浮点数
%lf double 型浮点数
%e 指数形式的浮点数
%c 单个字符
%s 字符串
%p 指针的值
特殊应用：
%3d 要求宽度为 3 位，如果不足 3 位，前面空格补齐;如果足够 3 位，此语句无效
%03d 要求宽度为 3 位，如果不足 3 位，前面 0 补齐;如果足够 3 位，此语句无效
%-3d 要求宽度为 3 位，如果不足 3 位，后面空格补齐;如果足够 3 位，此语句无效
%.2f 小数点后只保留 2 位
1.2.3 类型转换
自动转换:
遵循一定的规则,由编译系统自动完成.
强制类型转换：
把表达式的运算结果强制转换成所需的数据类型
自动转换的原则：
1、 占用内存字节数少(值域小)的类型，向占用内存字节数多(值域大)的类型转换,以保证精度不降低.
2、 转换方向:

1.2.4 指针
1.3 运算符1.3.1 运算符
用运算符将运算对象(也称操作数）连接起来的、符合Ｃ语法规则的式子，称为Ｃ表达式运算对象包括常量、变量、函数等
1.3.2 运算符的分类：
1、双目运算符：即参加运算的操作数有两个
例： +
​ a+b
2、单目运算符：参加运算的操作数只有一个
​ ++自增运算符 给变量值+1
​ –自减运算符
​ int a&#x3D;10;
​ a++;
3、三目运算符:即参加运算的操作数有 3 个
()?():()
1.3.3 算数运算符
+ - _ &#x2F; % +&#x3D; -&#x3D; _&#x3D; &#x2F;&#x3D; %&#x3D;
1.3.4 关系运算符
（＞、＜、&#x3D; &#x3D;、&gt;&#x3D;、&lt;&#x3D;、!&#x3D; ）
1.3.5 逻辑运算符
1、&amp;&amp; 逻辑与
两个条件都为真，则结果为真
if((a&gt;b) &amp;&amp; (a&lt;c))
2、|| 逻辑或
两个条件至少有一个为真，则结果为真
if((a&gt;b) || (a&lt;c))
3、! 逻辑非
if(!(a&gt;b))
{
}
1.3.6 位运算符
1、&amp;按位与
任何值与 0 得 0，与 1 保持不变
使某位清 0
0101 1011 &amp;
1011 0100
0001 0000
2、| 按位或
任何值或 1 得 1，或 0 保持不变
0101 0011 |
1011 0100
1111 0111
3、~ 按位取反
1 变 0，0 变 1
0101 1101 ~
1010 0010
4、^ 按位异或
相异得 1，相同得 0
1001 1100 ^
0101 1010
1100 0110
5、位移
&gt;&gt;右移
&lt;&lt; 左移
注意右移分：逻辑右移、算数右移
（1）右移
​ 逻辑右移 高位补 0 低位溢出
​ 算数右移 高位补符号位，低位溢出
（2）、左移**&lt;&lt; 高位溢出，低位补 0
​ 5&lt;&lt;1
1.3.7 条件运算符号
()?():()A?B:C;如果？前边的表达式成立，整个表达式的值，是？和：之&#x2F;&#x2F;间的表达式的结果否则是：之后的表达式的结果
1.3.8 逗号运算符
(… , … , …)
例如：A &#x3D; (B , C , D)
1.3.9 自增自减运算符
++ ++i 先加 ，后用
--
i++ i–
1.3.10 运算符优先级表

1.4 控制语句相关关键字
1、 if 语句
形式：

if(条件表达式)

{ &#x2F;&#x2F;复合语句，若干条语句的集合
语句 1;
语句 2；
}
如果条件成立执行大括号里的所有语句，不成立的话大括号里的语句不执行
#include &lt;stdio.h&gt;int main()&#123;	int a=10;	if(a&gt;5)	&#123;		printf(&quot;a&gt;5\n&quot;);	&#125;	return 0;&#125;


if(条件表达式)

{
语句块 1
}
else
{
语句块 2
}
if else 语句的作用是，如果 if 的条件成立，执行 if 后面{}内的语句，否则执行 else 后的语句
#include &lt;stdio.h&gt;int main()&#123;	int a=10;	if(a&gt;5)	&#123;		printf(&quot;a&gt;5\n&quot;);	&#125;	else	&#123;		printf(&quot;a&lt;=5\n&quot;);	&#125;	return 0;	&#125;


if(条件表达式)

{
}
else if(条件表达式)
{
}
else if(条件表达式)
{
}
else
{
}
在判断的时候，从上往下判断，一旦有成立的表达式，执行对应的复合语句， 下边的就不再判断了，各个条件判断是互斥的
#include &lt;stdio.h&gt;int main(void)&#123;	char ch;	float score = 0;	printf(&quot;请输入学生分数:\n&quot;);	scanf(&quot;%f&quot;,&amp;score);	if(score&lt;0 || score &gt;100)	&#123;		printf(&quot;你所输入的信息有错\n&quot;);		return 0;	&#125;	else if( score&lt;60)	&#123;		ch = &#x27;E&#x27;;	&#125;	else if ( score &lt; 70 )	&#123;		ch = &#x27;D&#x27;;	&#125;	else if ( score &lt; 80 )	&#123;		ch = &#x27;C&#x27;;	&#125;	else if ( score &lt; 90 )	&#123;		ch = &#x27;B&#x27;;	&#125;	else	&#123;		ch = &#x27;A&#x27;;	&#125;	printf(&quot;成绩评定为：%c\n&quot;,ch);	return 0;	&#125;

2、 switch 语句
switch（表达式）&#x2F;&#x2F;表达式只能是字符型或整型的(short int int long int)
{
case 常量表达式 1：
语句 1；
break；
case 常量表达式 2：
语句 2;
break；
default：
语句 3；
break;
}
#include &lt;stdio.h&gt;int main(int argc, char *argv[])&#123;	int n;	printf(&quot;请输入一个 1~7 的数\n&quot;);	scanf(&quot;%d&quot;,&amp;n);	switch(n)	&#123;		case 1:			printf(&quot;星期一\n&quot;);			break;		case 2:			printf(&quot;星期二\n&quot;);			break;		case 3:			printf(&quot;星期三\n&quot;);			break;		case 4:			printf(&quot;星期四\n&quot;);			break;		case 5:			printf(&quot;星期五\n&quot;);			break;		case 6:			printf(&quot;星期六\n&quot;);			break;		case 7:			printf(&quot;星期天\n&quot;);			break;		default:			printf(&quot;您的输入有误，请输入 1~7 的数\n&quot;);			break;	&#125;		return 0

1.4.2 循环控制语句相关的关键字
1、 for 循环
for(表达式 1;表达式 2;表达式 3)
{&#x2F;&#x2F;复合语句，循环体
}
第一次进入循环的时候执行表达式 1，表达式 1 只干一次，
表达式 2，是循环的条件，只有表达式 2 为真了，才执行循环体，也就是说
每次进入循环体之前要判断表达式 2 是否为真。
每次执行完循环体后，首先执行表达式 3
#include &lt;stdio.h&gt;int main(void)&#123;	int i;	int sum=0;	for(i=1;i&lt;=100;i++)	&#123;		sum = sum+i;	&#125;		printf(&quot;sum=%d\n&quot;,sum);		return 0;	&#125;//例 26：#include &lt;stdio.h&gt;int main(int argc, char *argv[])&#123;	int i,j;	for(i=1;i&lt;=9;i++)	&#123;	for(j=1;j&lt;=i;j++)	&#123;		printf(&quot;%d*%d=%d &quot;,i,j,i*j);	&#125;		printf(&quot;\n&quot;);	&#125;		return 0;	&#125;

2、 while 循环

形式 1：

while(条件表达式)
{&#x2F;&#x2F;循环体，复合语句
}
进入 while 循环的时候，首先会判断条件表达式是否为真，为真进入循环体，否则退出循环
#include &lt;stdio.h&gt;int main(void)&#123;/* 2) 形式 1：while(条件表达式)&#123;//循环体，复合语句&#125;*/	int i=1;	int sum=0;	while(i&lt;=100)	&#123;		sum = sum+i;		i++;	&#125;		printf(&quot;sum=%d\n&quot;,sum);	return 0;&#125;


形式 2 ： do

do{&#x2F;&#x2F;循环体
}while(条件表达式);
先执行循环体里的代码，然后去判断条件表达式是否为真，为真再次执行循环体，否则退出循环
#include &lt;stdio.h&gt;int main(void)&#123;	int i=1;	int sum=0;	do	&#123;		sum = sum+i;		i++;	&#125;while(i&lt;=100);		printf(&quot;sum=%d\n&quot;,sum);	return 0;&#125;

形式 1 和形式 2 的区别是，形式 1 先判断在执行循环体，形式 2 先执行循环体，再判断
break 跳出循环
continue 结束本次循环，进入下一次循环
#include &lt;stdio.h&gt;int main(void)	&#123;		int i;		int sum=0;	for(i=1;i&lt;=100;i++)	&#123;		if(i==10)		break;//将 break 修改成 continue 看效果		sum = sum+i;	&#125;		printf(&quot;sum=%d\n&quot;,sum);		return 0;	&#125;	return 0;//返回函数的意思。结束 return 所在的函数，//在普通函数中，返回到被调用处，在 main 函数中的话，结束程序

3、 goto
#include &lt;stdio.h&gt;int main(int argc, char *argv[])&#123;	printf(&quot;test000000000000000000\n&quot;);	printf(&quot;test1111111111111111\n&quot;);	goto xiutao;	printf(&quot;test222222222222222222\n&quot;);	printf(&quot;test3333333333333333\n&quot;);	printf(&quot;test444444444444444444444\n&quot;);	printf(&quot;test55555555555555555555\n&quot;);	xiutao:	printf(&quot;test66666666666666666\n&quot;);	return 0;&#125;
]]></content>
      <categories>
        <category>千锋C语言</category>
      </categories>
      <tags>
        <tag>嵌入式C</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql数据库</title>
    <url>/2023/08/29/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E4%BA%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[一、了解 SQL1、什么是数据库数据库是以某种组织的方式存储的数据集合。
数据库（database）保存有组织的数据的容器（一个文件或者一组文件）
更准确的来说，数据库软件称为数据库管理系统（DBMS）。通过 DBMS 创建和操作的容器
2、什么是表表 是一种结构化的文件，用来存储某种特定类型的数据。
3、什么是模式模式 关于数据库和表的布局以及特性的信息。
4、列和数据类型表是由列组成。列中存储这表中某种部分的信息。
列 表中的一个字段。所有表都是由一个或多个列组成的。
数据类型 所容许的数据的类型。每个字段都有相应的数据类型。
5、行表中的数据都是按行存储的，保存的记录存储在自己的行内。
行 表中的一个记录。
6、主键主键（又称键码、码） 一列（一组列），其值能够唯一区分表中的每个行。
满足条件：
任意两行都不具有相同的主键值。
每个行都必须具有一个主键值（主键列不允许 null 值）
二、了解 mysql一、客户机-服务器软件MySQL、Oracle 以及 Microsoft SQL Server 等数据库是基于客户机—服务器的数据库
DBMS（数据库管理系统）可以分为两类：
（1）基于共享文件系统的 DBMS（2）基于客户机-服务器的 DBMS

与数据文件打交道的只有服务器软件。关于数据、数据添加、删除和数据更新的所有请求都是由服务器软件完成。
客户机是与用户打交道的软件。例如：请求一个按字母顺序列出的产品表，则客户机软件通过网阔提交该请求给服务器软件。服务器软件处理这个请求，根据需求过滤、丢弃和排序数据，然后送回客户机软件。

三、排序索检数据一、子句有些字句是必需，有一些是可选的。一个子句通常由一个关键字和所提供的数据组成。
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>第一章-初识STM32</title>
    <url>/2023/08/17/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%88%9D%E8%AF%86STM32/</url>
    <content><![CDATA[一、芯片里面有什么1.片上外设
内核之外的部件叫核外外设或片上外设。GPIO，USART、I2C、SPI 都叫做片上外设。

芯片内核和外设之间，有总线连接，主控总线有 8 条，被控总线有 7 条。
2、寄存器映射
给存储器分配地址的过程称为存储器映射。如果是给吹气球再分配一个地址叫存储器重映射。
3、存储器区域功能划分

（1）BLock0 功能划分

（2）Block1 功能划分

（3）Block2 功能划分

二、寄存器以功能为名给这个内存单位取一个别名，这个别名就是我们经常说的寄存器，分配好地址的特定功能的内存单元取别名的过程叫做寄存器映射
如何理解寄存器

1、名称 (GPIOx_BSRR)(x&#x3D;A…I)
该寄存器名为(GPIOx_BSRR)(x&#x3D;A…I)，其中 x 可以为 A-I，适用于 GPIOA、GPIOB 到 GPIOU
2、偏移地址，寄存器相对这个外设的基地址的编译
寄存器的编译地址是 0x18，可以查到 GPIOA 外设的基地址是 0x4002 0000，GPIOx_BSRR 寄存器地址为，0x4002 0000+0x18
3、寄存器位表
0-31 的名称以及权限。最上方是位编号，中间位名称，最下方是读写权限，w 只写，r 只读，rw 可读写
4、位功能说明
BRy 及 BSy，其中的 y 数值可以是 0-15，这里的 0-15 表示端口的引脚号， 如 BR0、BS0 用于控制 GPIOx 的第 0 个引脚，若 x 表示 GPIOA，那就是控制 GPIOA 的第 0 引脚， 而 BR1、BS1 就是控制 GPIOA 第 1 个引脚。
其中，“复位”是将该位设置为 0 的意思，而“置位”表示将该位设置为 1；如果对 BR0 写入“
1”的话，那么 GPIOx 的第 0 个引脚就会输出“低电平”，但是对
BR0 写入“0”的话，却不会影响 ODR0 位，所以引脚电平不会改变。要想该引脚输出“高电平”， 就需要对“BS0”位写入“1”，寄存器位 BSy 与 BRy 是相反的操作
三、C 语言对寄存器的封装总线基地址和外设基地址都以相应的宏定义起来，总线或者外设都以他们的名字作为宏名
四、STM32 分类
五、STM32 命名方法以 STM32F407ZGT6 来讲解
家族：32bit 的 MCU
产品类型：F 表示基础型
引脚数：Z 表示 144pin，C 为 48，R 为 64，V 为 100，Z 为 144，B 为 208，N216
FLASH：G 表示 1024KB,C 表示 256，E 表示 512，I 表示 2048
封装：T 表示 QFP 封装最常用的封装
温度：6 表示等级为 A：-40~85°

]]></content>
      <categories>
        <category>野火STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>第一章 电路模型和电路定律</title>
    <url>/2023/09/09/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%94%B5%E8%B7%AF%E6%A8%A1%E5%9E%8B%E5%92%8C%E7%94%B5%E8%B7%AF%E5%AE%9A%E5%BE%8B/</url>
    <content><![CDATA[1.1 电路和电路模型实际电路：由电工设备和电气器件按预期目的连接构成的电路的通路。
功能：a 能量的传输、分配与转换
​              b 信息的传递、控制与处理
共性：建立在痛一电路理论的基础上。
1.1.1 电路模型
电路模型：反应实际电路部件的主要电磁性质的理想电路元件以及组合
理想电路元件：由某种确定的电磁性能的理想元件。
电阻元件：表示消耗电能的元件
电感元件：表示产生磁场，存储磁场能量的元件
电容元件：表示产生电场，存储电厂能量的元件
电压源与电流源：表示将其它形式的能量转变成电能的元件
注意：


1.2电流和电压的参考方向电路中的主要物理量由电压、电流、电荷、磁链、能量、电功率等。在线性电路分析中，主要关心的物理量是电路、电压和功率。
1.电流的参考方向电流：带电粒子由规则运动的定向运动
电流强度：单位时间内通过导体横截面的电荷量











]]></content>
      <categories>
        <category>电路原理、电工学</category>
      </categories>
      <tags>
        <tag>电路和电路模型</tag>
      </tags>
  </entry>
  <entry>
    <title>第七章 启动文件详解</title>
    <url>/2024/03/03/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[7.1启动文件介绍1、初始化堆栈指针 SP&#x3D;_initial_sp
2、初始化PC指针  &#x3D;Rest_Handler
3、初始化中断向量表
4、配置系统时钟
5、调用C库函数_main初始化用户堆栈，调用main函数
7.2 ARM汇编指令EQU：给数字常量去一个富豪们，相当于C语言的define
AREA：汇编一个新的代码段或者数据段
SPACE：分配内存空间
PRE-SERVE8：当前文件堆栈按照8位字节对齐
EX-PORT：声明一个符号具有全局属性，可被外部的文件使用
DCD：字节单位分配，要求4字节对齐，要去初始化这些内存
PROC：定义子程序，与ENDP成对使用，表示子程序结束
WEAK：弱定义，如果外部文件声明了一个标号，则优先使用外部文件定义的标号，如果外部文件没有定义也不出错。要注意的是：这个不是 ARM 的指令，是编译器的，这里放在一起只是为了方便。
IM-PORT：跳转到一个符号
ALIGN：编译器对指令或者数据的存放地址进行对齐，一般需要跟一个立即数，缺省表示 4 字节对齐要注意的是：这个不是 ARM 的指令，是编译器的，这里放在一起只是为了方便。
END：到达文件的末尾，文件结束
IF,ELSE,ENDIF：汇编条件分子语句，跟c语言的if else如此
7.3 启动文件代码讲解7.3.1 Stack栈Stack_Size     EQU 0x00000400 //开辟栈的大小为0X00000400（1KB）               AREA STACK, NOINIT, READWRITE, ALIGN=3              //名字为STACK      可读写       8（2^3）Stack_Mem      SPACE Stack_Size   //分配内存空间，单位 字节，这里指定大小为Strack_Size__initial_sp  //栈的结束地址，由高向低生长

栈的作用是用于局部变量，函数调用，函数形参等开销，栈的大小不能超过内部SRAM的大小，超过要修改栈的大小。
7.3.2 Heap堆Heap\_Size EQU 0x00000200    //开辟堆大小0X00000200（512字节）   AREA HEAP, NOINIT, READWRITE, ALIGN=3   //名字     不初始化，可读写，8（2^3）\_\_heap\_base  //堆的起始地址          Heap_Mem SPACE Heap_Size__heap_limit    //堆的结束地址       堆由低到高生长和栈相反

堆用来动态内存的分配，像malloc()函数申请的内存就在堆上面
7.3.3 向量表AREA RESET, DATA, READONLY//定义数据段为RESET 可读，生命三个标号具有全局属性，可供外部文件调用EXPORT __VectorsEXPORT __Vectors_EndEXPORT __Vectors_Size

__Vectors 为向量表起始地址，__Vectors_End 为向量表结束地址，两个相减即可算出向量表大小
7.3.4 复位程序AREA |.text|, CODE, READONLY//定义一个名称为.text 的代码段，可读。.textReset_Handler PROCEXPORT Reset_Handler [WEAK]IMPORT SystemInitIMPORT __mainLDR R0, =SystemInitBLX R0LDR R0, =__mainBX R0ENDP

复位子程序是系统上电后第一个执行的程序，调用 SystemInit 函数初始化系统时钟，然后调用 C库函数 _mian，最终调用 main 函数去到 C 的世界。
SystemInit() 是一个标准的库函数，在 system_stm32f103xe.c 这个库文件中定义。主要作用是配置系统时钟，这里调用这个函数之后，单片机的系统时钟配被配置为 72M。
__main 是一个标准的 C 库函数，主要作用是初始化用户堆栈。
7.3.5 中断服务程序NMI_Handler PROC ; 系统异常      EXPORT NMI_Handler [WEAK]      B .      ENDP; 限于篇幅，中间代码省略SysTick_Handler PROC      EXPORT SysTick_Handler [WEAK]      B .      ENDPDefault_Handler PROC ; 外部中断      EXPORT WWDG_IRQHandler [WEAK]      EXPORT PVD_IRQHandler [WEAK]      EXPORT TAMP_STAMP_IRQHandler [WEAK]; 限于篇幅，中间代码省略LTDC_IRQHandlerLTDC_ER_IRQHandlerDMA2D_IRQHandler      B .      ENDP

B：跳转到一个标号。这里跳转到一个‘.’，即表示无线循环。
7.3.6 用户堆栈初始化ALIGN：对指令或者数据存放的地址进行对齐，后面会跟一个立即数。缺省表示 4 字节对齐。
; 用户栈和堆初始化, 由 C 库函数_main 来完成IF : DEF :__MICROLIB ; 这个宏在 KEIL 里面开启EXPORT __initial_spEXPORT __heap_baseEXPORT __heap_limitELSE  IMPORT __use_two_region_memory ; 这个函数由用户自己实现  EXPORT __user_initial_stackheap  __user_initial_stackheap  LDR R0, = Heap_Mem  LDR R1, =(Stack_Mem + Stack_Size)  LDR R2, = (Heap_Mem + Heap_Size)  LDR R3, = Stack_Mem  BX LR  ALIGN  ENDIF  END


首先判断是否定义了 __MICROLIB，如果定义了这个宏则赋予标号 __initial_sp（栈顶地址）、__heap_base（堆起始地址）、__heap_limit（堆结束地址）全局属性，可供外部文件调用。
]]></content>
      <categories>
        <category>野火 STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>第三章 线性表</title>
    <url>/2024/09/09/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    <content><![CDATA[1.线性表的定义线性表：零个或多个数据元素的有限序列。
它是一个序列。如果有多个元素，则第一个元素无前驱，最后一个元素无后继，其他的每一个元素只有一个前驱和后继。
将线性表记为 a1，a2，a3，则a1是a2的直接前驱元素，a3是a2的直接后继元素。有且仅仅只有一个直接前驱和一个直接后继。
所以线性表元素的个数n(n≥0)定义为线性表的长度，当n＝0，为空表。
在非空表中的每个元素都有一个确定的位置，比如a1是第一个，a3是最后一个。a2是第二个，称2为数据元素a2在线性表中的位序。
2.线性表的抽象数据类型当传递一个参数给函数的时候，这个参数会不会在函数内被改动决定了使用什么参数形式。
如果需要被改动，则需要传递指向这个参数的指针。
如果不用被改动可以直接传递这个参数。
总结：需要改动则传递参数的指针，不需要则传递这个参数。
3.线性表的顺序存储结构顺序存储结构线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。
说白了就是：在内存中，占个地方，通过占位的形式，将一定的内存空间给占，然后把相同数据类型的数据元素一次存放在这里。
使用一维数组来实现顺序存储结构

数据长度与线性表长度的区别数组的长度是存放线性表的存储空间长度。
线性表的长度是线性表中数据元素的个数，会变化。
地址计算方法C语言中的数组是从0开始为第一个下标。所以线性表的第i个元素是要存储在数组下标为i-1的位置。
存储器中的每个存储单元都有自己的编号，这个编号为地址。
假设占用的是c个存储单元，那么线性表中第i+1个数据元素的存储位置和第i个数据元素的存储位置满足以下关系（LOC表示获得存储位置的函数）

例如：如果LOC(1)为第一个元素的地址，每个元素占用4个存储单元，即C&#x3D;4，那么第二个元素LOC(2)，就是LOC(1)+4
所以对于第i个数据元素ai的存储位置可以得出ai：


4.顺序存储结构的插入与删除获得元素操作// 定义两个宏，分别表示函数执行成功和失败的状态#define OK 1#define ERROR 0// 定义一个新的类型名Status，它实际上就是int类型typedef int Status;// 函数声明：从顺序表L中获取第i个位置的元素，并将其赋值给变量e// SqList L:顺序表结构体// int i:表示获取元素的位置，也就是索引// ElemType *e:这是一个指针，用于存放获取到的元素。Status GetElem(SqList L, int i, ElemType *e) &#123;    // 检查i是否在合法范围内，即i大于0且小于等于顺序表的长度    if (i &lt; 1 || i &gt; L.length) &#123;        // 如果i不合法，返回错误状态ERROR        return ERROR;    &#125;    // 如果i合法，将第i个位置的元素赋值给e指向的变量    // 注意：由于数组索引是从0开始的，所以第i个元素实际上是L.data[i-1]    *e = L.data[i - 1];    // 返回成功状态OK    return OK;&#125;

插入操作// 函数声明，用于在顺序表L中第i个位置插入元素e，并返回操作状态Status ListInsert(SqList *L, int i, ElemType e) &#123;    int k;    // 检查顺序表是否已满，如果已满，返回错误状态    if (L-&gt;length == MAXSIZE) return ERROR;    // 检查插入位置i是否合法，如果不合法（小于1或大于顺序表长度+1），返回错误状态    if (i &lt; 1 || i &gt; L-&gt;length + 1) return ERROR;    // 如果插入位置不在表尾    if (i &lt;= L-&gt;length) &#123;        // 从最后一个元素开始，直到要插入的位置，将每个元素向后移动一位        for (k = L-&gt;length - 1; k &gt;= i - 1; k--) &#123;            // 将元素向后移动            L-&gt;data[k + 1] = L-&gt;data[k];        &#125;    &#125;    // 将新元素e插入到位置i-1（因为数组索引从0开始）    L-&gt;data[i - 1] = e;    // 顺序表长度增加1    L-&gt;length++;    // 插入成功，返回成功状态    return OK;&#125;

删除操作// 函数声明，从顺序表L中删除第i个位置的元素，并通过e返回该元素的值，函数返回操作状态Status ListDelete(SqList *L, int i, ElemType *e)&#123;    int k;    // 检查顺序表是否为空，如果为空，返回错误状态    if(L-&gt;length == 0) return ERROR;     // 检查删除位置i是否正确，即i是否在1到L-&gt;length的范围内，如果不正确，返回错误状态    if(i &lt; 1 || i &gt; L-&gt;length) return ERROR;     // 将要删除的元素赋值给*e，即通过指针e返回被删除元素的值    *e = L-&gt;data[i-1];    // 如果删除的位置不是最后一个元素，则需要将后续元素前移    if(i &lt; L-&gt;length)&#123;        for(k = i; k &lt; L-&gt;length; k++)&#123;            // 将位置k的元素前移到位置k-1            L-&gt;data[k-1] = L-&gt;data[k];        &#125;    &#125;    // 顺序表的长度减1，因为已经删除了一个元素    L-&gt;length--;    // 如果删除操作成功，返回OK    return OK;&#125;

线性表顺序存储结构的优缺点
5.线性表的链式存储结构顺序存储结构不足的解决办法缺点：插入和删除需要移动大量元素
线性表链式存储结构定义特点：用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续，也可以不是连续。
存储数据元素信息的域称为数据域，存储直接后继位置的域称为指针域。
指针域存储的信息称为指针或链。这两部分信息组成数据元素ai的存储映像，为结点。
n个结点（ai的存储映像）链结成一个链表，即为线性表的链式存储结构，因此链表的每个节点只包含每个指针域，称为单链表。
单链表：通过每个节点的指针将线性表的数据元素按照逻辑次序链接在一起。

链表中第一个节点的存储位置叫做头指针，所以整个链表的存储从头指针开始。之后的每一个节点，就是上一个后继指针指向的位置。最后一个，直接后继不存储，所以线性链表的最后一个节点指针为“NULL”。

为了方便会在单链表的第一个节点前设一个头节点。

头指针与头节点的区别
线性表链式存储结构代码描述若线性表为空，则头节点的指针域为空


带有头节点的单链表，如下

空链表如下

// 定义链表节点结构体typedef struct None &#123;    int data;             // 数据域    struct None *next;    // 指向下一个节点的指针&#125; Node;                   // 使用 Node 作为别名typedef struct None *Link;  // 定义指向 Node 的指针类型 Link

从代码中来看：
结点由存放数据元素的数据域，存放后继节点地址的指针域组成。

单链表的读取算法思路：
（1）声明一个指针p指向链表的第一个结点，初始化j从1开始。
（2）当j&lt;i时，遍历链表，让p的指针向后移动，不断指向下一结点，j累加i。
（3）若到链表末尾p为空，则说明第i个结点不存。
（4）否则查找成功，返回结点p的数据。
static GetElem(LinkList L, int i, ElemType *e)&#123;    int j;  //声明结点p    p = L-&gt;next; //让p指向链表L的第一个结点    j = 1; //j为计数器    while (p &amp;&amp; j &lt; i)  //p不为空或计算器j还没有等于i时，循环继续    &#123;        p = p-&gt;next;  //让p指向下一个结点        j++;    &#125;    if (!p || j &gt; i)    &#123;        return ERROR;  //第i个不存在    &#125;    *e = p-&gt;data;  //读取第i个元素的数据    return OK;&#125;// ||：一个为真，则都为真 &amp;&amp;：要两个都为真

单链表的插入与删除插入算法思路（1）声明一个指针p指向链表头结点，初始化j从1开始。
（2）当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1；
（3）若到链表末尾p为空，则说明第i个结点不存在。
（4）否则查找成功，在系统中生成一个空结点s。
（5）将数据元素e赋值给s-&gt;data。
（6）单链表的插入标准语句s-&gt;next &#x3D; p-&gt;next; p-&gt;next &#x3D; s;
（7）返回成功。
static GetElem(LinkList L, int i, ElemType *e)&#123;    int j;    LinkList p = L-&gt;next;  // 假设 L 是头结点，p 指向第一个数据结点    j = 1;                 // 初始化计数器，从第 1 个结点开始    while (p &amp;&amp; j &lt; i)      // 遍历链表，直到找到第 i 个结点    &#123;        p = p-&gt;next;        j++;    &#125;    if (!p || j &gt; i)       // 如果链表为空或者 j 超过了 i，返回错误    &#123;        return ERROR;    &#125;      // 插入新结点    LinkList s = (LinkList)malloc(sizeof(Node));  // 为新结点分配内存    s-&gt;data = e;          s-&gt;next = p-&gt;next;       // 将p的后继结点赋值给s的后继    p-&gt;next = s;             // 将s赋值给p的后继    return OK;&#125;

删除算法思路（1）声明一个指针p指向链表头结点，初始化j从1开始。
（2）当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1；
（3）若到链表末尾p为空，则说明第i个结点不存在。
（4）否则查找成功，将要删除的结点p-&gt;next赋值给q。
（5）单链表的删除标准语句p-&gt;next &#x3D;  q-&gt;next。
（6）将q结点中的数据赋值给e，作为返回
（7）释放q结点。
（8）返回成功。
static GetElem(LinkList L, int i, ElemType *e)&#123;    int j;    p = L-&gt;next;  // 初始化 p 指针，指向链表的第一个节点    j = 1;        // 从第 1 个节点开始计数    while (p &amp;&amp; j &lt; i)  // 遍历链表，找到第 i 个节点的前一个节点    &#123;        p = p-&gt;next;        j++;    &#125;    if (!p || j &gt; i)  // 如果链表长度不足 i，或者 j 超过 i，返回错误    &#123;        return ERROR;    &#125;    q = p-&gt;next;  // 找到要删除的节点 q（即第 i 个节点）    p-&gt;next = q-&gt;next;  // 让 p 的后继指针跳过 q，指向 q 的后继节点    *e = q-&gt;data;  // 将要删除的节点 q 的数据保存到 e 中    free(q);  // 释放被删除节点 q 所占的内存    return OK;  // 返回成功&#125;

单链表的整表创建（1）声明一个指针p和计算器变量i。
（2）初始化一空链表L。
（3）让L的头结点的指针指向NULL，建立一个带头结点的单链表。
（4）循环。
1、生成一个新节点赋值给p。
2、随机生成一个数字赋值给p的数据域p-&gt;data。
3、将p插入到头结点与前一新结点之间。
static GetElem(LinkList L, int i, ElemType *e)&#123;    LinkList p;               // 定义一个指针 p 用于遍历链表    int i;                    // 定义计数器 i（注意：与外部函数参数 i 冲突）    srand(time(0));           // 初始化随机数种子，确保每次运行时生成不同的随机数      *L = (LinkList)malloc(sizeof(LNode));  // 为头节点分配内存    (*L)-&gt;next = NULL;        // 将头节点的后继指针设为 NULL，表示链表初始化为空      for (i = 0; i &lt; n; i++)   // 循环生成 n 个节点    &#123;        p = (LinkList)malloc(sizeof(LNode));  // 为新节点 p 分配内存        p-&gt;data = rand() % 100 + 1;           // 生成 1 到 100 之间的随机数，并赋给 p-&gt;data        p-&gt;next = (*L)-&gt;next;   // 将当前链表的第一个节点赋值为 p 的后继        (*L)-&gt;next = p;         // 将 p 插入到头节点之后    &#125;&#125;

循环链表循环链表和单链表的差异是p-&gt;netx是判断是否为空，循环链表的判断是p-&gt;next不等于头结点。

P = rearA -&gt; next;          //保存A表的头结点，1点rearA -&gt; next = rearB -&gt; next -&gt; next;  //将本是指向B表的第一个结点（不是头结点）q = rearB -&gt; next;   rearB -&gt; next = p;          //赋值给rearA-&gt;next,2点free(q);                    //释放q   

双向链表双向链表：是在单链表的每个节点中，在设置一个指向前驱结点的指针域。
typedef struct DulNode&#123;        ElemType data;        struct DuLNode *prior;     //直接前驱指针        struct DuLNone *next;      //直接后继指针&#125;DulNode,*DuLinkList;

总结


]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>第三章-函数</title>
    <url>/2023/08/10/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[一、函数的概念函数是 c 语言的功能单位，实现一个功能可以封装一个函数来实现。
定义函数的时候一切以功能为目的，根据功能去定函数的参数和返回值。
二、函数的分类1、定义角度分类1、库函数 2、自定义函数 3、系统调用
2、参数角度分类1、有参函数
​ 函数有形参，可以是一个，也可以是多个，类型随便
例如：
int fun(int a.float b.double c)&#123;&#125;int max(int x,int y)&#123;&#125;

2、无参函数
函数没有参数，在形参列表的位置写 void 或者不写
int fun(void)&#123;&#125;int fun()&#123;&#125;

3、返回值角度分类
（1）带返回值的函数
在定义函数的时候，必须带有返回值类型，在函数题，必须有 return，没有返回值类型，默认返回值整形
例如：
char fun() //定义一个返回字符数据的函数&#123;	char b = &#x27;a&#x27;;	return b;&#125;

fun()&#123;	return 1;&#125;

（2）没有返回值的函数
在定义函数的时候，函数名字前面加个 void
void fun(形参表)&#123;	;	;	return ;	;&#125;

在函数中不需要 return，如果想结束函数，返回到被调用的地方，return ;什么都不返回
#include &lt;stido.h&gt;int main(int x,int y)&#123;    int z;    if(x&gt;y)        z=x;    else        z=y;    return z;&#125;void help(void)&#123;    printf(&quot;*********************\n&quot;);    printf(&quot;********帮助信息*****\n&quot;);    printf(&quot;*********************\n&quot;);&#125;int main()&#123;    int num;    help();    num = max(10,10+5);    printf(&quot;num=%d\n&quot;,num);    return 0;&#125;

三、函数的定义1、定义方法
返回值类型 函数名字（形参列表）{
​ &#x2F;&#x2F;函数体，函数的功能写在函数体实现
}
//定义一个没有参数也没有返回值的函数void myfun1()&#123;    printf(&quot;hello world\n&quot;);&#125;return ;//定义一个有参数的函数void myfun2()&#123;    int sum;    sum = a + b;    printf(&quot;%d + %d = %d\n&quot;, a , b , sum);&#125;//定义一个有返回值的函数int myfun3(int a,int b)&#123;    int sum;    sum = a + b;    return sum;&#125;

四、函数的声明1、概念
对已经定义的函数，进行声明，可以多次
2、为什么声明
编译器在编译 c 时，上到下编译
3、声明方法
（1）主调函数和被调函数在同一个.c 中
void fun(void)&#123;	printf(&quot;hello world\n&quot;);&#125;int main()&#123;	fun();&#125;//不需要声明

（2）被调函数在下，主函数在上
int main()&#123;    fun();&#125;void fun(void)&#123;    printf(&quot;hello world\n&quot;);&#125;//需要声明//1.直接声明#include &lt;stdio.h&gt;void myfun1();void myfun2(int a,int b);int myfun3(int a,int b);int main()&#123;    myfun1();    return 0;&#125;void myfun1()&#123;    printf(&quot;hello world\n&quot;);    return ;&#125;void myfun2(int a,int b)&#123;    int sum;    sum = a + b;    printf(&quot;%d + %d = %d\n&quot;,a,b,sum);&#125;int myfun3(int a,int b)&#123;    int sum;    sum = a + b;    return sum;&#125;//2.间接声明//a.c文件#include &quot;a.h&quot;int main()&#123;    fun();&#125;void fun(void)&#123;    printf(&quot;hellow world&quot;);&#125;//a.h文件extern void fun(void);

（2）主调函数和被调函数不在同一个.c 文件
1.直接声明 2.间接声明
//myfun.c#include &quot;myfun.h&quot;void myfun1()&#123;	printf(&quot;hellow world\n&quot;);	return;&#125;//myfun.h#ifndef MYFUN_H#define MYFUN_Hvoid myfun1();#endif//main.c#include &lt;stdio.h&gt;#include &quot;myfun.h&quot;int main()&#123;    muyfun1();    return 0;&#125;

五、函数调用变量 &#x3D; 函数名（实参列表）；带返回值
函数名（实参列表）；不带返回值
#include &lt;stdio.h&gt;void myfun1();void myfun2(int a,int b);int myfun(int a,int b);int main()&#123;    //没有参数也没有返回值    myfun1();    printf(&quot;*******************\n&quot;);    //有参数，没有返回值，需要在函数名传入实参    myfun2(100,90);    int x = 10, y=10;    //x、y:实参，实际参数，本质就是在被调函数的时候将参数的值传递给形参    myfun2(x,y);    printf(&quot;*******************\n&quot;);    //有参数也有返回值，可以一个变量接收函数执行结果（返回值），或者直接输出    int n;    n = myfun3(100,90);    printf(&quot;n = %d\n&quot;,n);    printf(&quot;sum=&amp;d\n&quot;,myfun3(90,66));    return 0;&#125;void myfun1()&#123;    printf(&quot;hello world\n&quot;);    return ;&#125;//a、b形参，存在实参的值void myfun2(int a,int b)&#123;    int sum;    sum = a + b;    printf(&quot;%d + %d = %d\n&quot;,a,b,sum);&#125;int myfun3(int a,int b)&#123;    int sum;    sum = a + b;    return sum;&#125;


六、变量的存储类别1、内存的分区物理内存：存储在存储设备
虚拟内存：操作系统虚拟出来的内存
操作系统会在物理内存和虚拟内存之间叫映射
2、运行程序的时候，操作系统会将虚拟内存进行分区（1）堆
在动态申请内存的时候，在堆里开辟内存
（2）栈
存放局部变量
（3）静态全局区
1：未初始化的静态全局区
​ 静态变量（就是在前面添加 statiic），或者全局变量，没有初始化，存储在这里
2：初始化的静态全局区
​ 全局变量，静态变量，赋值初始值的，存储在这里
4、代码区
​ 存储在程序代码
5、文字常量区
​ 存放常量的
3、普通全局变量在函数外部定义的变量
int num =100;//全局变量,需要声明 extern int num;int main()&#123;return 0;&#125;//生命周期：程序运行，整个过程，一直存在，知道程序结束

#include &lt;stdio.h&gt;//定义一个普通全局变量，在main函数外的变量就是全局变量//没有赋值，系统将赋值初始化0int num;void myfun()&#123;    num= 888;&#125;int main()&#123;    printf(&quot;num=%d\n&quot;,num);    myfun();    printf(&quot;num=%d\n&quot;,num);    return 0;&#125;


4、静态全局变量定义全局变量的时候，用 static
作用范围：限定了静态全局变量的作业范围
生命周期：在程序整个运行中，都一直存在
#include &lt;stdio.h&gt; //定义一个静态全局变量 //静态全局变量只能在其定义的.c文件中任意位置使用，不能跨文件使用 static int num; void myfun() &#123; num++; &#125; int main(int argc, char *argv[]) &#123; printf(&quot;num = %d\n&quot;, num); myfun(); printf(&quot;num = %d\n&quot;, num); return 0;&#125;


5、局部变量在函数内部定义，或者复合语句定义的变量
int main()&#123;    int num;//局部    &#123;        int a;//局部    &#125;&#125;

作用范围：
在函数中定义的变量，在函数中有效
在复合语句中定义的，在复合语句中有效。
生命周期：
在函数调用之前，局部变量不占用空间，调用函数的时候，
才为局部变量开辟空间，函数结束了，局部变量就释放了。
#include &lt;stdio.h&gt; //定义一个局部变量 //在函数内部定义的，不加任何修饰的变量都是局部变量 void myfun() &#123; int num = 100; num++; printf(&quot;num = %d\n&quot;, num); return ; &#125; int main(int argc, char *argv[]) &#123; //局部变量只能在定义的函数内部使用，声明周期相对较短，函数结束，局部变量就会释放//printf(&quot;num = %d\n&quot;, num); myfun(); myfun(); myfun(); return 0;&#125;


6、静态的局部变量定义局部变量的时候，前面加 static 修饰
作用范围：
在它定义的函数或复合语句中有效。
生命周期：
第一次调用函数的时候，开辟空间赋值，函数结束后，不释放， 以后再调用函数的时候，就不再为其开辟空间，也不赋初值， 用的是以前的那个变量。
#include &lt;stdio.h&gt;//定义一个静态局部变量//在函数内部定义的使用static修饰的变量就是静态局部变量void myfun()&#123;//如果普通局部变量不进行初始化，则默认是随机值//如果静态局部变量不进行初始化，则默认是0 int a; //普通局部变量 static int num; //静态局部变量 printf(&quot;a = %d\n&quot;, a); printf(&quot;num = %d\n&quot;, num); &#125; void myfun1() &#123; //静态局部变量不会随着当前函数执行结束而释放空间，下次使用的函数之前的空间 //静态局部变量只会初始化一次 static int num1 = 100; num1++; printf(&quot;num1 = %d\n&quot;, num1); &#125; int main(int argc, char *argv[]) &#123;     myfun();     myfun1();     myfun1();     myfun1(); return 0; &#125;


1：定义普通局部变量，如果不赋初值，它的值是随机的。
定义静态局部变量，如果不赋初值，它的值是 0
2：普通全局变量，和静态全局变量如果不赋初值，它的值为 0
7、外部函数咱们定义的普通函数，都是外部函数。 即函数可以在程序的任何一个文件中调用。
在分文件编程中，只需要将函数的实现过程写在指定的.c 文件中，然后将其声明写在指定
的.h 文件中，其他文件只要包含了头文件，就可以使用外部函数
8、内部函数内部函数也称之为静态函数，就是用 static 修饰的函数
在定义函数的时候，返回值类型前面加 static 修饰。这样的函数被称为内部函数。
static 限定了函数的作用范围，在定义的.c 中有效。
外部函数，在所有地方都可以调用，
内部函数，只能在所定义的.c 中的函数调用
扩展：
在同一作用范围内，不允许变量重名。
作用范围不同的可以重名。
局部范围内，重名的全局变量不起作用。（就近原则）
int num = 100; //全局变量 int main() &#123; //如果出现可以重名的情况，使用的时候满足向上就近原则 int num = 999; //局部变量 return 0; &#125;
]]></content>
      <categories>
        <category>千锋C语言</category>
      </categories>
      <tags>
        <tag>嵌入式C</tag>
      </tags>
  </entry>
  <entry>
    <title>第三章 寄存器点亮LED</title>
    <url>/2023/09/01/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AF%84%E5%AD%98%E5%99%A8%E7%82%B9%E4%BA%AELED/</url>
    <content><![CDATA[一、GPIOGPIO 是通用输入输出端口的简称，就是可控的引脚。
上拉是高电平，下拉是低电平

1、P-MOS 和 N-MOS 管推挽输出： 低电平 0v，高电平 3.3v
输出高电平，经过反向后，上方 P-MOS 管导通，下方 N-MOS 管关闭，对外输出高电平。
输入低电平，经过反向后，上方 P-MOS 管关闭，下方 N-MOS 管导通，对外输出低电平。
当高低电平切换时，两个管轮流导通，P 负责电流，N 负责电流。
** 推挽输出一般应用在输出电平为 0，3.3v，需要高速切换开关的状态。
开漏输出：
P-MOS 管不工作。例如，输出 0，低电平，则 P-MOS 关闭，N-MOS 管导通，使输出接地。
输出为 1，P-MOS，N-MOS 都关闭，所以不输出高电平，低电平，为高阻态。
** 开漏输出一般应用在 I2C、SMBUS 通讯，需要“线与”（ *指的是它们任意一开关只要对地导通，这根线就一定是低电平* ）在总线电路上
输出：输出数据寄存器MOS 管结构电路的输出信号，由 GPIO“输出数据寄存器”GPIO_ODR 提供
“置位&#x2F;复位寄存器 GPIOx_BSRR”可以通过修改输出数据寄存器的值从而影响电路的输出
复用功能输出复用 是指 STM32 其它片上外设对 GPIO 引脚进行控制，此时 GPIO 引脚用作改外设功能的一部分。
例如我们使用 USART 串口通讯时，需要用到某个 GPIO 引脚作为通讯发送引脚，这个时候就可以把该 GPIO 引脚配置成 USART 串口复用功能，由串口外设控制该引脚，发送数据。
输入：输出数据寄存器
连接到施密特触发器，模拟信号转换 0&#x2F;1 数字信号，最好存储在“输出数据寄存器 GPIOx_IDR”中
复用功能输出
GPIO 引脚将信号传输到 stm32 其他片上外设，由该外设读取引脚状态
如我们使用 USART 串口通讯时，需要用到某个 GPIO 引脚作为通讯接收引脚，这个时候就可以把该 GPIO 引脚配置成 USART 串口复用功能，使 USART 可以通过该通讯引脚的接收远端数据。
]]></content>
      <categories>
        <category>野火STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>第九章 STM32中断应用</title>
    <url>/2024/05/09/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20STM32%E4%B8%AD%E6%96%AD%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[一、中断概述中断时出现某些意外需要主机干预，机器能自动停止运行的程序，转入新的处理的程序，处理完之后返回程序被暂停的程序，继续运行。
异常就是中断，中断就是异常。
异常分为：系统异常和外部中断。
二、NVIC介绍NVIC是嵌套向量中断控制器，控制芯片中断的功能。
一般来说，使用ISER（使能中断）、ICER（失能中断）和IP（设置中断优先级）寄存器。
（不常用）

三、优先级中断优先级寄存器NVIC_IPRx，用来配置外部中断的优先级。如果抢占优先级相同，九比较子优先级，如果都相同，比较硬件中断编号，编号越小，优先级越高

四、优先级分组优先级分组由外设SCB的应用程序中断和复位控制寄存器AIRCR的PRIGROUP[10:8]决定，主优先级&#x3D;抢占优先级
/*** 配置中断优先级分组：抢占优先级和子优先级* 形参如下：* @arg NVIC_PriorityGroup_0: 0bit for 抢占优先级* 4 bits for 子优先级* @arg NVIC_PriorityGroup_1: 1 bit for 抢占优先级* 3 bits for 子优先级* @arg NVIC_PriorityGroup_2: 2 bit for 抢占优先级* 2 bits for 子优先级* @arg NVIC_PriorityGroup_3: 3 bit for 抢占优先级* 1 bits for 子优先级* @arg NVIC_PriorityGroup_4: 4 bit for 抢占优先级* 0 bits for 子优先级* @ 注意 如果优先级分组为 0，则抢占优先级就不存在，优先级就全部由子优先级控制*/void NVIC_PriorityGroupConfig(uint32_t PriorityGroup)&#123;     // 检查参数     assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));     // 设置优先级分组     NVIC_SetPriorityGrouping(PriorityGroup);&#125;


五、中断编程配置中断一般使用三个：
1、使用 HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup) 函数配置中断优先级分组。一般默认是 NVIC_PRIORITYGROUP_4 分组 4。
2、使用 HAL_NVIC_SetPriority (IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority) 函数配置具体外设中断通道的抢占优先级和子优先级。
3、使用 HAL_NVIC_EnableIRQ 函数使能中断请求。
]]></content>
      <categories>
        <category>野火 STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>第二章 算法</title>
    <url>/2024/02/29/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[2.1 算法定义算法是解决特定问题求解步骤的描述，计算机中表现位指令的有限序列，并且每条指令表示一个或多个操作。
2.2 算法的特性算法具有：输入、输出、有穷性、确定性和可行性。
2.2.1 输入输出算法具有零个或多个输入和至少一个或多个输出。
2.2.2 有穷性指的是算法在执行有限步骤之后，自动结束而不会出现无限循环，并且每一个步骤可接受在时间内完成。
2.2.3 确定性算法的每一步骤具有确定的含义，不会出现二义性。
2.2.4 可行性算法的每一步都必须可行的，每一步都能狗通过执行有限次数完成。
2.3 算法设计的要求2.3.1 正确性指的是至少具有输入、输出和加工处理无歧义性，能正确反映问题的需求，能够得到问题的正确答案。
2.3.2 可读性算法设计的另外一个目的，为了便于阅读、理解和交流。
2.3.3 健壮性输入数据不合法，算法也能够做出相关处理，而不是产生异常或者莫名其妙的结果。
2.3.4 时间效率高和存储量低时间效率高：算法的执行时间。存储量低：执行过中需要的最大存储控件，运行时所占用的内存或外部硬盘存储控件。
应该满足时间效率和存储量低的需求。
2.4 算法效率的度量方法2.4.1 事后统计方法通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行对比，确定算法效率的高低。
2.4.2 事前分析估算方法在计算机程序编制前，依据统计方法对算法进行估算。

一个程序的运行时间，依据赖与算法的好坏和问题的输入规模。问题输出规模是指输入量的多少。
2.5 函数的渐近增长给定义两个函数f（n）和g（n），如果存在一个整数N，使得对于所有的n&gt;N，f（n）总是大于g（n），所以f（n）的增长渐近快于g（n）。
判断一个算法效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项（最高阶项） 的阶数。

可以分析出：某个算法，随着n的增大，它会优越于另外一个算法，或者差于另外一个算法。
2.6 算法时间的复杂度2.6.1 算法时间复杂度定义在进行算法分析时，语句总的执行次数T（n）是关于问题规模n的函数，进而分析T（n）随n的变化情况并而确定T（n）的数量级。算法的时间复杂度（时间量度），记作T（n）&#x3D;O（f（n））。表示随着问题规模n的增大，算法执行时间的增长率和f（n）的增长率相同，称为算法的渐近时间赋值度，简称时间复杂度。其中f（n）是问题规模n的某个函数。
2.6.2 推导大O阶方法推导大O阶：
（1）常数1取代运行时间中的所有加法常数。
（2）在修改后运行次数函数中，只保留最高阶项。
（3）如果最高阶项存在且系数不是1，则去除与这个项相乘的系数，得到结果最大O阶。
2.6.3 常数阶int sum = 0,n = 100;  //一次sum = (1 + n) * n /2; //一次printf(&quot;%d&quot;, sum);    //一次
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>第二章-寄存器</title>
    <url>/2023/08/17/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%AF%84%E5%AD%98%E5%99%A8/</url>
    <content><![CDATA[一、芯片组成负责在 内核之外设计部件并生产整个芯片，这些内核之外的部件被称为核外外设或片上外设。如 GPIO、 USART（串口）、I2C、SPI 等都叫做片上外设

芯片内核和外设之间通过各种总线连接，其中主控总线有 8 条，被控总线有 7 条
二、存储器映射给存储器分配地址的过程就称为存储器映射，具体见图 。给存储器再分配一个地址就叫存储器重映射
三、寄存器以功能为名给这个
内存单元取一个别名，这个别名就是我们经常说的寄存器，这个给已经分配好地址的有特定功能的内存单元取别名的过程就叫寄存器映射
寄存器的说明

① 名称
(GPIOx_BSRR)(x&#x3D;A…I)”是该寄存器名为“GPIOx_BSRR”其中的“x”可以为 A-I，也就是说这个寄存器说明适用于 GPIOA、GPIOB 至 GPIOI，这些 GPIO 端口都有这样的一个寄存器
② 偏移地址
偏移地址是指本寄存器相对于这个外设的基地址的偏移。查到 GPIOA 外设的基地址为 0x4002 0000 ，就可以算出 GPIOA 的这个 GPIOA_BSRR 寄存器的地址为：0x4002 0000+0x18
③ 寄存器位表
为读写权限，其中 w 表示只写，r 表示只读，rw 表示可读写
④ 位功能说明
本寄存器中有
两种寄存器位，分别为 BRy 及 BSy，其中的 y 数值可以是 0-15，这里的 0-15 表示端口的引脚号，如 BR0、BS0 用于控制 GPIOx 的第 0 个引脚，若 x 表示 GPIOA，那就是控制 GPIOA 的第 0 引脚，而 BR1、BS1 就是控制 GPIOA 第 1 个引脚。
这里的“复位”是将该位设置为 0 的意思，而“置位”表示将该位设置为 1；
四、GPIO 输出初始化顺序1、确定 GPIO 是输入、通用输出、复用功能还是模拟输入（MODER）
2、如果是输出还要确定推挽输出还是开漏输出（OTYPER）
3、配置输出的速度（OSPEEDR）
4、输出的时候内部是上&#x2F;下拉电阻要不要开启（PUPDR）
5、具体输出的内容（BSSR 和数据输出 ODR）
]]></content>
      <categories>
        <category>野火STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>第二章 数组</title>
    <url>/2023/08/06/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[一、数组的概念数组是若干个相同类型的变量在内存中有序存储的集合。
概念理解：
数组用于存储一组数据
数组里面存储的数据类型必须是相同的
数组在内存中会开辟一块连续的空间
int a[10];&#x2F;&#x2F;定义了一个整型的数组 a，a 是数组的名字，数组中有 10 个元素，每个元素的类型都是 int 类型，而且在内存中连续存储。
这十个元素分别是 a[0] a[1] …. a[9]
a[0]~a[9]在内存中连续的顺序存储
二、数组的分类1）字符数组
即若干个字符变量的集合，数组中的每个元素都是字符型的变量
char s[10]; s[0],s[1]….s[9];
2）短整型的数组
short int a[10]; a[0] ,a[9]; a[0]&#x3D;4;a[9]&#x3D;8;
3）整型的数组
int a[10]; a[0] a[9]; a[0]&#x3D;3;a[0]&#x3D;6;
4) 长整型的数组
lont int a[5];
5）浮点型的数组（单、双）
float a[6]; a[4]&#x3D;3.14f;
double a[8]; a[7]&#x3D;3.115926;
6）指针数组
char *a[10]
int *a[10];
7）结构体数组
struct stu boy[10];
2.2 按维数分类
一维数组
int a[30];
类似于一排平房
二维数组
int a[2] [30] ;
可以看成一栋楼房 有多层，每层有多个房间，也类似于数学中的矩阵
二维数组可以看成由多个一维数组构成的。
有行，有列，
多维数组
int a[4] [2] [10];
三维数组是由多个相同的二维数组构成的
int a[5] [4] [ 2] [10];
三、数组的定义
3.1 一维数组的定义
格式：
数据类型 数组名[数组元素个数];
例如：
int a[10]; &#x2F;&#x2F;定义了一个名为 a 的数组，数组中每一个元素都是 int 类型，一共有 10 个元素
&#x2F;&#x2F;每一个元素都保存在一个变量中，每一个变量都是有数组名和数组下标组成的
&#x2F;&#x2F;并且是从 0 开始的，分别是 a[0] a[1] a[2]… a[9]
注意：数组元素的个数在定义的时候也可以不写，但是如果不写，必须初始化（定义的时候赋值）
#include &lt;stdio.h&gt;int main(int argc, char *argv[])&#123;//定义一个一维数组int a[10];//通过sizeof关键字可以获取数组的大小printf(&quot;sizeof(a) = %d %d\n&quot;, sizeof(a), 10 * sizeof(int)); //如果定义数组的同时赋值（初始化），可以不指定数组元素的个数，系统会根据初始化元素的个数自动指定数组元素的个数 int b[] = &#123;10, 20, 30&#125;; printf(&quot;sizeof(b) = %d\n&quot;, sizeof(b)); return 0; &#125;

3.2 二维数组的定义格式:
数据类型 数组名[行的个数][列的个数];
例如：
int a[2][4];
解释：
定义一个名为 a 的二维数组，每一个元素都是 int 类型
这个二维数组中包含两行四列的元素，一共有 8 个元素
二维数组也是连续开辟空间，访问元素是行和列都是从 0 开始，分别是 a[0] [0] a[0] [1] a[0] [2] a[0] [3] a[1] [0] a[1] [1] a[1] [2] a[1] [3]
注意：二维数组的下标也是可以省略的，但是有条件，在初始化时行数可以省略，但是列数不能省略
//定义一个二维数组 int c[2][4]; printf(&quot;sizeof(c) = %d %d\n&quot;, sizeof(c), 2 * 4 * sizeof(int)); //二维数组的行数可以省略，但是列数不能省略，在初始化时可以这样操作 //系统会根据列数自动指定行数，最终得到的函数所得到得元素个数移动是列的整数倍 int d[][4] = &#123;1, 2, 3, 4, 5&#125;; printf(&quot;sizeof(d) = %d\n&quot;, sizeof(d));

四、定义并初始化4.1 一维数组的初始化
#include &lt;stdio.h&gt; int main(int argc, char *argv[]) &#123; //以一维数组的初始化 //如果不初始化，直接使用会是随机值 //int a[4];//初始化方式1：全部初始化 //int a[4] = &#123;123, 78, 666, 476&#125;; //如果是全部 初始化，可以不指定数组元素的个数，系统会自动分配 //int a[] = &#123;10, 20, 30, 40&#125;; //初始化方式2：局部初始化 //未初始化的位置的元素自动赋值为0 int a[4] = &#123;10, 20&#125;; printf(&quot;%d\n&quot;, a[0]); printf(&quot;%d\n&quot;, a[1]); printf(&quot;%d\n&quot;, a[2]); printf(&quot;%d\n&quot;, a[3]); return 0; &#125;

4.2 二维数组的初始化
按行初始化：
a、全部初始化
int a[2][2]=&#123;&#123;1,2&#125;,&#123;4,5&#125;&#125;;a[0][0] =1; a[0][1] = 2;a[1][0] =4, a[1][1]=5;

b、部分初始化
int a[3][3]=&#123;&#123;1,2&#125;,&#123;1&#125;&#125;;a[0][0] = 1;a[0][2] =0;

逐个初始化：
全部初始化：
int a [2][3]=&#123;2,5,4,2,3,4&#125;;

部分初始化：
int a[2][3]=&#123;3,5,6,8&#125;;

#include &lt;stdio.h&gt;int main(int argc, char *argv[])&#123;//二维数组的初始化//int a[2][3];//初始化方式1：按行初始化//全部初始化 //int a[2][3] = &#123;&#123;10, 20, 30&#125;, &#123;666, 777, 888&#125;&#125;; //局部初始化 //没有赋值的位置的元素自动为0 //int a[2][3] = &#123;&#123;10, 20&#125;, &#123;666&#125;&#125;; //初始化方式2：逐个初始化 //全部初始化 //int a[2][3] = &#123;1, 2, 3, 4, 5, 6&#125;; //局部初始化 //没有赋值的位置的元素自动为0 int a[2][3] = &#123;1, 2, 3&#125;; printf(&quot;%d\n&quot;, a[0][0]); printf(&quot;%d\n&quot;, a[0][1]); printf(&quot;%d\n&quot;, a[0][2]); printf(&quot;%d\n&quot;, a[1][0]); printf(&quot;%d\n&quot;, a[1][1]); printf(&quot;%d\n&quot;, a[1][2]); return 0; &#125;

五、数组元素的引用方法一维数组元素的引用方法
数组名[下标]；
&#x2F;&#x2F;下标代表数组元素在数组中的位置，注意从 0 开始
int a[10];a[2];
二维数组元素的引用方法
数组名[行下标] [列下标];
int a[3] [4];
a[1] [2]
#include &lt;iostream&gt;using namespace std;int main(int argc, char *argv[])&#123;//一维数组的引用以及一维数组的遍历int a[6] = &#123;111, 222, 333, 444, 555, 666&#125;; a[3] = 10000; //一维数组的遍历 int i; for(i = 0; i &lt; sizeof(a) / sizeof(int); i++) &#123; printf(&quot;a[%d] = %d\n&quot;, i, a[i]); &#125; printf(&quot;**********************\n&quot;); //二维数组的引用以及二维数组的遍历 int b[3][4] = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12&#125;; b[2][0] = 666; //二维数组的遍历 int m, n; //外层循环控制行数 for(m = 0; m &lt; 3; m++) &#123; //内层循环控制列数 for(n = 0; n &lt; 4; n++) &#123; printf(&quot;%‐4d&quot;, b[m][n]); &#125; printf(&quot;\n&quot;); &#125; return 0; &#125;

六、字符数组的定义和初始化问题char c1[] =&#123;‘c’,’ ’,’p’,’r’,’o’,’g’&#125;;char c2[] = “c prog”;char a[][5] = &#123;&#123;‘B’,’A’,’S’,’I’,’C’&#125;,&#123;‘d’,’B’,’A’,’S’,’E’&#125;&#125;;char a[][6] = &#123;“hello”,“world”&#125;

字符数组的引用
1.用字符串方式赋值比用字符逐个赋值要多占 1
个字节,用于存放字符串结束标志‘
\0’;
2.上面的数组 c2 在内存中的实际存放情况为：

3.由于采用了’\0’标志，字符数组的输入输出将变得简单方便
#include &lt;stdio.h&gt;int main(int argc, char *argv[])&#123;//定义一个字符数组，通过scanf函数输入字符串并输出结果//通过赋值&quot;&quot;这样的方式可以清除字符数组中的垃圾字符，让每一个元素都是\0char ch[32] = &quot;&quot;;//数组名就是当前数组的首地址，所以scanf的第二个参数直接传数组名即可 scanf(&quot;%s&quot;, ch); printf(&quot;ch = %s\n&quot;, ch); return 0; &#125;
]]></content>
      <categories>
        <category>千锋C语言</category>
      </categories>
      <tags>
        <tag>嵌入式C</tag>
      </tags>
  </entry>
  <entry>
    <title>第二章内存管理</title>
    <url>/2025/04/11/%E7%AC%AC%E4%BA%8C%E7%AB%A0%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[1.1、堆栈1、堆：即heap，一块空闲的内存，提供管理函数
malloc：从堆里面划出一块空间给程序使用
free：用完之后，标记空闲，可以再次使用
2、栈：即stack，函数调用时局部变量保存在栈中，当前程序环境可以保存在栈中，可以分配一块空间用作栈
堆（heap）意思就是被管理就叫做堆，栈（stack）就是栈寄存器指向的就叫做栈
1.3FreeRTOS内存管理方法1、Heap_1只实现了pvPortMalloc，没有实现vPortFree。

**pvPortMalloc**：用来分配内存的函数。你需要多少内存，它就给你分配，并返回一个指针指向这块内存。
**vPortFree**：用来释放之前分配的内存的函数。当你不再需要某块内存时，调用它把内存还给系统。

即：适合分配一次内存后就一直使用的场景，不需要频繁释放内存。
（1）数组定义：
/* Allocate the memory for the heap. */##if ( configAPPLICATION_ALLOCATED_HEAP == 1 )/* The application writer has already defined the array used for the RTOS* heap -  probably so it can be placed in a special segment or address. */    extern uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];##else    static uint8_t ucHeap[ configTOTAL_HEAP_SIZE ];##endif /* configAPPLICATION_ALLOCATED_HEAP */

（2）调用pvPortMalloc，从这个数组中分配空间
FreeRTOS创建任务的时候，需要两个内核对象：task control block(TCB：任务控制块)，stack（栈）。
内存分配的过程如下：

2、Heap_2在新设计中不在推荐使用Heap_2，建议使用Heap_4替代。
Heap_2也是在数组上分配内存，但是跟Heap_2不一样的地方在于：

Heap_2使用最佳匹配算法(best fit)来分配内存
它支持vPortFree

最佳匹配算法：

假设heap有3块空闲内存：5字节、25字节、100字节
pvPortMalloc想申请20字节
找出最小的、能满足pvPortMalloc的内存：25字节
把它划分为20字节、5字节
返回这20字节的地址
剩下的5字节仍然是空闲状态，留给后续的pvPortMalloc使用



总结：就是根据使用内存的大小，系统分配合适的空闲内存块
在Heap_2中不会像Heap_4那样合并相邻的空闲内存，所以Heap_2导致严重的“碎片化”问题
如果在申请、分配内存时大小总是相同的，使用Heap_2没有碎片化的问题，适合在场景例如：频繁创建、删除任务，任务的栈大小都是相同的
内存分配过程如下：

3、Heap_3Heap_3使用标准的C库中的malloc、free函数，所以堆大小由链接器的配置决定，配置项的congfigTOTAL_HEAP_SIZE不起作用。
在这两个函数中并没有特别考虑线程安全，Heap_3先暂停FreeRTOS的调度器，再去调用这些函数，实现了线程安全。
4、Heap_4Heap_4使用首次适应算法（first fit）分配内存。还会把相邻的空闲内存合并为一个更大的空闲内存，可以较少内存的碎片问题
首次适应算法：

假设堆中有3块空闲内存：5字节、200字节、100字节
pvPortMalloc想申请20字节
找出第1个能满足pvPortMalloc的内存：200字节
把它划分为20字节、180字节
返回这20字节的地址
剩下的180字节仍然是空闲状态，留给后续的pvPortMalloc使用

适用场景：频繁分配、频繁释放不同大小的内存

5、Heap_5分配内存、释放内存的算法和Heap_4一样
相比于Heap_4，Heap_5并不局限于管理一个大数组，可以管理多块、分隔的内存。在嵌入式中，内存地址可能并不连续，这种场景下可以使用Heap_5。
内存是分隔开的，那么需要进行初始化：确认这些内存块在哪里，多大

在使用pvPortMalloc之前，必须先指定内存块的信息
使用vPortDefineHeapRegions来指定这些信息

指定一块内存：
typedef struct HeapRegion&#123;    uint8_t * pucStartAddress; // 起始地址    size_t xSizeInBytes;       // 大小&#125; HeapRegion_t;

指定多块内存，使用一个HeapRegion_t数组，在这个数组中，低地址在前，高地址在后
HeapRegion_t xHeapRegions[] =&#123;  &#123; ( uint8_t * ) 0x80000000UL, 0x10000 &#125;, // 起始地址0x80000000，大小0x10000  &#123; ( uint8_t * ) 0x90000000UL, 0xa0000 &#125;, // 起始地址0x90000000，大小0xa0000  &#123; NULL, 0 &#125; // 表示数组结束 &#125;;

vPortDefineHeapRegions函数原型
void vPortDefineHeapRegions( const HeapRegion_t * const pxHeapRegions );

把xHeapRegions数组传给vPortDefineHeapRegions函数，就是先初始化。
Heap相关的函数pvPortMalloc&#x2F;vPortFreevoid * pvPortMalloc( size_t xWantedSize );void vPortFree( void * pv );

作用：分配内存，释放内存，如果分配内存不成功，返回NULL
xPortGetFreeHeapSizesize_t xPortGetFreeHeapSize( void );

当前还有多少空闲内存，这函数可以用来优化内存的使用情况。比如当所有内核对象都分配好后，执行此函数返回2000，那么configTOTAL_HEAP_SIZE就可减小2000。
注意：在heap_3无法使用
xPortGetMinimumEverFreeHeapSizesize_t xPortGetMinimumEverFreeHeapSize( void );

返回：程序运行中，空闲内存容量的最小值
注意：只有heap_4,5支持此函数
malloc失败的钩子函数void * pvPortMalloc( size_t xWantedSize )vPortDefineHeapRegions&#123;    ......    #if ( configUSE_MALLOC_FAILED_HOOK == 1 )        &#123;            if( pvReturn == NULL )            &#123;                extern void vApplicationMallocFailedHook( void );                vApplicationMallocFailedHook();            &#125;        &#125;    #endif      return pvReturn;      &#125;


在FreeRTOSConfig.h中，把configUSE_MALLOC_FAILED_HOOK定义为1
提供vApplicationMallocFailedHook函数
pvPortMalloc失败时，才会调用此函数

]]></content>
      <categories>
        <category>RTOS</category>
      </categories>
      <tags>
        <tag>RTOS</tag>
      </tags>
  </entry>
  <entry>
    <title>第五章 串</title>
    <url>/2024/11/02/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E4%B8%B2/</url>
    <content><![CDATA[串的定义串是由零个或者多个字符组成的有限序列，又叫字符串。
一般记为s&#x3D;”a1a2…an”(n≥0)，s是串的名字，引号中的字符序列是串的值而不是内容。ai(1≤i≤n)可以是字母、数字等，i是改字符在串中的位置。
串中的字符数目n称为串的长度，定义中谈到“有限”指的是长度n是有一个有限的数值。
零个字符的串称为空串，长度为0，直接用两个“”””表示。
所谓的序列，说明串的相邻字符之间有前驱和后继的关系。
空格串：只是包含空格的串。
字串和主串：串中任意个数的连续字符组成的子序列称为该串的子串，包含字串的串称为主串。
字串在珠串的位置就是字串的第一个字符在主串的序号。
串的比较对于两个不相等的串进行判断大小：
给定义两个串：s&#x3D;“a1a2…an”，t&#x3D;“b1b2…bm”，当满足以下条件之一时，s&lt;t。
（1）n&lt;m，且ai &#x3D; bi（i&#x3D;1,2,…,n）
例如：s&#x3D;“hap”，t&#x3D;“happy”，s&lt;t
（2）存在某个≤min(m,n)，使得ai&#x3D;bi(i&#x3D;1,2,…,k-1),ak&lt;bk
例如：当s-“happen”，t-“happy”，因为两串的前4个字母均相同，而两串第5个字母(k值)，字母e的ASCII码是101，而字母y的ASCI码是121，显然e&lt;y，所以s&lt;t。
串的抽象数据类型ADT 串 (string）Data串中元素仅由一个字符组成，相邻元素具有前驱和后继关系Operation        StrAssign(T,*chars):生成一个其值等于字符串常量 chars 的串T。        StrCopy(T,S):串s存在，由串S复制得串T。        Clearstring(s):串s存在，将串清空。        stringEmpty(S):若串S为空，返回true，否则返回 false。        strLength(s):返回串s的元素个数，即串的长度。        StrCompare(s,T):若S&gt;T,返回值&gt;0,若S=T,返回0,若S&lt;T,返回值&lt;0。        Concat(T,s1,S2):用T返回由S1和S2联接而成的新串。        Substring(Sub,s,pos,len):串s存在,1≤pos≤StrLength(s),且            0≤len≤StrLength(s)-pos+1，用Sub返回串s的第pos个字符起长度为 len的子串。         Index(S,T,pos):串S和T存在,T是非空串,1≤pos≤StrLength(s)。若主串s中存在和串T值相同的子串，则返回它在主串s中第pos个字符之后第一次出现的位置，否则返回0。        Replace(s,T,V):串S、T和V存在,T是非空串。用v替换主串s中出现的所有与T相等的不重叠的子串。        StrInsert(s,pos,T):串S和T存在,1≤pos≤StrLength(s)+1。在串s的第pos个字符之前插入串 T。        StrDelete(s,pos,len):串s存在,1≤pos&lt;strLength(s)-len+1。从串s中删除第pos个字符起长度为 len 的子串。endADT

Index算法int Index(String S,Strinf T,int pos)&#123;    int n,m,i;    String sub;    if(pos&gt;0)&#123;     n = StrLength(S); //得到主串S的长度     m = StrLength(T); //得到字串T的长度     i = pos;     while(i &lt;= n-m+1)&#123;          SubString(sub,S,i,m);//主串中第i个位置开始长度与T相等的字串给sub          if(SubString(sub,T)!=0)//如果两串不相等                  ++i;          else                  return i;        &#125;    &#125;reteun 0;&#125;

串的存储结构串的顺序存储结构串的顺序存储结构是用一组地址连续的存储单元来存储串中的字符序列的。
比如：计算机中寸在一个自由存储区，叫做“堆”。这个堆可由C语言的动态分配函数malloc()和free()来管理
串的链式存储结构如果是简单地应用链表存储串值，一个结点对应一个字符，就会存在很大的空间浪费。因此一个结点，可以存放一个字符，也可以考虑放多个字符，最后一个结点若是未被沾满，可以用“#”等非串字符补传，比如：

模式匹配算法去找一个单词在一篇文章中的定位为，这种字串的定位操作通常称做串的模式匹配。
int Index(Strinf S,String T,int pos)&#123;      int i = pos;       //i用于字串S中当前的位置下标值，从pos位置开始匹配      int j = 1;         //j用于字串T当前位置下标值      while(i≤S[0]&amp;&amp;j≤T[0])&#123;    //当i小于S的长度并且j小于T的长度是，循环继续           if(S[i] == T[j])    //两字母相等则继续           &#123;               ++i;               ++j;           &#125;else&#123;              //指针后退重新开始匹配                i = i-j+2;     //i退回上次匹配首尾的下一位                j = i;        //j退回到字串T的首位            &#125;     &#125;      if(j &gt;T[0])&#123;         return i-T[0];     &#125;else&#123;         retrun 0;     &#125;&#125;
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>第五章-初始HAL库</title>
    <url>/2024/02/06/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%88%9D%E5%A7%8BHAL%E5%BA%93/</url>
    <content><![CDATA[
一、库目录、文件介绍
Documentation：如何使用驱动库来编写自己的应用程序
Drivers：文件夹下是官方的 CMSISI 库，HAL 库，板载外设驱动。
Middlewares：中间件，包含 ST 官方的 STemWin、STM32_Audio、STM32_USB_Device_Library、STM32_USB_Host_Library；也有第三方的 fatfs 文件系统等等。
Project ：文件夹下是用驱动库写的针对官方发行 demo 板的例子和工程模板。
Utilities：实用的公用组件比如 LCD_LOG 实用液晶打印调试信息。
Release_Note.html:：库的版本更新说明。
2、CMSIS 文件
]]></content>
      <categories>
        <category>野火STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>第五章-指针</title>
    <url>/2023/08/14/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[一、指针的概念操作系统给每个存储单元分配了一个编号，从 0x00 00 00 00 00 ~0xff ff ff ff 称之为内存
指针变量：是变量也是指针变量，这个变量用来存放一个地址编号。在 32 位系统下，有 4 个字节
注：
​ 1、无论声明类型的地址，都有存储单元的编号，在 32 位下都是 4 个总控二。所以 任何类型的指针变量都是 4 个字节
​ 2、对应类型的指针变量，只能存放对应类型的变量地址
​ 比如：整形的指针变量，就是存放整型变量的地址
扩展：
字符变量 char ch; ch 占一个字节，它有一个地址编号，这个地址编号就是 ch 的地址整型变量 int a； a 占四个字节，占有四个字节的存储单位，有四个地址编号

二、指针的定义方法1、简单指针
数据类型 * 指针变量名
int * P;//定义一个指针变量P

2、指针的运算符
&amp; 取地址 ：获取一个变量的地址
*取值：标识作用

#include &lt;stdio.h&gt;int main()&#123;    int a = 100;    int * p;//指针变量    p = &amp;a;//a的地址保存在p中    printf(&quot;a = %d %d\n&quot;,a,*p);    ptintf(&quot;&amp;a = %p %p\n&quot;,&amp;a,p);&#125;


3、指针大小
在 32 位系统下，所以类型的指针都是 4 个字节
三、指针的分类1、字符指针
​ char *p;&#x2F;&#x2F;只能存放字符串类型的地址编号
​ char ch;
​ p &#x3D; &ch;
2、短整型指针
​ short int *p;
​ short int a;
​ p &#x3D;&a;
3、整形指针
​ int *p;
​ int a;
​ p &#x3D;&a;
4：长整型指针
long int *p;
long int a;
p &#x3D;&a;
5：float 型的指针
float *p;
float a;
p &#x3D;&a;
6：double 型的指针
​ double *p;
​ double a;
​ p &#x3D;&a;
7：函数指针
8、结构体指针
9、指针的指针
10、数组指针
四、指针和变量的关系指针可以存放变量地址编号
1、变量的名称引用变量
​ int a;
​ a&#x3D;100;
2、通过指针变量引来变量
​ int *p;
​ p &#x3D;&a;&#x2F;&#x2F;p 保存了 a 的地址，也可以说 p 指向了 a
​ *p&#x3D;100;
注意：指针变量的定义可以初始化
int a;
int *p&#x3D;&a;&#x2F;&#x2F;指针就是存放变量地址的
#include &lt;stdio.h&gt;int main()&#123;    int *p1,*p2,temp,a,b;    p1=&amp;a;    p2=&amp;b;    printf(&quot;输入a b的值：\n&quot;);    scanf(&quot;%d %d&quot;,p1,p2);//70 90    temp = *p1;//p1指向a的值给temp赋值 70    *p1 = *p2;//p2指向b的值给p1的变量a赋值 90    *p2 = temp;//temp给p2指向的变量b赋值 70    printf(&quot;a=%d b=%d\n&quot;,a,b);	printf(&quot;*p1=%d *p2=%d\n&quot;,*p1,*p2);&#125;


扩展：
对应类型的指针，只能保存对应类型数据的地址
如果想让不同类型的指针互相赋值，需要强制类型转换
#include &lt;stdio.h&gt;int main()&#123;    int a=0x1234,b=5678;    char *p1,*p2;    printf(&quot;%#x %#x\n&quot;,a,b);    p1=(char *)&amp;a;    p2=(char *)&amp;b;    printf(&quot;%#x %#x\n&quot;,*p1,*p2);    p1++;    p2++;    printf(&quot;%#x %#x\n&quot;,*p1,*p2);&#125;



五、指针和数组元素之间的关系1、数组元素和指针的基本关系
变量存放在内存中，有地址编号，定义的数组，是的哟个相同类型的变量的集合。每个变量都占内存空间，都有地址编号。指针变量可以存放数组元素的地址（数组首元素）
int a[10];//int *p =&amp;a[0];int *p;p=&amp;a[0]; //指针变量p保存了数组a中第0个元素的地址，即a[0]的地址

2、数组元素的引用方式
（1）数组名[下标]
int a[10];a[2]=100;

（2）指针名加下标
int a[10];int *p;p=a;p[2]=100;

（3）指针运算加取值
int a[10];int *p;p = a;*(p+2)=100;//a[2]=100

#include &lt;stdio.h&gt;int main()&#123;    int a[5]=&#123;0,1,2,3,4&#125;;    int *p;    p=a;    printf(&quot;a[2]=%d\n&quot;,a[2]);//2    printf(&quot;p[2]=%d\n&quot;,p[2]);//2    printf(&quot;*(p+2) = %d\n&quot;,*(p+2));//2 	printf(&quot;*(a+2) = %d\n&quot;,*(a+2));//2 	printf(&quot;p=%p\n&quot;,p); 	printf(&quot;p+2=%p\n&quot;,p+2); 	printf(&quot;&amp;a[0] = %p\n&quot;, &amp;a[0]); 	printf(&quot;&amp;a[2] = %p\n&quot;, &amp;a[2]);&#125;


]]></content>
      <categories>
        <category>千锋C语言</category>
      </categories>
      <tags>
        <tag>嵌入式C</tag>
      </tags>
  </entry>
  <entry>
    <title>第四章 栈与队列</title>
    <url>/2024/10/12/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[栈的定义栈（stack）是限定仅在表尾进行插入和删除操作的线性表。（指的是栈顶）栈顶：插入和删除的一端栈底：另外一段空栈：不含任何数据元素的栈栈又称：后进先出的线性表，简称LIFO结构
注意：栈元素具有线性表关系，即前驱后继关系。特殊之处就是这个线性表的插入和删除位置，只能在栈顶进行。栈底是固定的，最先进栈的只能在栈底。
栈的插入操作叫做进栈，也叫压栈、入栈。
栈的删除操作，叫做出栈，也叫弹栈。

栈的抽象数据类型push：插入（进栈）      pop：删除（出栈）
ADT 栈（stack）Data    同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。operation    InitStack(*S):初始化操作，建立一个空栈s。    DestroyStack(*S):若栈存在，则销毁它。    CleanrStack(*S):将栈清空。    StackEmpyt(S):若栈为空，返回true，否则返回false。    GetTop(S,*e):若栈存在且非空，用e返回s的栈元素    Push(*S,e):若栈s存在，插入新元素e到栈s中并称为栈顶元素。    StatckLengtg(S):返回栈s的元素个数。endADT

栈的顺序存储结构及实现栈的顺序存储结构栈的顺序结构其实就是线性表顺序存储的简化，称为顺序栈。
typedef int SElemType; //SElemType类型根据实际情况typedef struct&#123;      SElemType data[MAXSIZE];      int top; //栈顶指针&#125;SqStack;

栈的顺序存储结构-进栈//插入元素e为新的栈顶元素Status Push(SqStack *S,SElemType)&#123;      if(S-&gt;top == MAXSIZE -1)&#123;   //如果栈满          return ERROR;      &#125;      S-&gt;top++;     //栈顶指针加1      S-&gt;data[S-&gt;top]=e;  //将新插入元素赋值给栈顶空间      return OK;&#125;

栈的顺序存储结构–出栈操作//若栈不为空，则删除S的栈顶元素怒，用e返回其值，并返回OK，否则ERRORStatus Pop(SqStack *S,SElemType *e)&#123;     if(S-&gt;top==-1)&#123;          return ERROR;     &#125;     *e=S-&gt;data[S-&gt;top];  //将要删除栈顶元素赋值给e     S-&gt;top--;//栈顶指针减一     return OK;&#125;

两站共享空间typedef struct&#123;      SElemType data[MAXSIZE];      int top1; //栈1栈顶指针      int top2; //栈2栈顶指针&#125;SqDoubleSatck;

两站共享空间的push方法 Status Push(SqDoubleStack *S,SElemType e,int stackNumber)&#123;       if(S-&gt;top1+1=S-&gt;top2)   //栈满了            return ERROR;       if(statckNumber==1)        //栈1有元素进栈            S-&gt;data[++S-&gt;top1]=e   //如果是栈1则线top1+1后 给数组元素赋值       else if(statckNumber==2)       //栈2有元素进栈            S-data[--S-&gt;top2]=e   //如果是栈2，则线top2-1后 给数组元素赋值       return OK;&#125;

两站共享空间的pop方法，判断只是栈1栈2的参数stackNumberStatus Pop(SqDoubleStack *S,SElemType *e,int stackNumber)&#123;        if(statckNumber == 1)        &#123;                 if(S-&gt;top = -1)                   return ERROR;                 *e = S-&gt;data[S-&gt;top1--1];    //将栈1的栈顶元素出栈        &#125;        else if(stackNumber == 2)&#123;                 if(S-&gt;top2==MAXSIZE)                    return ERROR;                 *e = S-&gt;data[S-&gt;top2++];  //栈2的栈顶元素出栈        &#125;      return OK;&#125;

栈的链式存储结构以及实现栈的链式存储结构栈的链式存储结构，简称为链栈。
链栈代码定义：
typedef struct StackNode&#123;     SElemType data;     struct StatckNode *next;&#125;typedef struct&#123;    LinkStackPrt top;    int count;&#125;LinkStack;

栈的链式存储结构–进栈操作
Status Push(LinkStack *S,SElemType e)&#123;      LinkStackPtr s=(LinkStackPrt)malloc(sizeof(StackNode));      s-&gt;data=e;      s-&gt;next=S-&gt;top;   //把当前栈顶元素赋值给新节点的直接后继。见图1      S-&gt;top=s;     //把新的结点s赋值给栈顶指针，见图2      S-&gt;count++;      return OK;&#125;

栈的链式存储结构–出栈操作
Status Pop(LinkStack *S,SElemType *e)&#123;       LinkStackPrt p;       if(StackEmpty(*S))           return ERROR;       *e=S-&gt;top-&gt;data;       p=S-&gt;top;     //将栈顶结点赋值给p，见图3       S-&gt;top=S-&gt;top-&gt;next;   //使得栈顶指针下移一位，指向后一个结点，见图4       free(p);               //释放结点p       S-&gt;count--;       return OK;&#125;

使用建议：
如果栈的使用过程中元素变化不可预料，有时候小，有时候大，使用链栈。
如果变化在可控范围内，使用顺序栈。
栈的作用栈的引用同简化了程序设计的问题，划分了不同关注层次，使得思考范围缩小，更加聚焦我们要解决的问题核心。
栈的应用–递归递归：把一个直接调用自己或通过一系列的调用语句间接的调用自己的函数，称为递归函数。
例如：
int Fbi(int i)&#123;      if(i&lt;2)&#123;           return i == 0 ? 0 : 1;      &#125;      return Fbi(i-1)+Fbi(i-2);&#125;int main()&#123;       int i;       printf(&quot;递归显示斐波那契数列：\n&quot;);       for(i = 0;i&lt;40;i++)           printf(&quot;%d&quot;,Fbi(i));       return 0;&#125;

注意的是：每个递归定义必须至少有一个条件，满足递归不再进行，即不再引用自身而是返回值退出。
栈的应用–四则运算表达式求值后缀（逆波兰）表示法的定义一种不需要括号的后缀表达法，称为逆波兰
正常数学表达式：9+（3-1）x3+10÷2
后缀表达式：9 3 1-3 * + 10 2 &#x2F; +
后缀原因在于所有的符号都是在要运算数字的后面。
后缀表达式的计算结果后缀表达式：9 3 1-3 * + 10 2 &#x2F; +
规则：从左到右遍历表达式的每个数字和符号，遇到数字就进栈，遇到符号就将处于栈顶的两个数字出栈，进行运算，运算结果在进栈。
中缀表达式转后缀表达式正常数学表达式：9+（3-1）x3+10÷2也就是中缀表达式。
转换规则：从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，即后缀表达式的一部分。若是符号，判断其与栈顶符号的优先级，是右括号或优先级不高于栈顶符号（乘除优先加减）则栈顶元素一次出栈并输出，将当前符号进栈，一直到输出后缀表达式为止。
队列的定义队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。
队列是一种先进先出的线性表，简称FIFO。允许插入的一段称为队尾，允许删除的一端称为队头。
例如：q&#x3D;(a1,a2,…,an)，那么a1就是队头元素，an就是队尾。

队列的抽象数据类型ADT 队列(Queue)Data    同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。Operation    InitQueue(*Q):初始化操作，建立一个空队列Q    DestroyQueue(*Q):若队列Q存在，则销毁    ClearQueue(*Q):将队列Q清空    QueueEmpty(Q):若队列Q为空，返回ture，否则false    GetHead(Q,*Q):若队列Q存在且非空，用e返回队头元素    EnQueue(*Q,e):队列Q存在，插入新元素e到队列Q称为队尾元素    DeQueue(*Q,e):删除队列Q中队头元素，并用e返回其值    QueueLength(Q):返回队列Q的元素个数endADT

循环队列队列顺序存储的不足容易出现假溢出
循环队列的定义解决假溢出的办法就是后面满了，再从头开始，头尾相接的循环。这种队列头尾相接的顺序存储结构称为循环队列。
办法1：设置一个标志了flag，当front&#x3D;rear，且flag&#x3D;0时为队列空，当front&#x3D;rear，且flag&#x3D;1时为队列满。
办法2：当队列空时，条件时front&#x3D;rear。当队列满时，修改其条件，保留一个元素空间。也就是数，队列满时，数组还有一个空闲单元。

在第二种方法中，由于rear可能比front大，也可以比front小，若队列的最大尺寸为QueueSize，那么队列满的条件时(rear+1)%QueueSize&#x3D;&#x3D;front（取模的目的时为了整合rear与front大小为一个问题）。比如当QueueSize&#x3D;5，左边的图front&#x3D;0,而rear4，（4+1）%5&#x3D;0，所以此时队列满，再比如右图，front&#x3D;2而rear&#x3D;1，所以（1+1）%5&#x3D;2，所以队列也是满的，对于下图，ftont&#x3D;2,而rear&#x3D;0，(0+1)%5&#x3D;1，1≠2，所以此时队列没有满。

当rear&gt;front，即图1和图2，此时队列的长度为rear-front，但当rear&lt;front，如上图和下图3，队列长度分为两段，一段QueueSize-front，另一段时0+rear，加在一起的长度为rear-front+QueueSzie。

所以通用计算队列长度公式为
(rear - front + QueueSize)%QueueSize
循序队列的顺序存储结构代码如下：typedef int QElemType;typedef struct&#123;    QElemType data[MAXSIZE];    int front;  //头指针    int rear;   //尾指针，队列不为空，指向队列尾元素的下一个位置&#125;SqQueue;

循环队列的初始化代码Status InitQueue(SqQueue *Q)&#123;    Q-&gt;front=0;    Q-&gt;rear=0;    return OK;&#125;

循环队列求队列长度的代码//返回Q的元素个数，也就是队列的当前长度int QueueLength(SqQueue Q)&#123;  return (Q.rear - Q.front+MAXSIZE)%MAXSIZE;&#125;

循环队列的入列操作：Status EnQueue(SqQueue *Q,QElemType e)&#123;   if((Q-&gt;rear+1)%MAXSIZE==Q-&gt;front)&#123;   //队列满判断                  return ERROR;   &#125;    Q-&gt;data[Q-rear]=e;         //将元素e赋值给队尾    Q-&gt;rear=(Q-&gt;rear+1)%MAXSIZE; //rear指针向后移动一位，若为最后则转到数组头部    return OK;&#125;

循环队列如队列操作代码：Status EnQueue(SqQueue *Q,QElemType e)&#123;   if((Q-&gt;rear+1)%MAXSIZE==Q-&gt;front)//队列满的判断       return ERROR;   Q-&gt;data[Q-&gt;rear]=e;  //将元素e赋值给队尾   Q-&gt;rear=(Q-&gt;rear+1)%MAXSIZE; //rear指针向后移一位，若到最后则转到数组头部   return OK;&#125;

循环队列的出队列操作代码：Status DeQueue(SqQueue *Q,QElemType *e)&#123;     if(Q-&gt;front == Q-&gt;rear)         return ERROR;     *e=Q-&gt;data[Q-&gt;front];     Q-&gt;front=(Q-&gt;front+1)%MAXSIZE;&#125;

队列的链式存储结构及实现队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出，我们把它简称链队列。

将队头指针指向链队列的头结点，而队尾指针指向终端节点。空队列时，front和rear都指向头结点。
链队列的结构为：typedef int QElemType;typedef struct QNone     //结点结构&#123;     QElemType data;     struct QNone *next;&#125;QNone,*QueuePtr;typedef struct&#123;   QueuePtr front,rear;//队头、队尾指针&#125;

队列链式存储结构–入队操作入队操作，其实就是链表尾部插入结点
Status EnQueue(LinkQueue *Q,QElemType e)&#123;     QueuePtr s=(QueuePtr)malloc(sizeof(QNone));     if(!s)           //存储分配失败       exit(OVERFLOW);     s-&gt;data=e;     s-&gt;next=NULL;     Q-&gt;rear-&gt;next=s;  //把拥有元素e的新节点s赋值给原队尾结点的后继     Q-&gt;rear=s;  ///把当前的s设置为队尾结点，rear指向s     return OK;&#125;

队列的链式存储结构–出队操作出队操作，就是头结点的后继节点出队，将头结点的后继改为它后面的结点，若链表除头结点外只剩下一个元素，则需要将rear指向头结点。

Status DeQueue(LinkQueue *Q,QElemType *e)&#123;      QueuePtr p;      if(Q-&gt;front==Q-&gt;rear)             return ERROR;      p=Q-&gt;front-&gt;next;//将要删除的队头结点暂存到p      *e=p-&gt;data;     //将要删除的队头几点赋值给e      Q-&gt;front-&gt;next=p-next; //将队头结点的后继p-&gt;next赋值给头结点后继      if(Q-&gt;rear==p)   //若队头就是队尾，删除后将rear指向头结点         Q-&lt;rear=Q-&gt;front;      free(p);      retrun OK;&#125;

总结栈（stack）限定仅在表尾进行插入和删除操作的线性表。
队列（queue）是值允许在一端进行插入操作，而另外一端进行删除操作的线性表。
对于栈：如果两个相同数据类型的栈，则可以用数组的两段作栈底的地方来让两个栈共享数据，可以最大化利用数组的空间。
对于队列：为了避免数组插入和删除时需要移动数据，于是引用了循环队列，使得队头和队尾进行数组中循环变化，结局了移动数据的时间损耗。
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>第四章-自己创建函数库</title>
    <url>/2024/02/02/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%87%AA%E5%B7%B1%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0%E5%BA%93/</url>
    <content><![CDATA[

1、片上外设基地址#define PERIPH_BASE           ((unsigned int)0x40000000)

2、总线基地址#define AHB1PERIPH_BASE       (PERIPH_BASE + 0x00020000)

3、GPIO 外设基地址#define GPIOH_BASE            (AHB1PERIPH_BASE + 0x1C00)


&#x2F;&#x2F;H 高十位，L 低十位

]]></content>
      <categories>
        <category>野火STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>第四章-预处理</title>
    <url>/2023/08/14/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E9%A2%84%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[一、C 语言编译过程预处理、编译、汇编链接
gcc -E hello.c -o hello.i 1、预处理
gcc -S hello.i –o hello.s 2、编译
gcc -c hello.s -o hello.o 3、汇编
gcc hello.o -o hello_elf 4、链接
1、预编译
​ 将.c 的头文件、宏展开
​ 生成.i 文件
2、编译
​ 将预处理的.i 文件生成 .s 汇编文件
3、汇编
​ 将.s 汇编文件生成.o 目标文件
4、链接
​ .o 文件链接成目标文件
二、include#include&lt;&gt; 用尖括号包括头文件，在系统指定的路径找到头文件
#include”” 用双引号包括头文件，先在当前目录下找到头文件，找不到再系统指定的路径下找
三、define定义 宏用 define
1、不带参数的宏#define PI 3.14//终止宏的定义 定义#undef PI

2、带参宏#define S(a,b) a*b
注意带参宏的形参 ab 没有类名
S(2,4)在预处理代替成字符串的形参 2 * 4
#include &lt;stdio.h&gt;#define S(a,b) ((a)*(b))int main()&#123;    printf(&quot;%d\n&quot;,S(2,4));    //((2+8))*(4))=40    printf(&quot;%d\n&quot;,S(2 + 8,4));&#125;

3、带参宏和代餐函数的区​ 带参宏被调用多少次就会展开多少次，执行代码的时候没有函数调用的过程，不需要压栈弹栈。带参宏，浪费空间
​ 带参函数，代码只有一份，存放在代码段，调用的时候去代码段指令，调用的时候要压栈弹栈。带参函数浪费了时间，节省了空间
四、选择性编译1、
#ifdef AAA	代码段一#else	代码段二#endif//如果在当前.c ifdef上边定义AAA，就编译代码段一，否则编译代码段二 #include AAA int main()&#123;        #ifdef AAA        printf(&quot;hello kitty\n&quot;);        #else        printf(&quot;hello ddd&quot;);        #endif        return 0;    &#125;

2、
#ifndef AAA	代码段一#else	代码段二#endif //和第一种互补，用在防止头文件重复包含，用于多文件编程中.h的第一行就是#indef #endif结尾

3、
#if 表达式	代码块一#else	代码块二#endif//如果表达式为真，编译第一段，否则第二段//多用于注释多行代码
]]></content>
      <categories>
        <category>千锋C语言</category>
      </categories>
      <tags>
        <tag>嵌入式C</tag>
      </tags>
  </entry>
  <entry>
    <title>项目测试</title>
    <url>/2024/02/18/%E9%A1%B9%E7%9B%AE%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>项目</category>
      </categories>
  </entry>
  <entry>
    <title>黄山派之BLE</title>
    <url>/2025/08/20/%E9%BB%84%E5%B1%B1%E6%B4%BE%E4%B9%8BBLE/</url>
    <content><![CDATA[service服务

代码解析广播设备名称/* 获取设备蓝牙地址并生成包含MAC地址的设备名称 */ret = ble_get_public_address(&amp;addr);if (ret == HL_ERR_NO_ERROR)    rt_snprintf(local_name, 31, &quot;E_Badge&quot;); // 扫描出来的设备名称else    memcpy(local_name, DEFAULT_LOCAL_NAME, sizeof(DEFAULT_LOCAL_NAME));

自定义服务UUID(Unknown Service)/* 自定义服务UUID定义*/#define app_svc_uuid &#123;      \    0x73, 0x69, 0x66, 0x6c, \    0x69, 0x5f, 0x61, 0x70, \    0x70, 0x00, 0x00, 0x00, \    0x00, 0x00, 0x00, 0x00&#125;;/* 自定义特征UUID定义 */#define app_chara_uuid &#123;    \    0x73, 0x69, 0x66, 0x6c, \    0x69, 0x5f, 0x61, 0x70, \    0x70, 0x01, 0x00, 0x00, \    0x00, 0x00, 0x00, 0x00&#125;

服务UUID: 00000000-0000-0070-7061-5f696c666973
特征UUID: 00000000-0000-0170-7061-5f696c666973

]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>黄山派</tag>
        <tag>思澈</tag>
      </tags>
  </entry>
  <entry>
    <title>第八章 RCC使用HES/HSI</title>
    <url>/2024/03/21/%E7%AC%AC%E5%85%AB%E7%AB%A0%20RCC%E4%BD%BF%E7%94%A8HES/HSI/</url>
    <content><![CDATA[1、RCC主要作用 时钟部分设置系统时钟SYSCLK、设置AHB分频因子（决定HCLK等于多少）、设置APB2分频因子（决定PLCLK2等于多少）、设置APB1分频因子（决定PLK1等于多少）、设置各个外设的分配因子。控制 AHB、APB2 和 APB1 这三条总线时钟的开启、控制每个外设的时钟的开启。对于 SYSCLK、HCLK、PCLK2、PCLK1 这四个时钟的配置一般是：HCLK &#x3D; SYSCLK&#x3D;PLLCLK ，PCLK1&#x3D;HCLK&#x2F;2，PCLK1&#x3D;HCLK&#x2F;4 。
2、RCC时钟树库函数时钟系统始终函数：SetSysClock()。
HSE时钟树设置为：
HCLK&#x3D;SYSCLK&#x3D;PLLCLK&#x3D;180M（F429）
PCLK1&#x3D;HCLK&#x2F;2&#x3D;90M(F429)
PLCK1&#x3D;HCLK&#x2F;4&#x3D;45M(F429)

2.1系统时钟2.1.1HSE是高速的外部时钟信号，有无源&#x2F;有源晶振提供，频率4-26MHZ。
有源晶振，时钟从OSC_IN引脚进入，OSC_OUT引脚悬空。
无源晶振，时钟从OSC_IN,OSC_OUT进入，配合谐振电容。
2.1.2 锁相环PLLPLL的主要作用是对时钟进行倍频，然后将时钟输出到各个功能部分。
PLL和PLLI2S，他们由HSE或者HSI提供时钟输入信号。
主PLL有两路时钟输出，第一个输出时钟是PLLCLK用于系统时钟，F429最高时180M，第一个时用于USB OTG FS的时钟（48M）、RNG和SDIO时钟（&lt;&#x3D;48M）专门用于PLLI2S生成精准时钟，给I2S提供时钟。
HSE或者HSI经过PLL时钟输出分频因子M（2~63）分频后，称为VCO的时钟输入，VCO的时钟必须在1 ~2M，选择HSE&#x3D;25M作为PLL的时钟输入，M设置25，VCO输入时钟必须等于1M。
2.1.3 系统时钟SYSCLK系统时钟来源可以时HSI、PLLCLK、HSE，具体由时钟配置寄存器RCC_CFGR的SW位配置。SYSCLK&#x3D;PLLCLK&#x3D;180M。
如果系统时钟是由HSE经过PLL倍频之后的PLLCLK得到，当HSE出现故障的时候，系统时钟会切换HSI&#x3D;16M，知道HSE恢复正常。
2.1.4 AHB总线时钟HCLK系统时钟经过AHB预分频器分频之后得到的时钟是叫AHB总线时钟，就是HCLK，分频因子可以是[1,2,4,16,64,128,256,512]，具体由时钟配置寄存器RCC_CFGR的HPRE
位设置。片上大部分外设时钟都是HCLK分频德奥，AHB总线的外设设置时使用外设的时候设置。
2.1.5 APB2总线时钟PCLK2AHB2总线是由PCLK2由HCLK经过高速APB2预分频器得到，分频因子可以是[1,2,4,16]，由时钟配置寄存器RCC_CFGR的PRPE2位设置。PCLK2属于高速的总线时钟，片上高速的外设就挂载到这条总线，比如全部的GPIO、USART1、SPI1等。
2.1.6 APB1 总线时钟PCLK1APB1总线时钟PCLK1由HCLK经过低速APB预分频器得到，分频因子可以是[1,2,4,16]，由RCC_CFGR的PPRE2位设置。PCLK2属于低速的总线时钟，最高为45M（F429），片上低速的外设挂载到这条总线上，比如USART2&#x2F;4&#x2F;5，SPI2&#x2F;3，I2C1&#x2F;2。
]]></content>
      <categories>
        <category>野火STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>第十章 EXTI-外部中断/事件控制器</title>
    <url>/2024/05/09/%E7%AC%AC%E5%8D%81%E7%AB%A0%20EXTI-%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD/%E4%BA%8B%E4%BB%B6%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
    <content><![CDATA[一、EXTI介绍外部中断&#x2F;事件控制器（EXTI）管理控制器的23个中断&#x2F;时间线，都有一个对应的一个边沿检测器，实现输入信号的上升沿和下降沿检测，都可以实现对每个中断&#x2F;事件进行单独配置，可以单独配置中断或事件和触发事件的属性。

（EXTI是在APB2总线上的）
1、红色虚线和绿色虚线分别是 产生中断的线路，信号流入到NVIC控制器。
2、绿色虚线是产生事件的线路，输出一个脉冲信号。
3、输入线，EXTI有23个中断&#x2F;事件输入先，可以为任意一个GPIO，也可以是外设的事件。
4、边沿检测电路，根据上升沿触发寄存器（EXTI_RTSR）和下降沿触发选择寄存器（EXTI_FTSR）对应位控制信号触发。
5、软件中事件寄存器（EXTI_SWIER），允许程序控制可以启动中断&#x2F;时间线。
6、中断屏蔽寄存器（EXTI_IMR），可以简单控制EXTI_IMR来实现产生中断的目的。
7、挂起寄存器（EXTI_PR），内容输出到NVIC，实现系统中断事件中断控制。
8、事件屏蔽寄存器（EXTI_EMR），控制它来实现是否产生事件的目的。
二、编程要点1、初始化RGB
2、开启按键GPIO和SYSCFG时钟
3、配置NVIC
4、配置按键GPIO为输入
5、按键连接到EXTI源输入
6、配置按键EXTI中断&#x2F;事件线
7、编写EXTI中断服务函数
]]></content>
      <categories>
        <category>野火 STM32</category>
      </categories>
      <tags>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>利用MQTT连接华为IOT平台，进行数据上报与下发</title>
    <url>/2024/03/09/%E5%88%A9%E7%94%A8MQTT%E8%BF%9E%E6%8E%A5%E5%8D%8E%E4%B8%BAIOT%E5%B9%B3%E5%8F%B0%EF%BC%8C%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E4%B8%8A%E6%8A%A5%E4%B8%8E%E4%B8%8B%E5%8F%91/</url>
    <content><![CDATA[一、查看接入信息
二、创建产品
三、注册设备
]]></content>
      <categories>
        <category>华为IOT平台连接</category>
      </categories>
      <tags>
        <tag>HarmonyOS</tag>
      </tags>
  </entry>
</search>
